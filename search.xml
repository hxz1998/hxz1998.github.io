<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++中push_back和emplace_back的区别</title>
    <url>/2020/09/02/CPP%E4%B8%ADpush-back%E5%92%8Cemplace-back%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>在 <code>C++11</code> 之后，<code>vector</code> 容器中添加了新的方法：<code>emplace_back()</code> ，和 <code>push_back()</code> 一样的是都是在容器末尾添加一个新的元素进去，不同的是 <code>emplace_back()</code> 在效率上相比较于 <code>push_back()</code> 有了一定的提升。</p>
<a id="more"></a>

<h1 id="1-push-back-方法"><a href="#1-push-back-方法" class="headerlink" title="1. push_back() 方法"></a>1. <code>push_back()</code> 方法</h1><p>首先分析较为简单直观的 <code>push_back()</code> 方法。对于 <code>push_back()</code> 而言，最开始只有 <code>void push_back( const T&amp; value );</code> 这个函数声明，后来从 <code>C++11</code> ，新加了<code>void push_back( T&amp;&amp; value )</code> 函数，以下为 <code>C++</code> 中的源码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以下程序来自STL源码 bits/stl_vector.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @brief  Add data to the end of the %vector.</span></span><br><span class="line"><span class="comment"> *  @param  __x  Data to be added.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This is a typical stack operation.  The function creates an</span></span><br><span class="line"><span class="comment"> *  element at the end of the %vector and assigns the given data</span></span><br><span class="line"><span class="comment"> *  to it.  Due to the nature of a %vector this operation can be</span></span><br><span class="line"><span class="comment"> *  done in constant time if the %vector has preallocated space</span></span><br><span class="line"><span class="comment"> *  available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type &amp;__x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage) &#123;</span><br><span class="line">        <span class="comment">// 首先判断容器满没满，如果没满那么就构造新的元素，然后插入新的元素</span></span><br><span class="line">        _Alloc_traits::construct(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                                 __x);</span><br><span class="line">        ++<span class="keyword">this</span>-&gt;_M_impl._M_finish; <span class="comment">// 更新当前容器内元素数量</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果满了，那么就重新申请空间，然后拷贝数据，接着插入新数据 __x</span></span><br><span class="line">        _M_realloc_insert(<span class="built_in">end</span>(), __x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 C++ 版本为 C++11 及以上（也就是从 C++11 开始新加了这个方法），使用 emplace_back() 代替</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(value_type &amp;&amp;__x)</span> </span>&#123;</span><br><span class="line">    emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(__x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在 <code>C++20</code> 之后，对这两个重载方法进行了修改，变成了 <code>constexpr void push_back( const T&amp; value );</code> 以及 <code>constexpr void push_back( T&amp;&amp; value );</code> 。详情参考 <code>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1004r2.pdf</code> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1004r2.pdf">版本修改计划</a>。</p>
<h1 id="2-emplace-back-方法"><a href="#2-emplace-back-方法" class="headerlink" title="2. emplace_back() 方法"></a>2. <code>emplace_back()</code> 方法</h1><p><code>emplace_back()</code> 是从 <code>C++11</code> 起新增到 <code>vector</code> 中的方法，最初的函数声明为： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; class... Args &gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>

<p>之后在 <code>C++14</code> 之后，将无返回值 <code>void</code> 改为了返回对插入元素的引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; class... Args &gt;</span><br><span class="line"><span class="function">reference <span class="title">emplace_back</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>STL</code> 源码中，可以看到 <code>emplace_back()</code> 的实现是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以下程序来自STL源码 bits/vector.tcc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt; 201402L</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;::reference</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;::emplace_back(_Args &amp;&amp;... __args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage) &#123;</span><br><span class="line">        <span class="comment">// 同样判断容器是否满了，没满的话，执行构造函数，对元素进行构造，并执行类型转换</span></span><br><span class="line">        _Alloc_traits::construct(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                                 <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">        ++<span class="keyword">this</span>-&gt;_M_impl._M_finish; <span class="comment">// 更新当前容器大小</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 满了的话重新申请内存空间，将新的元素继续构造进来，并且进行类型转换</span></span><br><span class="line">        _M_realloc_insert(<span class="built_in">end</span>(), <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt; 201402L</span></span><br><span class="line">    <span class="keyword">return</span> back(); <span class="comment">// 在 C++14版本之后，添加返回值，返回最后一个元素的引用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>将 <code>emplace_back()</code> 和 <code>push_back()</code> 中区别最大的程序拎出来看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_Alloc_traits::construct(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                                 <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...); <span class="comment">// emplace_back()</span></span><br><span class="line">_Alloc_traits::construct(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                                 __x);                            <span class="comment">// push_back()</span></span><br></pre></td></tr></table></figure>

<p>对于 <code>std::forward()</code> 函数而言，本质上是一个类型转换函数，它的声明函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以下程序来自STL源码 bits/move.h</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an lvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp &amp;&amp;<span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type &amp;<span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp &amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在强制类型转换中，将参数 <code>__t</code> 传递给对应类 <code>_Tp</code> 的构造函数，然后调用了该类的构造函数从而完成对象创建过程。</strong></p>
<p>因此，在 <code>emplace_back()</code> 函数中，是支持直接将构造函数所需的参数传递过去，然后构建一个新的对象出来，然后填充到容器尾部的。</p>
<h1 id="3-直观区别"><a href="#3-直观区别" class="headerlink" title="3. 直观区别"></a>3. 直观区别</h1><p>声明一个 <code>Person</code> 类，里面只有一个字段 <code>_age</code> ，在容器中存储该类的对象，方便于查看整个函数调用过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age) : _age(age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct a person.&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;p) : _age(p._age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy-Construct&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;&amp;p) <span class="keyword">noexcept</span>: _age(p._age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move-Construct&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先使用 <code>push_back()</code> 方法添加创建好的元素，可以看出使用到了<strong>拷贝构造函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; person;</span><br><span class="line">    <span class="keyword">auto</span> p = Person(<span class="number">1</span>); <span class="comment">// &gt;: Construct a person.1</span></span><br><span class="line">    person.push_back(p);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Copy-Construct1 因为容器扩容，需要把前面的元素重新添加进来，因此需要拷贝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再使用 <code>emplace_back()</code> 函数添加元素进来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; person;</span><br><span class="line">    <span class="keyword">auto</span> p = Person(<span class="number">1</span>); <span class="comment">// &gt;: Construct a person.1</span></span><br><span class="line">    person.emplace_back(<span class="built_in">move</span>(p)); <span class="comment">// &gt;: Move-Construct1</span></span><br><span class="line">    person.emplace_back(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Construct a person.2  // 构建一个新的元素</span></span><br><span class="line"><span class="comment">     * &gt;: Move-Construct1       // 拷贝之前的元素过来，这个时候用的是 Person(const Person &amp;&amp;p)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到直接使用<strong>构造参数列表</strong>来添加元素的方法，它会使用到了移动构造函数 <code>move</code> 。这也是 <code>emplace_back()</code> 方法的一大特色。</p>
<h1 id="4-性能分析"><a href="#4-性能分析" class="headerlink" title="4. 性能分析"></a>4. 性能分析</h1><p><code>emplace_back()</code> 函数在原理上比 <code>push_back()</code> 有了一定的改进，包括在内存优化方面和运行效率方面。内存优化主要体现在使用了<strong>就地构造（直接在容器内构造对象，不用拷贝一个复制品再使用）+强制类型转换</strong>的方法来实现，在运行效率方面，由于省去了拷贝构造过程，因此也有一定的提升。</p>
<p>以下程序源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/3.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/3 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age) : _age(age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct a person.&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;p) : _age(p._age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy-Construct&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;&amp;p) <span class="keyword">noexcept</span>: _age(p._age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move-Construct&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_EMPLACE_BACK</span></span><br><span class="line"><span class="comment">//#define TEST_PUSH_BACK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; person;</span><br><span class="line">    <span class="keyword">auto</span> p = Person(<span class="number">1</span>); <span class="comment">// &gt;: Construct a person.1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST_EMPLACE_BACK</span></span><br><span class="line">    person.emplace_back(<span class="built_in">move</span>(p)); <span class="comment">// &gt;: Move-Construct1</span></span><br><span class="line">    person.emplace_back(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Construct a person.2  // 构建一个新的元素</span></span><br><span class="line"><span class="comment">     * &gt;: Move-Construct1       // 拷贝之前的元素过来，这个时候用的是 Person(const Person &amp;&amp;p)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST_PUSH_BACK</span></span><br><span class="line">    person.push_back(p);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Copy-Construct1 因为容器扩容，需要把前面的元素重新添加进来，因此需要拷贝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>源码分析</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的lambda表达式探究</title>
    <url>/2020/08/30/CPP%E4%B8%AD%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>在 <code>C++11</code> 及之后的版本中，<code>C++</code> 提供了 <code>lambda</code> 表达式，它是一种方便了参数传递和定义匿名函数的方法。该方法通常用于封装算法、执行异步方法 ，也就是说比较适用于少量的代码。以下原文：</p>
<blockquote>
<p>In C++11 and later, a lambda expression—often called a <em>lambda</em>—is a convenient way of defining an anonymous function object (a <em>closure</em>) right at the location where it is invoked or passed as an argument to a function. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous methods. This article defines what lambdas are, compares them to other programming techniques, describes their advantages, and provides a basic example. </p>
</blockquote>
<a id="more"></a>

<h1 id="1-Lambda-表达式的组成"><a href="#1-Lambda-表达式的组成" class="headerlink" title="1. Lambda 表达式的组成"></a>1. <code>Lambda</code> 表达式的组成</h1><p>先对 <code>lambda</code> 表达式有一个直观的认识，参考下面程序，该程序完成的是将输入的数组 <code>nums</code> 按照绝对值大小进行升序排列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) <span class="keyword">mutable</span> <span class="keyword">throw</span>() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="comment">// lambda 表达式函数体，在这里做到了将输入数组升序排列</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(b));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">// &gt;: 1 -1 2 3 4 5 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛开边边角角，单独拿出最重要的一部分来学习，<code>[](int a, int b) mutable throw() -&gt; bool&#123; // statement &#125;</code> 就是 <code>lambda</code> 表达式最原始的内容。在该表达式中，每一部分的含义如下叙述：</p>
<ol>
<li><code>[]</code> 捕获子句：用来捕获<strong>周围范围</strong>中出现的变量，也被称为<strong>引导</strong>子句，可以在其中声明获取的变量是按<strong>值</strong>访问还是<strong>引用</strong>来访问<del>，默认值为 <code>&amp;</code> ，上文中的例子和 <code>[&amp;]</code> 是一样的效果，</del>具体例子见下文。</li>
<li><code>()</code> 参数列表：用来获取参数，对于一个一般的 <code>lambda</code> 函数，使用起来和一般的指针函数没有区别，也是需要有参数列表的，具体例子见下文。</li>
<li><code>mutable</code> 可变类型（可选）：一般来说，在 <code>lambda</code> 体中调用运算符的变量，都是以 <code>const value</code> 来使用的，加上这个 <code>mutable</code> 之后，人家变成了变量来使用，具体栗子见下文。</li>
<li><code>throw()</code> 异常类型（可选）：和普通函数一样样，<code>lambda</code> 函数也可能引发异常，如果不会引发异常的话，直接声明 <code>noexcept</code> 就可以啦~</li>
<li><code>-&gt; bool</code> 返回类型（可选）：继续和普通函数一样</li>
<li><code>&#123;// statement &#125;</code> <code>lambda</code> 体：和一般的函数体一样。</li>
</ol>
<p>不难发现，<code>lambda</code> 函数和一般的函数没有太大区别，基本上只有在头部位置有特殊语法。</p>
<h1 id="2-捕获语句的使用-amp-可变规范-mutable"><a href="#2-捕获语句的使用-amp-可变规范-mutable" class="headerlink" title="2. 捕获语句的使用 &amp; 可变规范 mutable"></a>2. 捕获语句的使用 &amp; 可变规范 <code>mutable</code></h1><p>拿出栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>; <span class="comment">// 在上文中声明好变量 num</span></span><br><span class="line">    <span class="keyword">auto</span> f = [n = num]() &#123; <span class="comment">// 在下文中通过 捕获[] 来获取 num，并在 lambda 函数体中进行使用</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; ++num &lt;&lt; std::endl; // 错误的使用，因为 num 是不可变的常量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    f(); <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="keyword">auto</span> m = [num]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 将内部变量声明成 mutable 可变类型，此时可以修改内部变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    m(); <span class="comment">// &gt;: 2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del><code>mutable</code> 可变声明优势在于可以在内部直接改变外部变量，相当于使用了 <code>[&amp;num]</code> 引用方法。</del></p>
<p><strong>2020年9月1日 修正：</strong> 在 <code>C++14</code> 及以后的版本中，可以通过 <code>capture</code> 语句从周围（Surrounding Scope）捕获变量，在 <code>[]</code> 子句中指定要捕获哪些变量，以及按照何种方式使用它们。和普通语法一样，带有 <code>＆</code> 前缀的变量可以通过<strong>引用</strong>进行访问，而没有前缀 <code>＆</code> 的变量可以通过值进行访问。<strong>而空的捕获子句[]表示 <code>lambda</code> 表达式的主体在闭包范围内不访问外部任何变量。</strong> 当然~，也可以使用默认的捕获模式来指示如何捕获 <code>lambda</code> 中引用的任何外部变量：<code>[＆]</code> 表示周围所有变量都是通过引用捕获的，而 <code>[=]</code> 意味着它们按值所捕获。</p>
<p>一般情况下，<code>lambda</code>的函数调用运算符是<strong>常量值</strong>，但是使用 <code>mutable</code> 关键字可以修改默认值，<code>mutable</code> 使 <code>lambda</code> 表达式的函数体可以修改按值捕获的变量。</p>
<h1 id="3-参数列表"><a href="#3-参数列表" class="headerlink" title="3. 参数列表"></a>3. 参数列表</h1><p>再拿出一个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> y = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; y(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// &gt;: 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里开始，也就是参数列表开始，后面的内容都是可选项，也就是如果为空，那么就直接<strong>省略</strong>不写即可。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> empty = [] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Wow!空的~&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 啥也没有只有个函数体&#125;;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    empty(); <span class="comment">// &gt;: Wow!空的~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-特殊用法"><a href="#4-特殊用法" class="headerlink" title="4. 特殊用法"></a>4. 特殊用法</h1><h2 id="4-1-花里胡哨的-lambda-嵌套"><a href="#4-1-花里胡哨的-lambda-嵌套" class="headerlink" title="4.1 花里胡哨的 lambda 嵌套"></a>4.1 花里胡哨的 <code>lambda</code> 嵌套</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两层 lambda 嵌套，看起来挺花里胡哨</span></span><br><span class="line">    <span class="keyword">auto</span> embed_embed_lambda = [](<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; - - &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> [](<span class="keyword">int</span> c) &#123; <span class="keyword">return</span> c / <span class="number">2</span>; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; embed_embed_lambda(<span class="number">2</span>)(<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2 - - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-高阶-lambda-函数"><a href="#4-2-高阶-lambda-函数" class="headerlink" title="4.2 高阶 lambda 函数"></a>4.2 高阶 <code>lambda</code> 函数</h2><p>高阶函数是指，采用另一个 <code>lambda</code> 表达式作为其参数或返回 <code>lambda</code> 表达式的 <code>lambda</code> 表达式（不知不觉想起了俄罗斯套娃🤔）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回 function 对象的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> get_function = [](<span class="keyword">int</span> x) -&gt; <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用 function 为对象作为其参数的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> param_function = [](<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &amp;f, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> f(n) * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> ans = param_function(get_function(<span class="number">2</span>), <span class="number">3</span>); <span class="comment">// x = 2, n = 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.  总结"></a>5.  总结</h1><p>写到此处，关于 <code>C++</code> 的 <code>lambda</code> 语法规范和用法已经学习了一小部分，它作为一种方便灵活的方法随用随学也是阔以的。</p>
<blockquote>
<p>因为参数类型和函数模板参数一样可以被推导而无需和具体参数类型耦合，有利于重构代码；和使用auto声明变量的作用类似，它也允许避免书写过于复杂的参数类型。特别地，不需要显式指出参数类型使得使用高阶函数变得更加容易。</p>
</blockquote>
<p>以下程序源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/8/30.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/8/30 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b) <span class="keyword">mutable</span> <span class="keyword">throw</span>() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="comment">// lambda 表达式函数体，在这里做到了将输入数组升序排列</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(b));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">// &gt;: 1 -1 2 3 4 5 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>; <span class="comment">// 在上文中声明好变量 num</span></span><br><span class="line">    <span class="keyword">auto</span> f = [n = num]() &#123; <span class="comment">// 在下文中通过 捕获[] 来获取 num，并在 lambda 函数体中进行使用</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; ++num &lt;&lt; std::endl; // 错误的使用，因为 num 是不可变的常量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    f(); <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="keyword">auto</span> m = [num]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 将内部变量声明成 mutable 可变类型，此时可以修改内部变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    m(); <span class="comment">// &gt;: 2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> y = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; y(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// &gt;: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> empty = [] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Wow!空的~&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 啥也没有只有个函数体&#125;;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    empty(); <span class="comment">// &gt;: Wow!空的~</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个函数，然后直接使用 (5, 3)</span></span><br><span class="line">    <span class="keyword">int</span> n = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两层 lambda 嵌套，看起来挺花里胡哨</span></span><br><span class="line">    <span class="keyword">auto</span> embed_embed_lambda = [](<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; - - &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> [](<span class="keyword">int</span> c) &#123; <span class="keyword">return</span> c / <span class="number">2</span>; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; embed_embed_lambda(<span class="number">2</span>)(<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2 - - 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 function 对象的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> get_function = [](<span class="keyword">int</span> x) -&gt; <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 function 为对象作为其参数的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> param_function = [](<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &amp;f, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> f(n) * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ans = param_function(get_function(<span class="number">2</span>), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的unordered_map和map的区别</title>
    <url>/2020/09/01/CPP%E4%B8%AD%E7%9A%84unordered-map%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><code>unordered_map</code> 类模板和 <code>map</code> 类模板都是描述了这么一个对象：它是由 <code>std::pair&lt;const Key, value&gt;</code> 组成的可变长容器，这个容器中每个元素存储两个对象，也就是 <code>key</code> - <code>value</code> 对。</p>
<a id="more"></a>

<h1 id="1-unordered-map"><a href="#1-unordered-map" class="headerlink" title="1. unordered_map"></a>1. <code>unordered_map</code></h1><p>在头文件上，引入 <code>&lt;unordered_map&gt;</code> 来使用它。对于 <code>unordered_map</code> 而言，最大的特点在于内部实现上，使用到了<strong>哈希表</strong>（散列表、<code>hash_table</code> ）来进行映射存储，它的模板类声明及其参数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序来自STL源码 bits/unordered_map.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key,  <span class="comment">// key 类型 </span></span><br><span class="line">        <span class="keyword">typename</span> _Tp,    <span class="comment">// value 类型</span></span><br><span class="line">        <span class="keyword">typename</span> _Hash = hash &lt;_Key&gt;,     <span class="comment">// 哈希函数</span></span><br><span class="line">        <span class="keyword">typename</span> _Pred = equal_to &lt;_Key&gt;, <span class="comment">// 用于比较两者是否相同的函数</span></span><br><span class="line">        <span class="keyword">typename</span> _Alloc = allocator &lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">const</span> _Key, _Tp&gt;&gt;&gt; <span class="comment">// 分配器，描述了容器在内存管理上的细节，不应该自己来处理，除非写自己的容器</span></span><br><span class="line">class <span class="built_in">unordered_map</span> &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>unordered_map</code> 内部，使用的 <code>Hash Table</code> 对数据进行组织，通过把键值 <code>key</code> 映射到 <code>hash</code> 表中的一个位置进行访问，根据 <code>hash</code> 函数的特点， <code>unordered_map</code> 对于元素查找的时间复杂度可以达到 <code>O(1)</code> ，但是，它的元素排列是无序的。具体例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="comment">// 首先创建一个无序 map，它的 key 使用 int 类型，value 使用 string 类型</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; unorderedMap;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 三种插入新元素的方法，“茴”字有三种写法~</span></span><br><span class="line">    unorderedMap.insert(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="string">&quot;Alice&quot;</span>)); </span><br><span class="line">    unorderedMap[<span class="number">1</span>] = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    unorderedMap.insert(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">2</span>, <span class="string">&quot;Candy&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 对内部元素挨个输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = unorderedMap.<span class="built_in">begin</span>(); iter != unorderedMap.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * &gt;: 输出如下，可以得知它们在 key 的排序上并没有顺序</span></span><br><span class="line"><span class="comment">         * 2 - Candy</span></span><br><span class="line"><span class="comment">         * 0 - Alice</span></span><br><span class="line"><span class="comment">         * 1 - Bob</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>unordered_map</code> 由于建立了哈希表，所以它在最开始建立的时候比较耗时间，但是它查询速度快呀~，一般情况下用 <code>unordered_map</code> 是没有问题的。</p>
<h1 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. <code>map</code></h1><p>对于 <code>map</code> 而言，首先在头文件上，引用 <code>&lt;map&gt;</code> 进来，然后使用。它的类模板声明以及部分函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序来自C++源码 bits/stl_map.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key,  <span class="comment">// key 类型</span></span><br><span class="line">        <span class="keyword">typename</span> _Tp,    <span class="comment">// value 类型</span></span><br><span class="line">        <span class="keyword">typename</span> _Compare = <span class="built_in">std</span>::less&lt;_Key&gt;, <span class="comment">// 用于比较两个元素的比较函数</span></span><br><span class="line">        <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt; &gt; <span class="comment">// 分配器，同样的描述了容器在内存管理上的细节，不应该自己来处理，除非写自己的容器</span></span><br><span class="line">class <span class="built_in">map</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 将一个红黑树转换成 [multi]map.</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::<span class="keyword">template</span></span><br><span class="line">    rebind&lt;value_type&gt;::other _Pair_alloc_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree&lt;key_type, value_type, _Select1st&lt;value_type&gt;,</span><br><span class="line">    key_compare, _Pair_alloc_type&gt; _Rep_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>map</code> 的内部，使用了<strong>红黑树</strong>（<code>red-black tree</code>）来组织数据，因此默认的就已经实现了数据的排序。从下面例子中可以看出，它默认实现了在 <code>key</code> 上排序实现递增：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapper;</span><br><span class="line">    mapper.insert(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">    mapper[<span class="number">1</span>] = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    mapper.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">2</span>, <span class="string">&quot;Candy&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter : mapper) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; iter.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * &gt;: 输出如下，很明显的，它们在 key 的排序上是递增排列的</span></span><br><span class="line"><span class="comment">         * 0 - Alice</span></span><br><span class="line"><span class="comment">         * 1 - Bob</span></span><br><span class="line"><span class="comment">         * 2 - Candy</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，在存储上 <code>map</code> 却比较占用空间，因为在红黑树中，每一个节点都要额外保存父节点和子节点的连接，因此使得每一个节点都占用较大空间来维护红黑树性质。</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>两种数据结构特点如下表格~</p>
<table>
<thead>
<tr>
<th></th>
<th><code>unordered_map</code></th>
<th align="left"><code>map</code></th>
</tr>
</thead>
<tbody><tr>
<td>查找</td>
<td><strong>快</strong>，Average：<code>O(1)</code> ，Worst Case：<code>O(n)</code></td>
<td align="left">恒定的 <code>log(n)</code></td>
</tr>
<tr>
<td>插入</td>
<td>和上面一样</td>
<td align="left"><code>log(n)</code> + 平衡二叉树所用时间</td>
</tr>
<tr>
<td>删除</td>
<td>还和上面一样</td>
<td align="left"><code>log(n)</code> + 平衡二叉树所用时间</td>
</tr>
<tr>
<td>是否排序</td>
<td>不排序</td>
<td align="left"><strong>排序</strong></td>
</tr>
<tr>
<td>实现方法</td>
<td>哈希表</td>
<td align="left">红黑树</td>
</tr>
<tr>
<td>适用于</td>
<td>查找操作频率高</td>
<td align="left">要求结果有序（按 <code>key</code> 排序）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>哈希表</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的可变参数模板</title>
    <url>/2020/09/08/CPP%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>C++可变参数模板，是指能够使用任意数量参数的函数或类模板，能够很有效的提升灵活性。</p>
<a id="more"></a>

<h1 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h1><h2 id="1-1-可变类模板"><a href="#1-1-可变类模板" class="headerlink" title="1.1 可变类模板"></a>1.1 可变类模板</h2><p>对于可变类模板，基本示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arguments&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span>;</span></span><br></pre></td></tr></table></figure>

<p>由上式可知，其特殊性在于 <code>...</code> 的使用，可变参数模板，通过使用 <code>...</code> 来帮助定义，其中，<code>...</code> 左侧为参数包（<code>parameter pack</code> ），右侧将参数包展开成多个单独的参数。</p>
<p>对于两边的空白可以任意分布，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Arguments&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Arguments&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span>;</span></span><br></pre></td></tr></table></figure>

<p>上面的类 <code>classname</code> 可以接收任意数量的参数来进行实例化，例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">classname&lt;&gt; <span class="title">c1</span><span class="params">()</span></span>;</span><br><span class="line">classname&lt;float, int&gt; c2();</span><br><span class="line">classname&lt;float, std::string, std::vector&lt;int&gt;&gt; c3();</span><br></pre></td></tr></table></figure>

<p>当然，还可以指定必须填充固定数量的参数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> first, <span class="keyword">typename</span>... Arguments&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// classname2&lt;&gt; c4(); 这是错误的用法！参数必须大于等于 1</span></span><br><span class="line"><span class="function">classname2&lt;<span class="keyword">float</span>&gt; <span class="title">c4</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-可变参数的函数模板"><a href="#1-2-可变参数的函数模板" class="headerlink" title="1.2 可变参数的函数模板"></a>1.2 可变参数的函数模板</h2><p>可变参数的函数模板基本示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(Params... params)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当然，还可以使用引用类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(Params *... params)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(Params &amp;... params)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(Params &amp;&amp;... params)</span></span>;</span><br></pre></td></tr></table></figure>

<p>还可以使用不变类型 <code>const</code> 来修饰：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(<span class="keyword">const</span> Params &amp;... params)</span></span>;</span><br></pre></td></tr></table></figure>

<p>除此之外，还可以使用和可变参数的类模板用法一样，指定固定数量的参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(<span class="keyword">const</span> First &amp;first, <span class="keyword">const</span> Params... params)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="2-测量可变参数数量"><a href="#2-测量可变参数数量" class="headerlink" title="2. 测量可变参数数量"></a>2. 测量可变参数数量</h1><p>使用 <code>sizeof</code> 来完成，当然，该方法和之前测量字节大小的 <code>sizeof</code> 不是同一个用法，这里的 <code>sizeof</code> 是用来测量提供了多少个参数，示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tfunc</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(params) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tfunc();        <span class="comment">// &gt;: 0</span></span><br><span class="line">    tfunc(<span class="number">1</span>);       <span class="comment">// &gt;: 1</span></span><br><span class="line">    tfunc(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// &gt;: 2</span></span><br><span class="line">    tfunc(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello~YouLi~&quot;</span>);    <span class="comment">// &gt;: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-示例程序"><a href="#3-示例程序" class="headerlink" title="3. 示例程序"></a>3. 示例程序</h1><p>下面程序演示了如何使用 <strong>可变参数模板</strong> 来对函数进行重写定义并使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/8.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/8 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Rest&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> First &amp;first, <span class="keyword">const</span> Rest &amp;...rest)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(rest...); <span class="comment">// 将会根据语法来递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>();    <span class="comment">// &gt;:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>); <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// &gt;: 10, 20</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">3.14</span>, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// &gt;: 10, 20, Alice, 3.14, Bob</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>对于可变参数模板而言，都是使用某种形式的递归，但是它与传统递归是不一样的。传统的递归使用的是一样的函数声明，但是可变参数模板使用的是不同参数数量的函数<strong>（每次都会递减）</strong>声明，从而每次都区分出当前次使用的函数签名。和一般的递归一样，都需要一个终止递归的 <strong>base-line</strong> 条件，但是这里的含义不同。</p>
<blockquote>
<p>参考自 Ellipsis and Variadic Templates： <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/ellipses-and-variadic-templates?view=vs-2019">https://docs.microsoft.com/zh-cn/cpp/cpp/ellipses-and-variadic-templates?view=vs-2019</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <url>/2020/08/28/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1. 准备环境"></a>1. 准备环境</h1><p>所需软件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.js	-&gt; v12.18.3</span><br><span class="line">npm     -&gt; 6.14.6 </span><br><span class="line">Git     -&gt; 2.16.2.windows1</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 <code>Hexo</code></h1><p>首先在自己的磁盘里创建一个目录，例如 <code>C:\Blog</code>，打开命令行工具，然后输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:                      <span class="comment"># 进入C盘</span></span><br><span class="line"><span class="built_in">cd</span> Blog	                <span class="comment"># 进入 Blog 文件夹</span></span><br><span class="line">npm install -g hexo-cli <span class="comment"># 安装 hexo 这个过程超级漫长，建议去喝一杯咖啡，如果没有修改 npm 的镜像源的话</span></span><br></pre></td></tr></table></figure>
<p>假如上面的过程没有出现什么幺蛾子，没有报错，也没有警告，那么恭喜，现在来到了 <code>hexo</code> 软件。</p>
<h1 id="3-在-Github-创建-Pages"><a href="#3-在-Github-创建-Pages" class="headerlink" title="3. 在 Github 创建 Pages"></a>3. 在 <code>Github</code> 创建 <code>Pages</code></h1><p>这里有两种创建的方法，可以创建<strong>仓库</strong>归属的 <code>Pages</code>，也可以创建<strong>帐户</strong>归属的 <code>Pages</code>，这里创建的是后者（账户归属），不为别的，因为好看。两者的区别主要在：</p>
<ol>
<li>仓库归属的最终访问路径为：<code>https://github.com/&#123;username&#125;/&#123;repo&#125;</code></li>
<li>账户归属的最终访问路径为：<code>https://&#123;username&#125;.github.io/</code></li>
</ol>
<p>在创建过程中，需要把仓库名称设置为自己的账户名称这样才能实现上面的第二种。</p>
<h1 id="4-创建本地博客并本地预览"><a href="#4-创建本地博客并本地预览" class="headerlink" title="4. 创建本地博客并本地预览"></a>4. 创建本地博客并本地预览</h1><p>回到第 2 步的命令行中，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog     <span class="comment"># 初始化博客仓库</span></span><br><span class="line">hexo new HelloHexo <span class="comment"># 创建第一篇文章</span></span><br></pre></td></tr></table></figure>

<p>然后可以到目录 <code>C:\Blog\source\_post</code> 目录下看到 <code>HelloHexo.md</code> 文件，找一个称手的 <code>MarkDown</code> 编辑器，通过修改该文件内容来完成内容编写。</p>
<p>修改完成后，继续回到上面的命令行中，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean    <span class="comment"># （可选）清除缓存，方便后面重新生成 hexo c</span></span><br><span class="line">hexo generate <span class="comment"># 生成相关页面，也可以 hexo g</span></span><br><span class="line">hexo server   <span class="comment"># 启动本地预览，也可以 hexo s</span></span><br></pre></td></tr></table></figure>

<p>然后就可以在 <code>http://localhost:4000/</code> 中看到自己的博客预览了，如果成功看到，那么恭喜，可以再喝一杯咖啡了😝。</p>
<h1 id="5-2020年9月1日更新"><a href="#5-2020年9月1日更新" class="headerlink" title="5.  2020年9月1日更新"></a>5.  2020年9月1日更新</h1><p>当使用 <code>hexo s</code> 来启动本地服务，然后进去网页报类似于 <code>(node:23020) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency</code> 错误时，需要将 <code>node</code> 从 <code>14</code> 版本降为 <code>12</code> 版本。</p>
<p>如果在 <code>git bash</code> 中使用 <code>Ctrl + c</code> 快捷键终止服务未响应的话，需要更新 <code>git</code> 。</p>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT主题配置</title>
    <url>/2020/08/30/Hexo-NexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>首先安装</strong></p>
<p>首先安装好 <code>NexT</code> ，从 <a href="https://github.com/theme-next/hexo-theme-next">这里</a> 下载克隆最新的 <code>NexT</code> ，然后把内容解压到 <code>Hexo</code> 安装目录下的 <code>theses</code> 文件夹中，并且重命名为 <code>next</code>。</p>
<a id="more"></a>

<p><strong>配置文件</strong> </p>
<p>完成上面步骤后，在 <code>Hexo</code> 的安装目录下，有一个文件夹 <code>themes</code> 该文件夹中存放着主题文件，在 <code>themes\next\</code> 文件夹下有配置文件 <code>_config.yml</code> （以后称为 <strong>NexT 配置文件</strong>） ，在该文件中，内容可以说是巨大无比，抽取关键内容，可以对以下内容进行配置。NexT配置<a href="https://theme-next.org/docs/theme-settings/">详细文档</a></p>
<h2 id="1-网站图标"><a href="#1-网站图标" class="headerlink" title="1 网站图标"></a>1 网站图标</h2><p>找到自己中意的图标后，先调整尺寸，一般都是 <code>16 * 16</code> 用作网站小图标，<code>32 * 32</code> 及以上用作站点图标（用户头像类似），然后保存在 <code>&#123;Hexo_home&#125;\source\image\</code> 下。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/icon-16.png</span>            <span class="comment"># 小图标</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/icon-32.png</span>           <span class="comment"># 中等图标</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/icon-32.png</span> <span class="comment"># 适配 Apple 设备</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/icon.svg</span>   <span class="comment"># safari 浏览器的小图标，需要用 svg 格式</span></span><br></pre></td></tr></table></figure>

<h2 id="2-版权声明"><a href="#2-版权声明" class="headerlink" title="2. 版权声明"></a>2. 版权声明</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="3-主题样式以及暗黑模式"><a href="#3-主题样式以及暗黑模式" class="headerlink" title="3. 主题样式以及暗黑模式"></a>3. 主题样式以及暗黑模式</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模式</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暗黑模式</span></span><br><span class="line"><span class="attr">darkmode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="4-菜单栏"><a href="#4-菜单栏" class="headerlink" title="4. 菜单栏"></a>4. 菜单栏</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否打开某一个菜单栏，打开的话只需要将前面的 # 注释去掉</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment"># sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment"># commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否显示图标、是否显示角标</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="5-社交链接"><a href="#5-社交链接" class="headerlink" title="5. 社交链接"></a>5. 社交链接</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据需要进行添加就好了</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/hxz1998</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">huxz1998@163.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br></pre></td></tr></table></figure>

<h2 id="6-阅读更多（Read-More）"><a href="#6-阅读更多（Read-More）" class="headerlink" title="6. 阅读更多（Read More）"></a>6. 阅读更多（Read More）</h2><p>这个功能类似于 <strong>全文展开</strong> ，第一步打开 <strong>阅读全文</strong> 按钮：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">read_more_btn:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>第二步，在某一个文章中，添加 <code>&lt;!-- more --&gt;</code> 标签，该标签前面的内容将会被展示，后面的内容将会被折叠。</p>
<h2 id="7-字数统计，阅读时长-amp-本地查询"><a href="#7-字数统计，阅读时长-amp-本地查询" class="headerlink" title="7. 字数统计，阅读时长 &amp; 本地查询"></a>7. 字数统计，阅读时长 &amp; 本地查询</h2><p>参考 <strong>配置Hexo</strong> 一文。</p>
<h2 id="8-访客统计"><a href="#8-访客统计" class="headerlink" title="8. 访客统计"></a>8. 访客统计</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span>      </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>              <span class="comment"># 首先打开该插件</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>      <span class="comment"># 是否显示访客</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span> <span class="comment"># 该数字前面的图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>         <span class="comment"># 总浏览量</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span>     <span class="comment"># 还是图标~</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>          <span class="comment"># 文章浏览量</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span>      <span class="comment"># 仍旧是图标</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World！</title>
    <url>/2020/08/27/hello-world/</url>
    <content><![CDATA[<h2 id="震惊！-○´･д･-ﾉ"><a href="#震惊！-○´･д･-ﾉ" class="headerlink" title="震惊！(○´･д･)ﾉ"></a>震惊！(○´･д･)ﾉ</h2><p>咩哈哈哈哈哈，可可可可算弄好了。<br>明天见~我的宝宝理。</p>
<h2 id="晚安安"><a href="#晚安安" class="headerlink" title="晚安安"></a>晚安安</h2><blockquote>
<p>晚安啦，我亲爱的宝贝~爱你爱你。</p>
</blockquote>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>初出茅庐</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Hexo</title>
    <url>/2020/08/29/%E9%85%8D%E7%BD%AEHexo/</url>
    <content><![CDATA[<p><strong>配置文件 <code>_config.yml</code></strong></p>
<p>在 <code>Hexo</code> 的安装目录下， 有一个文件 <code>_config.yml</code> （以后称为 <strong>Hexo 配置文件</strong> ，在该文件中，可以对以以下内容进行配置。</p>
<a id="more"></a>

<h2 id="1-站点信息"><a href="#1-站点信息" class="headerlink" title="1. 站点信息"></a>1. 站点信息</h2><p>在这个配置中，可以对站点的基本信息进行修改。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">CHerrY</span> <span class="comment"># 站点标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;门前大桥下，C#C++，快来快来数一数，Java煮青蛙~&#x27;</span>  <span class="comment"># 子标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;算法分析，基础架构&#x27;</span> <span class="comment"># 站点描述，用来展示给访客的</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&#x27;算法分析分享，技术博客，LeetCode，个人博客&#x27;</span>  <span class="comment"># 给搜索引擎用的</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">CHerrY</span>  <span class="comment"># 作者信息，博客中的作者默认署名</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment"># 语言信息，Hexo支持多种语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span>    <span class="comment"># 时区配置，默认使用计算机的当地时间</span></span><br></pre></td></tr></table></figure>

<h2 id="2-URL-配置"><a href="#2-URL-配置" class="headerlink" title="2. URL 配置"></a>2. <code>URL</code> 配置</h2><p>该配置将会影响到博客内 <strong>图片</strong> 的访问、外链等信息。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://hxz1998.github.io/</span> <span class="comment"># 站点域名，如果有的话可以设置自己的域名</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span>                         <span class="comment"># 配置根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>  <span class="comment"># URL 组成格式</span></span><br></pre></td></tr></table></figure>

<h2 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3. 扩展"></a>3. 扩展</h2><p>对 <code>Hexo</code> 进行扩展所用到的配置，每一个插件需要去查看插件自己的说明文档。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插件扩展到： https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment"># 主题扩展到： https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span> <span class="comment"># 设置主题为 next</span></span><br></pre></td></tr></table></figure>

<h2 id="4-部署分发"><a href="#4-部署分发" class="headerlink" title="4. 部署分发"></a>4. 部署分发</h2><p>将博客部署到哪里，就配置这里~</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span> <span class="comment"># 部署服务类型，在这里我使用的是 Github 和 Gitee，因此选 git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># 仓库名称“们”，之所以使用“们”，是因为可以同步多个git仓库</span></span><br><span class="line">    <span class="attr">gitee:</span> <span class="string">https://gitee.com/hxz1998/hxz1998.git</span>  </span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://github.com/hxz1998/hxz1998.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<h2 id="5-字数统计，阅读时长（可选）"><a href="#5-字数统计，阅读时长（可选）" class="headerlink" title="5. 字数统计，阅读时长（可选）"></a>5. 字数统计，阅读时长（可选）</h2><p><strong>下面内容在Hexo配置文件中并不存在，别害怕，自己添加就完事儿了。</strong> 这里主要对博客的一些额外的功能进行配置，需要结合 <code>hexo-symbols-count-time</code> 插件进行使用。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>     <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure>

<h3 id="5-1-hexo-symbols-count-time-安装"><a href="#5-1-hexo-symbols-count-time-安装" class="headerlink" title="5.1 hexo-symbols-count-time 安装"></a>5.1 <code>hexo-symbols-count-time</code> 安装</h3><p>打开心心念念的命令行终端，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time	<span class="comment"># 过程很快，没有多大</span></span><br></pre></td></tr></table></figure>

<p>等待安装完成，<strong>重新生成</strong> 、启动 <code>Hexo</code> 即可查看效果。</p>
<h3 id="5-2-配置-NexT-中的内容"><a href="#5-2-配置-NexT-中的内容" class="headerlink" title="5.2 配置 NexT 中的内容"></a>5.2 配置 <code>NexT</code> 中的内容</h3><p>将 <code>symbol_count_time</code> 启用：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>   <span class="comment"># 分隔的元数据</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>   <span class="comment"># 文章字数 </span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span> <span class="comment"># 总字数</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>                 <span class="comment"># 平均字长（字符以字为单位）</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>               <span class="comment"># 每分钟字数</span></span><br></pre></td></tr></table></figure>

<p>上面的数字都可以修改，当然，还可以参考来自 <a href="https://github.com/theme-next/hexo-symbols-count-time">官方</a> 指导：</p>
<blockquote>
<p><strong>注意对于中国用户：</strong>因为在有关中国语文平均字长<code>~1.5</code>，如果你在大多数情况下，写中国的职位（不含混合英文），建议设置<code>awl</code>到<code>2</code>和<code>wpm</code>到<code>300</code>。<br>但是，如果您通常将自己的帖子与英语混在一起，则<code>awl</code>to <code>4</code>和<code>wpm</code>to <code>275</code>会很好。</p>
</blockquote>
<h2 id="6-搜索（可选）"><a href="#6-搜索（可选）" class="headerlink" title="6. 搜索（可选）"></a>6. 搜索（可选）</h2><p>同样的，这是一个在 <strong>Hexo配置文件中并不存在的内容，需要额外添加。</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span> </span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span>  <span class="comment"># 将搜索索引放到哪里</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span>       <span class="comment"># 搜索字段</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span>     <span class="comment"># 是否检索内容</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span>      <span class="comment"># 生成格式</span></span><br></pre></td></tr></table></figure>

<p> 配置完之后，仍然需要额外配置 <code>NexT</code> 主题的配置文件 <code>next\_config.xml</code> 才可以生效。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span>	</span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>	</span><br></pre></td></tr></table></figure>

<h3 id="6-1-hexo-generator-searchdb-安装"><a href="#6-1-hexo-generator-searchdb-安装" class="headerlink" title="6.1 hexo-generator-searchdb 安装"></a>6.1 <code>hexo-generator-searchdb</code> 安装</h3><p>继续使用上面心心念念的终端，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p>等待安装完成，<strong>重新生成</strong> 、再次启动 <code>Hexo</code> 即可查看效果。</p>
<h2 id="7-标签云"><a href="#7-标签云" class="headerlink" title="7. 标签云"></a>7. 标签云</h2><p>首先要建立存放标签的页面，打开喜欢用的命令行终端，并输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure>

<p>然后就可以在 <code>Hexo_home\source\</code> 文件夹下看到有 <code>tags\index.md</code> 文件，对该文件进行修改成如下内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 标签云              # 展示标题</span><br><span class="line">date: 2020-08-27 23:03:38 # 创建时间，一般不需要改</span><br><span class="line">type: &quot;tags&quot;              # <span class="xml"><span class="tag">&lt;<span class="name">---</span> 这个才是添加的重点！</span></span></span><br></pre></td></tr></table></figure>

<p>然后刷新就可以在主页面菜单中看到 <strong>标签</strong> 这一栏了。</p>
<h2 id="8-分类"><a href="#8-分类" class="headerlink" title="8. 分类"></a>8. 分类</h2><p>对于分类页面的建立，和上面 <strong>第七条</strong> 一样。</p>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的顺序容器比较</title>
    <url>/2020/09/10/C++%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>容器就是特定类型对象的集合，顺序容器（Sequential Container）是一种提供了元素顺序存储访问的数据结构，顺序存储意味着在存储方式上仅仅依赖于先后加入容器的顺序。在 <code>C++</code> 的 <code>STL</code> 中，提供了 <code>vector, deque, list, forward_list, array</code> 这几种容器，当然还有 <code>string</code> 也可以视为一种容器，只不过只能存储 <code>char</code> 类型的数据。</p>
<a id="more"></a>

<blockquote>
<p>  本文主要参考自 <em>C++ Primer, 5th Edition</em>, [美] Stanley B. Lippman / [美] Josée Lajoie / [美] Barbara E. Moo</p>
</blockquote>
<h1 id="1-顺序容器类型"><a href="#1-顺序容器类型" class="headerlink" title="1. 顺序容器类型"></a>1. 顺序容器类型</h1><p>在 <code>STL</code> 中（截至 <code>C++11</code>，提供了如下所示几个顺序类型）</p>
<ol>
<li><code>vector</code>：可变大小数组。支持<strong>快速随机</strong>访问。在<strong>尾部</strong>插入元素较快，但其他位置插入很慢。</li>
<li><code>deque</code>：双端队列。支持快速随机访问。在头部、尾部插入元素都很快。</li>
<li><code>list</code>：双向链表。<strong>仅</strong>支持<strong>双向顺序</strong>访问。在<strong>任何位置</strong>删除、添加元素都很快。</li>
<li><code>forward_list</code>：单向链表。<strong>仅</strong>支持<strong>从头部开始</strong>的顺序访问。在链表<strong>任何位置</strong>插入、删除元素都很快。</li>
<li><code>array</code>：固定大小数组。支持<strong>快速随机</strong>访问，<strong>不能</strong>添加、删除元素。</li>
<li><code>string</code>：和 <code>vector</code> 类似，只不过只能存储 <code>char</code> 类型的数据。</li>
</ol>
<h1 id="2-性能分析"><a href="#2-性能分析" class="headerlink" title="2. 性能分析"></a>2. 性能分析</h1><p>除了 <code>array</code> 容器之外，其他容器均提供了高效的内存管理，可以在计算机资源允许的情况下任意添加删除元素到容器中。它们之间的主要区别在于存储策略的不同和操作接口的不同，从而间接导致了不同容器有不同的性能和应用场合。</p>
<p><code>string</code> 和 <code>vector</code> 是存储在一块连续的内存空间中的，因此它可以很方便的计算每一个元素的物理地址从而实现快速随机访问。但是也正是因为它们在连续空间中存储，当需要在中间位置 <code>i</code> 插入元素时，需要将 <code>i + 1</code> 及以后的每一个元素平移到它们的下一个位置，空出来 <code>i</code> 位置才可以插入进来保持空间的连续性。不仅如此，有时添加元素进来，需要<strong>扩容+拷贝元素</strong>到新存储空间中。</p>
<p><code>list</code> 和 <code>forward_list</code> 是两个使用<strong>链表</strong>来实现的数据结构，它们在添加元素时非常便利，但是访问时却不支持快速随机访问，需要从头部（<code>list</code>还支持从尾部向头部的查找）开始逐个遍历访问。除此之外，这俩数据结构在存储每一个元素时，都需要额外的空间来维持链表结构。</p>
<p><code>deque</code> 是一个不仅支持快速随机访问，而且支持在头部和尾部高效的删除或添加元素，在这一点和 <code>list</code> 与 <code>forward_list</code> 效率相当。</p>
<p><code>forward_list</code> 和 <code>array</code> 是 <code>C++11</code> 新添加的类型，<code>array</code> 是一种更加安全、易用的数组类型，在用法上和内置数组类似（并没有感觉到有什么大的区别）。<code>forward_list</code> 是单链表，为了达到最好的性能，没有维护 <code>size</code> 方法，因此计算它的大小时，只能手动实现。</p>
<blockquote>
<p>  一般来说，除非有更好的理由（例如需要高频率中间增加元素和删除元素），使用 <code>vector</code> 就是最好的选择了。</p>
</blockquote>
<h1 id="3-容器选择基本原则"><a href="#3-容器选择基本原则" class="headerlink" title="3. 容器选择基本原则"></a>3. 容器选择基本原则</h1><ol>
<li>一般选 <code>vector</code> 就可以啦，除非有更好理由。</li>
<li>如果空间的额外开销很重要，不要用 <code>list</code> 和 <code>forward_list</code>。</li>
<li>如果要求高频率随机访问元素，那么使用 <code>vector</code> 和 <code>deque</code> 更加合适。</li>
<li>如果需要在容器中间位置插入删除元素，使用 <code>list</code> 和 <code>forward_list</code> 更加合适。</li>
<li>如果只有在最初输入阶段需要插入删除元素，而后稳定下来仅仅需要随机访问，可以这样：<ol>
<li>如果需要在<strong>中间</strong>位置插入元素，那么使用 <code>list</code> 来构造输入阶段，再把它放到 <code>vector</code> 中去。</li>
<li>如果<strong>不需要在中间位置</strong>插入元素，那么直接使用 <code>vector</code> （或 <code>deque</code>）就可以了，因为在末尾（或头部）添加元素就很方便呀。</li>
</ol>
</li>
</ol>
<p>总的来说，容器操作类型（读取或增删）的占比决定了容器类型的选择，因此，在必要情况下进行性能测试也是不错的选择~</p>
<p>如果还是不清楚，那么就用<strong>迭代器</strong>来代替下标访问，因为迭代器是一个通用接口，可以任意替换具体实现而不影响程序使用，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/10.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/10 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  如果后面需要，可以只改一处地方，就完成了整个实现，如：</span></span><br><span class="line"><span class="comment">     *  vector&lt;int&gt; nums = &#123;1, 2, 3, 4, 5&#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = nums.<span class="built_in">begin</span>(); iter != nums.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// &gt;: 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
      </tags>
  </entry>
</search>
