<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++的顺序容器比较</title>
    <url>/2020/09/10/C++%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>容器就是特定类型对象的集合，顺序容器（Sequential Container）是一种提供了元素顺序存储访问的数据结构，顺序存储意味着在存储方式上仅仅依赖于先后加入容器的顺序。在 <code>C++</code> 的 <code>STL</code> 中，提供了 <code>vector, deque, list, forward_list, array</code> 这几种容器，当然还有 <code>string</code> 也可以视为一种容器，只不过只能存储 <code>char</code> 类型的数据。</p>
<a id="more"></a>
<blockquote>
<p>  本文主要参考自 <em>C++ Primer, 5th Edition</em>, [美] Stanley B. Lippman / [美] Josée Lajoie / [美] Barbara E. Moo</p>
</blockquote>
<h1 id="1-顺序容器类型"><a href="#1-顺序容器类型" class="headerlink" title="1. 顺序容器类型"></a>1. 顺序容器类型</h1><p>在 <code>STL</code> 中（截至 <code>C++11</code>，提供了如下所示几个顺序类型）</p>
<ol>
<li><code>vector</code>：可变大小数组。支持<strong>快速随机</strong>访问。在<strong>尾部</strong>插入元素较快，但其他位置插入很慢。</li>
<li><code>deque</code>：双端队列。支持快速随机访问。在头部、尾部插入元素都很快。</li>
<li><code>list</code>：双向链表。<strong>仅</strong>支持<strong>双向顺序</strong>访问。在<strong>任何位置</strong>删除、添加元素都很快。</li>
<li><code>forward_list</code>：单向链表。<strong>仅</strong>支持<strong>从头部开始</strong>的顺序访问。在链表<strong>任何位置</strong>插入、删除元素都很快。</li>
<li><code>array</code>：固定大小数组。支持<strong>快速随机</strong>访问，<strong>不能</strong>添加、删除元素。</li>
<li><code>string</code>：和 <code>vector</code> 类似，只不过只能存储 <code>char</code> 类型的数据。</li>
</ol>
<h1 id="2-性能分析"><a href="#2-性能分析" class="headerlink" title="2. 性能分析"></a>2. 性能分析</h1><p>除了 <code>array</code> 容器之外，其他容器均提供了高效的内存管理，可以在计算机资源允许的情况下任意添加删除元素到容器中。它们之间的主要区别在于存储策略的不同和操作接口的不同，从而间接导致了不同容器有不同的性能和应用场合。</p>
<p><code>string</code> 和 <code>vector</code> 是存储在一块连续的内存空间中的，因此它可以很方便的计算每一个元素的物理地址从而实现快速随机访问。但是也正是因为它们在连续空间中存储，当需要在中间位置 <code>i</code> 插入元素时，需要将 <code>i + 1</code> 及以后的每一个元素平移到它们的下一个位置，空出来 <code>i</code> 位置才可以插入进来保持空间的连续性。不仅如此，有时添加元素进来，需要<strong>扩容+拷贝元素</strong>到新存储空间中。</p>
<p><code>list</code> 和 <code>forward_list</code> 是两个使用<strong>链表</strong>来实现的数据结构，它们在添加元素时非常便利，但是访问时却不支持快速随机访问，需要从头部（<code>list</code>还支持从尾部向头部的查找）开始逐个遍历访问。除此之外，这俩数据结构在存储每一个元素时，都需要额外的空间来维持链表结构。</p>
<p><code>deque</code> 是一个不仅支持快速随机访问，而且支持在头部和尾部高效的删除或添加元素，在这一点和 <code>list</code> 与 <code>forward_list</code> 效率相当。</p>
<p><code>forward_list</code> 和 <code>array</code> 是 <code>C++11</code> 新添加的类型，<code>array</code> 是一种更加安全、易用的数组类型，在用法上和内置数组类似（并没有感觉到有什么大的区别）。<code>forward_list</code> 是单链表，为了达到最好的性能，没有维护 <code>size</code> 方法，因此计算它的大小时，只能手动实现。</p>
<blockquote>
<p>  一般来说，除非有更好的理由（例如需要高频率中间增加元素和删除元素），使用 <code>vector</code> 就是最好的选择了。</p>
</blockquote>
<h1 id="3-容器选择基本原则"><a href="#3-容器选择基本原则" class="headerlink" title="3. 容器选择基本原则"></a>3. 容器选择基本原则</h1><ol>
<li>一般选 <code>vector</code> 就可以啦，除非有更好理由。</li>
<li>如果空间的额外开销很重要，不要用 <code>list</code> 和 <code>forward_list</code>。</li>
<li>如果要求高频率随机访问元素，那么使用 <code>vector</code> 和 <code>deque</code> 更加合适。</li>
<li>如果需要在容器中间位置插入删除元素，使用 <code>list</code> 和 <code>forward_list</code> 更加合适。</li>
<li>如果只有在最初输入阶段需要插入删除元素，而后稳定下来仅仅需要随机访问，可以这样：<ol>
<li>如果需要在<strong>中间</strong>位置插入元素，那么使用 <code>list</code> 来构造输入阶段，再把它放到 <code>vector</code> 中去。</li>
<li>如果<strong>不需要在中间位置</strong>插入元素，那么直接使用 <code>vector</code> （或 <code>deque</code>）就可以了，因为在末尾（或头部）添加元素就很方便呀。</li>
</ol>
</li>
</ol>
<p>总的来说，容器操作类型（读取或增删）的占比决定了容器类型的选择，因此，在必要情况下进行性能测试也是不错的选择~</p>
<p>如果还是不清楚，那么就用<strong>迭代器</strong>来代替下标访问，因为迭代器是一个通用接口，可以任意替换具体实现而不影响程序使用，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/10.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/10 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  如果后面需要，可以只改一处地方，就完成了整个实现，如：</span></span><br><span class="line"><span class="comment">     *  vector&lt;int&gt; nums = &#123;1, 2, 3, 4, 5&#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = nums.<span class="built_in">begin</span>(); iter != nums.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// &gt;: 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中push_back和emplace_back的区别</title>
    <url>/2020/09/02/CPP%E4%B8%ADpush-back%E5%92%8Cemplace-back%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>在 <code>C++11</code> 之后，<code>vector</code> 容器中添加了新的方法：<code>emplace_back()</code> ，和 <code>push_back()</code> 一样的是都是在容器末尾添加一个新的元素进去，不同的是 <code>emplace_back()</code> 在效率上相比较于 <code>push_back()</code> 有了一定的提升。</p>
<a id="more"></a>
<h1 id="1-push-back-方法"><a href="#1-push-back-方法" class="headerlink" title="1. push_back() 方法"></a>1. <code>push_back()</code> 方法</h1><p>首先分析较为简单直观的 <code>push_back()</code> 方法。对于 <code>push_back()</code> 而言，最开始只有 <code>void push_back( const T&amp; value );</code> 这个函数声明，后来从 <code>C++11</code> ，新加了<code>void push_back( T&amp;&amp; value )</code> 函数，以下为 <code>C++</code> 中的源码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以下程序来自STL源码 bits/stl_vector.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @brief  Add data to the end of the %vector.</span></span><br><span class="line"><span class="comment"> *  @param  __x  Data to be added.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This is a typical stack operation.  The function creates an</span></span><br><span class="line"><span class="comment"> *  element at the end of the %vector and assigns the given data</span></span><br><span class="line"><span class="comment"> *  to it.  Due to the nature of a %vector this operation can be</span></span><br><span class="line"><span class="comment"> *  done in constant time if the %vector has preallocated space</span></span><br><span class="line"><span class="comment"> *  available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type &amp;__x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage) &#123;</span><br><span class="line">        <span class="comment">// 首先判断容器满没满，如果没满那么就构造新的元素，然后插入新的元素</span></span><br><span class="line">        _Alloc_traits::construct(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                                 __x);</span><br><span class="line">        ++<span class="keyword">this</span>-&gt;_M_impl._M_finish; <span class="comment">// 更新当前容器内元素数量</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果满了，那么就重新申请空间，然后拷贝数据，接着插入新数据 __x</span></span><br><span class="line">        _M_realloc_insert(<span class="built_in">end</span>(), __x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 C++ 版本为 C++11 及以上（也就是从 C++11 开始新加了这个方法），使用 emplace_back() 代替</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(value_type &amp;&amp;__x)</span> </span>&#123;</span><br><span class="line">    emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(__x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在 <code>C++20</code> 之后，对这两个重载方法进行了修改，变成了 <code>constexpr void push_back( const T&amp; value );</code> 以及 <code>constexpr void push_back( T&amp;&amp; value );</code> 。详情参考 <code>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1004r2.pdf</code> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1004r2.pdf">版本修改计划</a>。</p>
<h1 id="2-emplace-back-方法"><a href="#2-emplace-back-方法" class="headerlink" title="2. emplace_back() 方法"></a>2. <code>emplace_back()</code> 方法</h1><p><code>emplace_back()</code> 是从 <code>C++11</code> 起新增到 <code>vector</code> 中的方法，最初的函数声明为： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; class... Args &gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>
<p>之后在 <code>C++14</code> 之后，将无返回值 <code>void</code> 改为了返回对插入元素的引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; class... Args &gt;</span><br><span class="line"><span class="function">reference <span class="title">emplace_back</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>STL</code> 源码中，可以看到 <code>emplace_back()</code> 的实现是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以下程序来自STL源码 bits/vector.tcc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt; 201402L</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;::reference</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;::emplace_back(_Args &amp;&amp;... __args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage) &#123;</span><br><span class="line">        <span class="comment">// 同样判断容器是否满了，没满的话，执行构造函数，对元素进行构造，并执行类型转换</span></span><br><span class="line">        _Alloc_traits::construct(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                                 <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">        ++<span class="keyword">this</span>-&gt;_M_impl._M_finish; <span class="comment">// 更新当前容器大小</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 满了的话重新申请内存空间，将新的元素继续构造进来，并且进行类型转换</span></span><br><span class="line">        _M_realloc_insert(<span class="built_in">end</span>(), <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt; 201402L</span></span><br><span class="line">    <span class="keyword">return</span> back(); <span class="comment">// 在 C++14版本之后，添加返回值，返回最后一个元素的引用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>将 <code>emplace_back()</code> 和 <code>push_back()</code> 中区别最大的程序拎出来看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_Alloc_traits::construct(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                                 <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...); <span class="comment">// emplace_back()</span></span><br><span class="line">_Alloc_traits::construct(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                                 __x);                            <span class="comment">// push_back()</span></span><br></pre></td></tr></table></figure>
<p>对于 <code>std::forward()</code> 函数而言，本质上是一个类型转换函数，它的声明函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以下程序来自STL源码 bits/move.h</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an lvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp &amp;&amp;<span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type &amp;<span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp &amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在强制类型转换中，将参数 <code>__t</code> 传递给对应类 <code>_Tp</code> 的构造函数，然后调用了该类的构造函数从而完成对象创建过程。</strong></p>
<p>因此，在 <code>emplace_back()</code> 函数中，是支持直接将构造函数所需的参数传递过去，然后构建一个新的对象出来，然后填充到容器尾部的。</p>
<h1 id="3-直观区别"><a href="#3-直观区别" class="headerlink" title="3. 直观区别"></a>3. 直观区别</h1><p>声明一个 <code>Person</code> 类，里面只有一个字段 <code>_age</code> ，在容器中存储该类的对象，方便于查看整个函数调用过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age) : _age(age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct a person.&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;p) : _age(p._age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy-Construct&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;&amp;p) <span class="keyword">noexcept</span>: _age(p._age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move-Construct&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先使用 <code>push_back()</code> 方法添加创建好的元素，可以看出使用到了<strong>拷贝构造函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; person;</span><br><span class="line">    <span class="keyword">auto</span> p = Person(<span class="number">1</span>); <span class="comment">// &gt;: Construct a person.1</span></span><br><span class="line">    person.push_back(p);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Copy-Construct1 因为容器扩容，需要把前面的元素重新添加进来，因此需要拷贝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再使用 <code>emplace_back()</code> 函数添加元素进来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; person;</span><br><span class="line">    <span class="keyword">auto</span> p = Person(<span class="number">1</span>); <span class="comment">// &gt;: Construct a person.1</span></span><br><span class="line">    person.emplace_back(<span class="built_in">move</span>(p)); <span class="comment">// &gt;: Move-Construct1</span></span><br><span class="line">    person.emplace_back(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Construct a person.2  // 构建一个新的元素</span></span><br><span class="line"><span class="comment">     * &gt;: Move-Construct1       // 拷贝之前的元素过来，这个时候用的是 Person(const Person &amp;&amp;p)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到直接使用<strong>构造参数列表</strong>来添加元素的方法，它会使用到了移动构造函数 <code>move</code> 。这也是 <code>emplace_back()</code> 方法的一大特色。</p>
<h1 id="4-性能分析"><a href="#4-性能分析" class="headerlink" title="4. 性能分析"></a>4. 性能分析</h1><p><code>emplace_back()</code> 函数在原理上比 <code>push_back()</code> 有了一定的改进，包括在内存优化方面和运行效率方面。内存优化主要体现在使用了<strong>就地构造（直接在容器内构造对象，不用拷贝一个复制品再使用）+强制类型转换</strong>的方法来实现，在运行效率方面，由于省去了拷贝构造过程，因此也有一定的提升。</p>
<p>以下程序源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/3.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/3 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age) : _age(age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct a person.&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;p) : _age(p._age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy-Construct&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;&amp;p) <span class="keyword">noexcept</span>: _age(p._age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move-Construct&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_EMPLACE_BACK</span></span><br><span class="line"><span class="comment">//#define TEST_PUSH_BACK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; person;</span><br><span class="line">    <span class="keyword">auto</span> p = Person(<span class="number">1</span>); <span class="comment">// &gt;: Construct a person.1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST_EMPLACE_BACK</span></span><br><span class="line">    person.emplace_back(<span class="built_in">move</span>(p)); <span class="comment">// &gt;: Move-Construct1</span></span><br><span class="line">    person.emplace_back(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Construct a person.2  // 构建一个新的元素</span></span><br><span class="line"><span class="comment">     * &gt;: Move-Construct1       // 拷贝之前的元素过来，这个时候用的是 Person(const Person &amp;&amp;p)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST_PUSH_BACK</span></span><br><span class="line">    person.push_back(p);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Copy-Construct1 因为容器扩容，需要把前面的元素重新添加进来，因此需要拷贝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的lambda表达式探究</title>
    <url>/2020/08/30/CPP%E4%B8%AD%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>在 <code>C++11</code> 及之后的版本中，<code>C++</code> 提供了 <code>lambda</code> 表达式，它是一种方便了参数传递和定义匿名函数的方法。该方法通常用于封装算法、执行异步方法 ，也就是说比较适用于少量的代码。以下原文：</p>
<blockquote>
<p>In C++11 and later, a lambda expression—often called a <em>lambda</em>—is a convenient way of defining an anonymous function object (a <em>closure</em>) right at the location where it is invoked or passed as an argument to a function. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous methods. This article defines what lambdas are, compares them to other programming techniques, describes their advantages, and provides a basic example. </p>
</blockquote>
<a id="more"></a>
<h1 id="1-Lambda-表达式的组成"><a href="#1-Lambda-表达式的组成" class="headerlink" title="1. Lambda 表达式的组成"></a>1. <code>Lambda</code> 表达式的组成</h1><p>先对 <code>lambda</code> 表达式有一个直观的认识，参考下面程序，该程序完成的是将输入的数组 <code>nums</code> 按照绝对值大小进行升序排列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) <span class="keyword">mutable</span> <span class="keyword">throw</span>() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="comment">// lambda 表达式函数体，在这里做到了将输入数组升序排列</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(b));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">// &gt;: 1 -1 2 3 4 5 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛开边边角角，单独拿出最重要的一部分来学习，<code>[](int a, int b) mutable throw() -&gt; bool&#123; // statement &#125;</code> 就是 <code>lambda</code> 表达式最原始的内容。在该表达式中，每一部分的含义如下叙述：</p>
<ol>
<li><code>[]</code> 捕获子句：用来捕获<strong>周围范围</strong>中出现的变量，也被称为<strong>引导</strong>子句，可以在其中声明获取的变量是按<strong>值</strong>访问还是<strong>引用</strong>来访问<del>，默认值为 <code>&amp;</code> ，上文中的例子和 <code>[&amp;]</code> 是一样的效果，</del>具体例子见下文。</li>
<li><code>()</code> 参数列表：用来获取参数，对于一个一般的 <code>lambda</code> 函数，使用起来和一般的指针函数没有区别，也是需要有参数列表的，具体例子见下文。</li>
<li><code>mutable</code> 可变类型（可选）：一般来说，在 <code>lambda</code> 体中调用运算符的变量，都是以 <code>const value</code> 来使用的，加上这个 <code>mutable</code> 之后，人家变成了变量来使用，具体栗子见下文。</li>
<li><code>throw()</code> 异常类型（可选）：和普通函数一样样，<code>lambda</code> 函数也可能引发异常，如果不会引发异常的话，直接声明 <code>noexcept</code> 就可以啦~</li>
<li><code>-&gt; bool</code> 返回类型（可选）：继续和普通函数一样</li>
<li><code>&#123;// statement &#125;</code> <code>lambda</code> 体：和一般的函数体一样。</li>
</ol>
<p>不难发现，<code>lambda</code> 函数和一般的函数没有太大区别，基本上只有在头部位置有特殊语法。</p>
<h1 id="2-捕获语句的使用-amp-可变规范-mutable"><a href="#2-捕获语句的使用-amp-可变规范-mutable" class="headerlink" title="2. 捕获语句的使用 &amp; 可变规范 mutable"></a>2. 捕获语句的使用 &amp; 可变规范 <code>mutable</code></h1><p>拿出栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>; <span class="comment">// 在上文中声明好变量 num</span></span><br><span class="line">    <span class="keyword">auto</span> f = [n = num]() &#123; <span class="comment">// 在下文中通过 捕获[] 来获取 num，并在 lambda 函数体中进行使用</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; ++num &lt;&lt; std::endl; // 错误的使用，因为 num 是不可变的常量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    f(); <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="keyword">auto</span> m = [num]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 将内部变量声明成 mutable 可变类型，此时可以修改内部变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    m(); <span class="comment">// &gt;: 2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del><code>mutable</code> 可变声明优势在于可以在内部直接改变外部变量，相当于使用了 <code>[&amp;num]</code> 引用方法。</del></p>
<p><strong>2020年9月1日 修正：</strong> 在 <code>C++14</code> 及以后的版本中，可以通过 <code>capture</code> 语句从周围（Surrounding Scope）捕获变量，在 <code>[]</code> 子句中指定要捕获哪些变量，以及按照何种方式使用它们。和普通语法一样，带有 <code>＆</code> 前缀的变量可以通过<strong>引用</strong>进行访问，而没有前缀 <code>＆</code> 的变量可以通过值进行访问。<strong>而空的捕获子句[]表示 <code>lambda</code> 表达式的主体在闭包范围内不访问外部任何变量。</strong> 当然~，也可以使用默认的捕获模式来指示如何捕获 <code>lambda</code> 中引用的任何外部变量：<code>[＆]</code> 表示周围所有变量都是通过引用捕获的，而 <code>[=]</code> 意味着它们按值所捕获。</p>
<p>一般情况下，<code>lambda</code>的函数调用运算符是<strong>常量值</strong>，但是使用 <code>mutable</code> 关键字可以修改默认值，<code>mutable</code> 使 <code>lambda</code> 表达式的函数体可以修改按值捕获的变量。</p>
<h1 id="3-参数列表"><a href="#3-参数列表" class="headerlink" title="3. 参数列表"></a>3. 参数列表</h1><p>再拿出一个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> y = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; y(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// &gt;: 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里开始，也就是参数列表开始，后面的内容都是可选项，也就是如果为空，那么就直接<strong>省略</strong>不写即可。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> empty = [] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Wow!空的~&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 啥也没有只有个函数体&#125;;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    empty(); <span class="comment">// &gt;: Wow!空的~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-特殊用法"><a href="#4-特殊用法" class="headerlink" title="4. 特殊用法"></a>4. 特殊用法</h1><h2 id="4-1-花里胡哨的-lambda-嵌套"><a href="#4-1-花里胡哨的-lambda-嵌套" class="headerlink" title="4.1 花里胡哨的 lambda 嵌套"></a>4.1 花里胡哨的 <code>lambda</code> 嵌套</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两层 lambda 嵌套，看起来挺花里胡哨</span></span><br><span class="line">    <span class="keyword">auto</span> embed_embed_lambda = [](<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; - - &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> [](<span class="keyword">int</span> c) &#123; <span class="keyword">return</span> c / <span class="number">2</span>; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; embed_embed_lambda(<span class="number">2</span>)(<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2 - - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-高阶-lambda-函数"><a href="#4-2-高阶-lambda-函数" class="headerlink" title="4.2 高阶 lambda 函数"></a>4.2 高阶 <code>lambda</code> 函数</h2><p>高阶函数是指，采用另一个 <code>lambda</code> 表达式作为其参数或返回 <code>lambda</code> 表达式的 <code>lambda</code> 表达式（不知不觉想起了俄罗斯套娃🤔）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回 function 对象的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> get_function = [](<span class="keyword">int</span> x) -&gt; <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用 function 为对象作为其参数的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> param_function = [](<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &amp;f, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> f(n) * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> ans = param_function(get_function(<span class="number">2</span>), <span class="number">3</span>); <span class="comment">// x = 2, n = 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.  总结"></a>5.  总结</h1><p>写到此处，关于 <code>C++</code> 的 <code>lambda</code> 语法规范和用法已经学习了一小部分，它作为一种方便灵活的方法随用随学也是阔以的。</p>
<blockquote>
<p>因为参数类型和函数模板参数一样可以被推导而无需和具体参数类型耦合，有利于重构代码；和使用auto声明变量的作用类似，它也允许避免书写过于复杂的参数类型。特别地，不需要显式指出参数类型使得使用高阶函数变得更加容易。</p>
</blockquote>
<p>以下程序源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/8/30.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/8/30 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b) <span class="keyword">mutable</span> <span class="keyword">throw</span>() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="comment">// lambda 表达式函数体，在这里做到了将输入数组升序排列</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(b));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">// &gt;: 1 -1 2 3 4 5 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>; <span class="comment">// 在上文中声明好变量 num</span></span><br><span class="line">    <span class="keyword">auto</span> f = [n = num]() &#123; <span class="comment">// 在下文中通过 捕获[] 来获取 num，并在 lambda 函数体中进行使用</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; ++num &lt;&lt; std::endl; // 错误的使用，因为 num 是不可变的常量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    f(); <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="keyword">auto</span> m = [num]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 将内部变量声明成 mutable 可变类型，此时可以修改内部变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    m(); <span class="comment">// &gt;: 2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> y = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; y(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// &gt;: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> empty = [] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Wow!空的~&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 啥也没有只有个函数体&#125;;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    empty(); <span class="comment">// &gt;: Wow!空的~</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个函数，然后直接使用 (5, 3)</span></span><br><span class="line">    <span class="keyword">int</span> n = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两层 lambda 嵌套，看起来挺花里胡哨</span></span><br><span class="line">    <span class="keyword">auto</span> embed_embed_lambda = [](<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; - - &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> [](<span class="keyword">int</span> c) &#123; <span class="keyword">return</span> c / <span class="number">2</span>; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; embed_embed_lambda(<span class="number">2</span>)(<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2 - - 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 function 对象的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> get_function = [](<span class="keyword">int</span> x) -&gt; <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 function 为对象作为其参数的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> param_function = [](<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &amp;f, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> f(n) * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ans = param_function(get_function(<span class="number">2</span>), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的unordered_map和map的区别</title>
    <url>/2020/09/01/CPP%E4%B8%AD%E7%9A%84unordered-map%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><code>unordered_map</code> 类模板和 <code>map</code> 类模板都是描述了这么一个对象：它是由 <code>std::pair&lt;const Key, value&gt;</code> 组成的可变长容器，这个容器中每个元素存储两个对象，也就是 <code>key</code> - <code>value</code> 对。</p>
<a id="more"></a>
<h1 id="1-unordered-map"><a href="#1-unordered-map" class="headerlink" title="1. unordered_map"></a>1. <code>unordered_map</code></h1><p>在头文件上，引入 <code>&lt;unordered_map&gt;</code> 来使用它。对于 <code>unordered_map</code> 而言，最大的特点在于内部实现上，使用到了<strong>哈希表</strong>（散列表、<code>hash_table</code> ）来进行映射存储，它的模板类声明及其参数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序来自STL源码 bits/unordered_map.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key,  <span class="comment">// key 类型 </span></span><br><span class="line">        <span class="keyword">typename</span> _Tp,    <span class="comment">// value 类型</span></span><br><span class="line">        <span class="keyword">typename</span> _Hash = hash &lt;_Key&gt;,     <span class="comment">// 哈希函数</span></span><br><span class="line">        <span class="keyword">typename</span> _Pred = equal_to &lt;_Key&gt;, <span class="comment">// 用于比较两者是否相同的函数</span></span><br><span class="line">        <span class="keyword">typename</span> _Alloc = allocator &lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">const</span> _Key, _Tp&gt;&gt;&gt; <span class="comment">// 分配器，描述了容器在内存管理上的细节，不应该自己来处理，除非写自己的容器</span></span><br><span class="line">class <span class="built_in">unordered_map</span> &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>unordered_map</code> 内部，使用的 <code>Hash Table</code> 对数据进行组织，通过把键值 <code>key</code> 映射到 <code>hash</code> 表中的一个位置进行访问，根据 <code>hash</code> 函数的特点， <code>unordered_map</code> 对于元素查找的时间复杂度可以达到 <code>O(1)</code> ，但是，它的元素排列是无序的。具体例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="comment">// 首先创建一个无序 map，它的 key 使用 int 类型，value 使用 string 类型</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; unorderedMap;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 三种插入新元素的方法，“茴”字有三种写法~</span></span><br><span class="line">    unorderedMap.insert(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="string">&quot;Alice&quot;</span>)); </span><br><span class="line">    unorderedMap[<span class="number">1</span>] = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    unorderedMap.insert(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">2</span>, <span class="string">&quot;Candy&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 对内部元素挨个输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = unorderedMap.<span class="built_in">begin</span>(); iter != unorderedMap.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * &gt;: 输出如下，可以得知它们在 key 的排序上并没有顺序</span></span><br><span class="line"><span class="comment">         * 2 - Candy</span></span><br><span class="line"><span class="comment">         * 0 - Alice</span></span><br><span class="line"><span class="comment">         * 1 - Bob</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>unordered_map</code> 由于建立了哈希表，所以它在最开始建立的时候比较耗时间，但是它查询速度快呀~，一般情况下用 <code>unordered_map</code> 是没有问题的。</p>
<h1 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. <code>map</code></h1><p>对于 <code>map</code> 而言，首先在头文件上，引用 <code>&lt;map&gt;</code> 进来，然后使用。它的类模板声明以及部分函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序来自C++源码 bits/stl_map.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key,  <span class="comment">// key 类型</span></span><br><span class="line">        <span class="keyword">typename</span> _Tp,    <span class="comment">// value 类型</span></span><br><span class="line">        <span class="keyword">typename</span> _Compare = <span class="built_in">std</span>::less&lt;_Key&gt;, <span class="comment">// 用于比较两个元素的比较函数</span></span><br><span class="line">        <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt; &gt; <span class="comment">// 分配器，同样的描述了容器在内存管理上的细节，不应该自己来处理，除非写自己的容器</span></span><br><span class="line">class <span class="built_in">map</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 将一个红黑树转换成 [multi]map.</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::<span class="keyword">template</span></span><br><span class="line">    rebind&lt;value_type&gt;::other _Pair_alloc_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree&lt;key_type, value_type, _Select1st&lt;value_type&gt;,</span><br><span class="line">    key_compare, _Pair_alloc_type&gt; _Rep_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>map</code> 的内部，使用了<strong>红黑树</strong>（<code>red-black tree</code>）来组织数据，因此默认的就已经实现了数据的排序。从下面例子中可以看出，它默认实现了在 <code>key</code> 上排序实现递增：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapper;</span><br><span class="line">    mapper.insert(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">    mapper[<span class="number">1</span>] = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    mapper.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">2</span>, <span class="string">&quot;Candy&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter : mapper) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; iter.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * &gt;: 输出如下，很明显的，它们在 key 的排序上是递增排列的</span></span><br><span class="line"><span class="comment">         * 0 - Alice</span></span><br><span class="line"><span class="comment">         * 1 - Bob</span></span><br><span class="line"><span class="comment">         * 2 - Candy</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，在存储上 <code>map</code> 却比较占用空间，因为在红黑树中，每一个节点都要额外保存父节点和子节点的连接，因此使得每一个节点都占用较大空间来维护红黑树性质。</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>两种数据结构特点如下表格~</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><code>unordered_map</code></th>
<th style="text-align:left"><code>map</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>查找</td>
<td><strong>快</strong>，Average：<code>O(1)</code> ，Worst Case：<code>O(n)</code></td>
<td style="text-align:left">恒定的 <code>log(n)</code></td>
</tr>
<tr>
<td>插入</td>
<td>和上面一样</td>
<td style="text-align:left"><code>log(n)</code> + 平衡二叉树所用时间</td>
</tr>
<tr>
<td>删除</td>
<td>还和上面一样</td>
<td style="text-align:left"><code>log(n)</code> + 平衡二叉树所用时间</td>
</tr>
<tr>
<td>是否排序</td>
<td>不排序</td>
<td style="text-align:left"><strong>排序</strong></td>
</tr>
<tr>
<td>实现方法</td>
<td>哈希表</td>
<td style="text-align:left">红黑树</td>
</tr>
<tr>
<td>适用于</td>
<td>查找操作频率高</td>
<td style="text-align:left">要求结果有序（按 <code>key</code> 排序）</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>源码分析</tag>
        <tag>哈希表</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的upper_bound和lower_bound的区别</title>
    <url>/2020/09/20/CPP%E7%9A%84upper-bound%E5%92%8Clower-bound%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>在STL提供的 <code>algorithm</code> 头文件中，提供了两个函数：<code>upper_bound</code> 和 <code>lower_bound</code> ，这俩函数功能 ”类似“，但并不完全相同，具体不同如下文所述。</p>
<a id="more"></a>
<h1 id="1-upper-bound-函数"><a href="#1-upper-bound-函数" class="headerlink" title="1. upper_bound 函数"></a>1. upper_bound 函数</h1><p>在 <code>STL</code> 源码中，关于 <code>upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__val)</code> 函数的说明是这样的：</p>
<blockquote>
<p>  找到最后一个可以插入 <code>val</code> 而不改变原来有序数组的排序位置（Finds the last position in which <code>@p __val</code> could be inserted without changing the ordering）。</p>
</blockquote>
<p>来一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         *upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数 <code>*upper_bound(nums.begin(), nums.end(), 3)</code> 的返回值中，指向了 <code>4</code> 也就是大于 <code>3</code> 的数，从 <code>upper_bound(nums.begin(), nums.end(), 3) - nums.begin()</code> 中可以看出返回来了 <code>3</code> 也就是第一个 <code>4</code> 的下标，因此 <code>upper_bound()</code> 函数可以理解为：<strong>大于目标元素的第一个数/位置</strong>。</p>
<p>翻出来源码验证一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以下程序来自：bits/stl_algobase.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @brief 找到最后一个可以插入 __val 的位置，而且不改变原来的排序</span></span><br><span class="line"><span class="comment"> *  @ingroup binary_search_algorithms，二分查找算法</span></span><br><span class="line"><span class="comment"> *  @param  __first   An iterator. 一个迭代器</span></span><br><span class="line"><span class="comment"> *  @param  __last    Another iterator. 另一个迭代器</span></span><br><span class="line"><span class="comment"> *  @param  __val     The search term. 寻找的项</span></span><br><span class="line"><span class="comment"> *  @return  An iterator pointing to the first element greater than @p __val,</span></span><br><span class="line"><span class="comment"> *           or end() if no elements are greater than @p __val.</span></span><br><span class="line"><span class="comment"> *           拿到一个迭代器，指向第一个大于 __val 元素的地方，</span></span><br><span class="line"><span class="comment"> *           如果没找到大于 __val 的元素，那么就返回 end()</span></span><br><span class="line"><span class="comment"> *  @ingroup binary_search_algorithms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator, <span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _ForwardIterator</span><br><span class="line">upper_bound(_ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">            <span class="keyword">const</span> _Tp &amp;__val) &#123;</span><br><span class="line">    <span class="comment">// concept requirements</span></span><br><span class="line">    __glibcxx_function_requires(_ForwardIteratorConcept &lt; _ForwardIterator &gt;)</span><br><span class="line">    __glibcxx_function_requires(_LessThanOpConcept &lt;</span><br><span class="line">                                _Tp, <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::value_type &gt;)</span><br><span class="line">    __glibcxx_requires_partitioned_upper(__first, __last, __val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::__upper_bound(__first, __last, __val,</span><br><span class="line">                              __gnu_cxx::__ops::__val_less_iter());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到的 <code>__upper_bound()</code> 函数，是实际的用来查找的算法实现，具体实现如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以下程序来自：bits/stl_algobase.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">_ForwardIterator</span><br><span class="line">__upper_bound(_ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">              <span class="keyword">const</span> _Tp &amp;__val, _Compare __comp) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::difference_type</span><br><span class="line">            _DistanceType;</span><br><span class="line"></span><br><span class="line">    _DistanceType __len = <span class="built_in">std</span>::distance(__first, __last);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面使用二分查找算法来实现</span></span><br><span class="line"><span class="comment">     * __len 右指针</span></span><br><span class="line"><span class="comment">     * __first 左指针</span></span><br><span class="line"><span class="comment">     * __middle 中间值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        _DistanceType __half = __len &gt;&gt; <span class="number">1</span>; <span class="comment">// __len / 2 操作，位移操作更快</span></span><br><span class="line">        _ForwardIterator __middle = __first;</span><br><span class="line">        <span class="built_in">std</span>::advance(__middle, __half);</span><br><span class="line">        <span class="keyword">if</span> (__comp(__val, __middle))</span><br><span class="line">            __len = __half;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            __first = __middle;</span><br><span class="line">            ++__first;</span><br><span class="line">            __len = __len - __half - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，可以理解 <code>upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__val)</code> 函数为查找 <strong>大于 <code>__val</code> 的第一个元素及其位置，返回来一个指向这个位置的迭代器</strong>。其底层实现使用了 <strong>二分查找</strong>。</p>
<p>其实，在后面的阅读中，发现对于 <code>upper_bound</code> 还有另一个重载实现，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief Finds the last position in which @p __val could be inserted</span></span><br><span class="line"><span class="comment"> *         without changing the ordering.</span></span><br><span class="line"><span class="comment"> *  @ingroup binary_search_algorithms</span></span><br><span class="line"><span class="comment"> *  @param  __first   An iterator.</span></span><br><span class="line"><span class="comment"> *  @param  __last    Another iterator.</span></span><br><span class="line"><span class="comment"> *  @param  __val     The search term.</span></span><br><span class="line"><span class="comment"> *  @param  __comp    A functor to use for comparisons.</span></span><br><span class="line"><span class="comment"> *  @return  An iterator pointing to the first element greater than @p __val,</span></span><br><span class="line"><span class="comment"> *           or end() if no elements are greater than @p __val.</span></span><br><span class="line"><span class="comment"> *  @ingroup binary_search_algorithms</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  The comparison function should have the same effects on ordering as</span></span><br><span class="line"><span class="comment"> *  the function used for the initial sort.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line"><span class="keyword">inline</span> _ForwardIterator</span><br><span class="line">upper_bound(_ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">            <span class="keyword">const</span> _Tp &amp;__val, _Compare __comp) &#123;</span><br><span class="line">    <span class="comment">// concept requirements</span></span><br><span class="line">    __glibcxx_function_requires(_ForwardIteratorConcept &lt; _ForwardIterator &gt;)</span><br><span class="line">    __glibcxx_function_requires(_BinaryPredicateConcept &lt; _Compare,</span><br><span class="line">                                _Tp, <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::value_type &gt;)</span><br><span class="line">    __glibcxx_requires_partitioned_upper_pred(__first, __last,</span><br><span class="line">                                              __val, __comp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::__upper_bound(__first, __last, __val,</span><br><span class="line">                              __gnu_cxx::__ops::__val_comp_iter(__comp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个实现中，可以使用自定义的 <code>lambda</code> 表达式来替代默认的比较函数，例如下面的栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数 val 就是 3</span></span><br><span class="line"><span class="comment">         * 参数 b 来自 nums 中的数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> val &lt; b;</span><br><span class="line">    &#125;) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它实现的功能和默认的函数是一样的。</p>
<hr>
<h1 id="2-lower-bound-函数"><a href="#2-lower-bound-函数" class="headerlink" title="2. lower_bound 函数"></a>2. lower_bound 函数</h1><p>对于 <code>lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__val)</code> 函数，<code>STL</code> 源码中是这样说的：</p>
<blockquote>
<p>  找到第一个可以插入 <code>__val</code> 的位置，并且不改变原有排序（Finds the first position in which <code>@a val</code> could be inserted without changing the ordering.）。</p>
</blockquote>
<p>字面上意思和 <code>upper_bound</code> 函数很像，都是为 <code>val</code> 找到一个可插入的位置，并不改变原来序列的有序性。但它和 <code>upper_bound()</code> 函数的最大不同在于找到的是 <strong>第一个</strong> 可插入的位置，而 <code>upper_bound</code> 找到的是 <strong>最后一个</strong> 可插入的位置。对于它的例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于输出结果，不难猜测对于 <code>lower_bound()</code> 函数，找到的是 <strong>大于等于</strong> 目标元素的数值和下标。接下来从 <code>STL</code> 中 <code>lower_bound()</code> 的源码进行分析，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  @brief Finds the first position in which @a val could be inserted</span></span><br><span class="line"><span class="comment">   *         without changing the ordering.</span></span><br><span class="line"><span class="comment">   *  @param  __first   An iterator.</span></span><br><span class="line"><span class="comment">   *  @param  __last    Another iterator.</span></span><br><span class="line"><span class="comment">   *  @param  __val     The search term.</span></span><br><span class="line"><span class="comment">   *  @return         An iterator pointing to the first element not less</span></span><br><span class="line"><span class="comment">   *                  than（不小于！！！也就是大于等于） @a val, or end() if every element is less than</span></span><br><span class="line"><span class="comment">   *                  @a val.</span></span><br><span class="line"><span class="comment">   *  @ingroup binary_search_algorithms</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator, <span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _ForwardIterator</span><br><span class="line">lower_bound(_ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">            <span class="keyword">const</span> _Tp &amp;__val) &#123;</span><br><span class="line">    <span class="comment">// concept requirements</span></span><br><span class="line">    __glibcxx_function_requires(_ForwardIteratorConcept &lt; _ForwardIterator &gt;)</span><br><span class="line">    __glibcxx_function_requires(_LessThanOpConcept &lt;</span><br><span class="line">                                <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::value_type, _Tp &gt;)</span><br><span class="line">    __glibcxx_requires_partitioned_lower(__first, __last, __val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::__lower_bound(__first, __last, __val,</span><br><span class="line">                              __gnu_cxx::__ops::__iter_less_val());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它与其中用到的 <code>__lower_bound()</code> 函数作用和之前的 <code>__upper_bound</code> 函数功能类似，都是使用二分查找算法去找目标位置。具体实现如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">_ForwardIterator</span><br><span class="line">__lower_bound(_ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">              <span class="keyword">const</span> _Tp &amp;__val, _Compare __comp) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::difference_type</span><br><span class="line">            _DistanceType;</span><br><span class="line"></span><br><span class="line">    _DistanceType __len = <span class="built_in">std</span>::distance(__first, __last);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _DistanceType __half = __len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        _ForwardIterator __middle = __first;</span><br><span class="line">        <span class="built_in">std</span>::advance(__middle, __half);</span><br><span class="line">        <span class="keyword">if</span> (__comp(__middle, __val)) &#123; <span class="comment">// 也正是这里的不同导致了两个函数功能的不同~</span></span><br><span class="line">            __first = __middle;</span><br><span class="line">            ++__first;</span><br><span class="line">            __len = __len - __half - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            __len = __half;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以分析得出，<code>lower_bound</code> 函数确实是找到大于等于 <strong>目标元素</strong> 的数值和下标，与先前的猜测相符合。</p>
<p>当然！它也是可以自定义比较函数 <code>__comp</code> 的，例子如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; b;</span><br><span class="line">    &#125;) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过修改比较函数让 <code>lower_bound()</code> 函数功能和 <code>upper_bound()</code> 函数一样，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         *upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt;= b;</span><br><span class="line">    &#125;) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt;= b;</span><br><span class="line">    &#125;) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过应该不会这么整吧，没用呀 : (</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p><code>upper_bound()</code> 和 <code>lower_bound()</code> 函数实现的都是在有序序列中查找一个可插入的位置，插入后原序列有序性不变，但是：</p>
<ul>
<li><p><code>upper_bound()</code> 找到的是大于目标数的位置</p>
</li>
<li><p><code>lower_bound()</code> 找到的是大于等于目标数的位置</p>
</li>
</ul>
<p>嗯，整完了！~</p>
<h2 id="程序源码："><a href="#程序源码：" class="headerlink" title="程序源码："></a>程序源码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/20.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/20 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vector&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;algorithm&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         *upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数 val 就是 3</span></span><br><span class="line"><span class="comment">         * 参数 b 来自 nums 中的数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> val &lt; b;</span><br><span class="line">    &#125;) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; b;</span><br><span class="line">    &#125;) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt;= b;</span><br><span class="line">    &#125;) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt;= b;</span><br><span class="line">    &#125;) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的可变参数模板</title>
    <url>/2020/09/08/CPP%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>C++可变参数模板，是指能够使用任意数量参数的函数或类模板，能够很有效的提升灵活性。</p>
<a id="more"></a>
<h1 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h1><h2 id="1-1-可变类模板"><a href="#1-1-可变类模板" class="headerlink" title="1.1 可变类模板"></a>1.1 可变类模板</h2><p>对于可变类模板，基本示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arguments&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span>;</span></span><br></pre></td></tr></table></figure>
<p>由上式可知，其特殊性在于 <code>...</code> 的使用，可变参数模板，通过使用 <code>...</code> 来帮助定义，其中，<code>...</code> 左侧为参数包（<code>parameter pack</code> ），右侧将参数包展开成多个单独的参数。</p>
<p>对于两边的空白可以任意分布，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Arguments&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Arguments&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span>;</span></span><br></pre></td></tr></table></figure>
<p>上面的类 <code>classname</code> 可以接收任意数量的参数来进行实例化，例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">classname&lt;&gt; <span class="title">c1</span><span class="params">()</span></span>;</span><br><span class="line">classname&lt;float, int&gt; c2();</span><br><span class="line">classname&lt;float, std::string, std::vector&lt;int&gt;&gt; c3();</span><br></pre></td></tr></table></figure>
<p>当然，还可以指定必须填充固定数量的参数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> first, <span class="keyword">typename</span>... Arguments&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// classname2&lt;&gt; c4(); 这是错误的用法！参数必须大于等于 1</span></span><br><span class="line"><span class="function">classname2&lt;<span class="keyword">float</span>&gt; <span class="title">c4</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-可变参数的函数模板"><a href="#1-2-可变参数的函数模板" class="headerlink" title="1.2 可变参数的函数模板"></a>1.2 可变参数的函数模板</h2><p>可变参数的函数模板基本示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(Params... params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当然，还可以使用引用类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(Params *... params)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(Params &amp;... params)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(Params &amp;&amp;... params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>还可以使用不变类型 <code>const</code> 来修饰：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(<span class="keyword">const</span> Params &amp;... params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>除此之外，还可以使用和可变参数的类模板用法一样，指定固定数量的参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(<span class="keyword">const</span> First &amp;first, <span class="keyword">const</span> Params... params)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="2-测量可变参数数量"><a href="#2-测量可变参数数量" class="headerlink" title="2. 测量可变参数数量"></a>2. 测量可变参数数量</h1><p>使用 <code>sizeof</code> 来完成，当然，该方法和之前测量字节大小的 <code>sizeof</code> 不是同一个用法，这里的 <code>sizeof</code> 是用来测量提供了多少个参数，示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tfunc</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(params) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tfunc();        <span class="comment">// &gt;: 0</span></span><br><span class="line">    tfunc(<span class="number">1</span>);       <span class="comment">// &gt;: 1</span></span><br><span class="line">    tfunc(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// &gt;: 2</span></span><br><span class="line">    tfunc(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello~YouLi~&quot;</span>);    <span class="comment">// &gt;: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-示例程序"><a href="#3-示例程序" class="headerlink" title="3. 示例程序"></a>3. 示例程序</h1><p>下面程序演示了如何使用 <strong>可变参数模板</strong> 来对函数进行重写定义并使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/8.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/8 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Rest&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> First &amp;first, <span class="keyword">const</span> Rest &amp;...rest)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(rest...); <span class="comment">// 将会根据语法来递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>();    <span class="comment">// &gt;:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>); <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// &gt;: 10, 20</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">3.14</span>, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// &gt;: 10, 20, Alice, 3.14, Bob</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>对于可变参数模板而言，都是使用某种形式的递归，但是它与传统递归是不一样的。传统的递归使用的是一样的函数声明，但是可变参数模板使用的是不同参数数量的函数<strong>（每次都会递减）</strong>声明，从而每次都区分出当前次使用的函数签名。和一般的递归一样，都需要一个终止递归的 <strong>base-line</strong> 条件，但是这里的含义不同。</p>
<blockquote>
<p>参考自 Ellipsis and Variadic Templates： <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/ellipses-and-variadic-templates?view=vs-2019">https://docs.microsoft.com/zh-cn/cpp/cpp/ellipses-and-variadic-templates?view=vs-2019</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的多线程（Ⅰ）</title>
    <url>/2020/09/26/CPP%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B1/</url>
    <content><![CDATA[<blockquote>
<p>  今天是预报名的最后一天，你一定可以成功上岸，矿大等你~😘加油💪~，相信你而且很坚定！</p>
</blockquote>
<p>从 <code>C++11</code> 开始，C++标准委员会开始关注多线程的处理，并提供关于线程操作的标准库 <code>&lt;thread&gt;</code> 。而在此之前，C++程序员已经苦<strong>平台相关性</strong>的非标准多线程库久矣……</p>
<a id="more"></a>
<p>多线程本身就是一个很广范的内容，包括管理、调度、锁和同步、内存模型等内容，因此本文先从C++线程中的线程管理开始，逐步介绍线程的<strong>创建</strong>、<strong>启动</strong>、<code>join</code> 、<code>detach</code> 操作。</p>
<p>当然，在下面开始之前，需要得到一个支持 <code>C++11</code> 标准的编译器。</p>
<h1 id="1-C-多线程创建和启动"><a href="#1-C-多线程创建和启动" class="headerlink" title="1. C++多线程创建和启动"></a>1. C++多线程创建和启动</h1><p>首先引入 <code>&lt;thread&gt;</code> 头文件，该头文件包括了对C++多线程相关的类。引入头文件完成之后可以使用 <code>std::thread</code> 来创建一个线程。</p>
<h2 id="1-1-外部函数创建线程"><a href="#1-1-外部函数创建线程" class="headerlink" title="1.1 外部函数创建线程"></a>1.1 外部函数创建线程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;   // 引入头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_task</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// 声明要执行的任务函数（也可为callable类型）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; * &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(func_task, i)</span></span>; <span class="comment">// 创建线程 t（并为线程指定任务 func_task）</span></span><br><span class="line">        t.<span class="built_in">detach</span>();             <span class="comment">// 将线程 t 与当前线程分离</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 015 * 9 *  * 2 *  * 7 * 3 * 6 * 4 * 8 *</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一步骤中，创建了 <code>10</code> 个线程，并且它们需要执行的任务都是 <code>func_task</code> ，也就是说这十个线程需要在各自的线程执行期间去执行 <code>func_task</code> 这个函数。当这十个线程创建完成之后 <code>thread t(func_task, i);</code> 就已经开始执行了，不需要特殊声明。</p>
<p>而对于 <code>t.detach()</code> ，表示允许该线程 <code>t</code> 脱离当前线程去运行，而无需等待当前线程执行结束，后面会详细说明。</p>
<p>从输出结果：<code>015 * 9 *  * 2 *  * 7 * 3 * 6 * 4 * 8 *</code> 可以看出这十个线程在执行顺序上并没有固定逻辑，例如第二次重新执行得到的结果为：<code>01 * 4 * 3 * 5 * 9 * 7 * 2 * 8 * 6 *  *</code>，那是因为这十个线程在优先级上并没有做区分，完全是独立运行得到的。</p>
<h2 id="1-2-lambda-创建线程"><a href="#1-2-lambda-创建线程" class="headerlink" title="1.2 lambda 创建线程"></a>1.2 lambda 创建线程</h2><p>当然在创建时候，也可以传入一个 <code>lambda</code> 表达式（匿名函数），例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;   // 引入头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> func_lambda = [](<span class="keyword">int</span> i) &#123; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; - &quot;</span>; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(func_lambda, i)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 024 - 5 -  - 1 - 6 - 7 - 3 - 9 - 8 -  -</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">([](<span class="keyword">int</span> i) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; - &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;, i)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-Callable-类型创建线程"><a href="#1-3-Callable-类型创建线程" class="headerlink" title="1.3 Callable 类型创建线程"></a>1.3 Callable 类型创建线程</h2><p>声明一个类，然后重载它的 <code>()</code> 运算符，实现 <code>callable</code> 类型的线程创建。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;   // 引入头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; () &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">Task</span> task;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(task, i)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 024 () 3 () 1 ()  () 6 () 8 () 9 () 5 ()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在这里需要把 <code>()</code> 运算符重载为 <code>public</code> 访问域，否则会识别不到。不过在此处需要注意的是，如果创建过程为：<code>thread t(Task(), i)</code></p>
<h1 id="2-C-线程的-join-操作"><a href="#2-C-线程的-join-操作" class="headerlink" title="2. C++线程的 join 操作"></a>2. C++线程的 join 操作</h1><p><code>join</code> 是一种等待线程结束的运算，例如 <code>main</code> 线程启动了 <code>t</code> 线程，然后 <code>t</code> 线程在启动完成过后执行了 <code>t.join()</code> ，那么 <code>main</code> 线程需要等待 <code>t</code> 线程执行结束之后，才能继续执行 <code>main</code> 函数下面的程序。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id &lt;&lt; <span class="string">&quot;: &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="comment">// &gt;: 2: 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    <span class="comment">//    1:0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般使用这种方法，是因为原始线程在其生命周期中没有了其他的事可做，或者说独立出来一个线程去执行函数收效甚微。使用 <code>join</code> 是简单粗暴的等待线程，当需要对线程进行更灵活的控制时，比如看某个线程是否存活，或者设置<strong>等待超时</strong>，可以使用<strong>条件变量</strong>或者<strong>期待（futures，也称期货模型）</strong>去实现。</p>
<p>噢！对，只能对一个线程执行一次 <code>join</code> 操作一次，所以在执行 <code>join</code> 操作之前，对其使用 <code>joinable</code> 检查操作更加合适。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t1 id: &quot;</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// &gt;: t1 id: 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t1.joinable() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="keyword">if</span> (t1.joinable()) &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; t1.joinable() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-C-线程的-detach-操作"><a href="#3-C-线程的-detach-操作" class="headerlink" title="3. C++线程的 detach 操作"></a>3. C++线程的 detach 操作</h1><p>在<code>C++11</code>中对线程规定了 <code>detach</code> 操作，顾名思义就是将线程与当前线程<strong>分离</strong>，实际上该操作可以将创建好的线程丢到后台去运行，这也就意味着创建它的线程将不能再与之直接交互，例如 <code>join</code> 操作、引用该对象等。所以一般来说，该操作都是用来创建<strong>守护线程</strong>的。具体操作如下例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;joinable? &quot;</span> &lt;&lt; t.joinable() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// &gt;: joinable? 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t.get_id() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: thread::id of a non-executing thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了分离线程，前提肯定是该线程要能分离，所以我们也可以使用 <code>joinable</code> 来对它进行检查，如果反回的是 <code>true</code> 说明可以对它进行 <code>detach</code> 操作。</p>
<blockquote>
<p>  守护线程（daemon threads）：在UNIX中守护线程是指没有任何用户接口，并在后台运行的线程。特点运行时间长，前台感受不到这个线程的存在 😑。（fire and forget 类型的任务就是使用到这种操作了）</p>
</blockquote>
<h3 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h3><ol>
<li><p><code>hello_thread.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/26.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/26 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;   // 引入头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_task</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// 声明要执行的任务函数（也可为callable类型）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; * &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; () &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(func_task, i)</span></span>; <span class="comment">// 创建线程 t（并为线程指定任务 func_task）</span></span><br><span class="line">        t.<span class="built_in">detach</span>();             <span class="comment">// 将线程 t 与当前线程分离</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 015 * 9 *  * 2 *  * 7 * 3 * 6 * 4 * 8 *</span></span><br><span class="line">    this_thread::sleep_for(chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(func_task, i)</span></span>; <span class="comment">// 创建线程 t（并为线程指定任务 func_task）</span></span><br><span class="line">        t.join();               <span class="comment">// 将线程 t 并入到当前线程中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 0 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 *</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func_lambda = [](<span class="keyword">int</span> i) &#123; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; - &quot;</span>; &#125;;</span><br><span class="line">    <span class="comment">// 024 - 5 -  - 1 - 6 - 7 - 3 - 9 - 8 -  -</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(func_lambda, i)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 -</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(func_lambda, i)</span></span>;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">([](<span class="keyword">int</span> i) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; - &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;, i)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">Task</span> task;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(task, i)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 024 () 3 () 1 ()  () 6 () 8 () 9 () 5 ()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>thread_join.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/27.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/27 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id &lt;&lt; <span class="string">&quot;: &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="comment">// &gt;: 2: 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    <span class="comment">//    1:0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    <span class="comment">// &gt;: 2: 0 1 2 3 4 5 6 7 8 1 :0 1 2 3 4 5 6 7 8 9 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>thread_joinable.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/27.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/27 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t1 id: &quot;</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// &gt;: t1 id: 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t1.joinable() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="keyword">if</span> (t1.joinable()) &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; t1.joinable() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>thread_detach.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/27.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/27 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;joinable? &quot;</span> &lt;&lt; t.joinable() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// &gt;: joinable? 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t.get_id() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: thread::id of a non-executing thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的多线程（Ⅱ）</title>
    <url>/2020/09/28/CPP%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B2/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/vdx6USLcafB9yriwNpNwBQ">上次</a>了解了C++如何创建、运行以及如何对线程进行 <code>join</code> 和 <code>detach</code> 操作。这次就来了解线程的<strong>参数传递</strong>以及<strong>权限转移</strong>操作。</p>
<a id="more"></a>
<h1 id="1-参数传递"><a href="#1-参数传递" class="headerlink" title="1. 参数传递"></a>1. 参数传递</h1><p>开门见山地说，在 <code>&lt;thread&gt;</code> 中，对线程中执行的函数进行参数传递是很简单但需要注意细节的。简单之处在于没有多余的语法，细节在于传递引用参数。一个简单例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello~ &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(hello, <span class="string">&quot;Cherry&quot;</span>)</span></span>; <span class="comment">// &gt;: Hello~ Cherry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里创建了一个线程 <code>t1</code> ，<code>t1</code> 执行的函数是 <code>hello</code>，它需要接收一个 <code>string</code> 类型的参数进来，然后打声招呼 <code>&gt;: Hello~XXX</code> 。很明显的，当需要传递参数时，直接在 <code>thread</code> 的构造函数中传递就可以了，在底层源码中是这样实现的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 首先声明可变长度模板，有一个必须提供的参数是 _Callable ，其余为可选参数</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    <span class="keyword">explicit</span></span><br><span class="line">    thread(_Callable &amp;&amp;__f, _Args &amp;&amp;... __args) &#123;</span><br><span class="line">        <span class="comment">// 查看是否激活 gthr 代理</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GTHR_ACTIVE_PROXY</span></span><br><span class="line">        <span class="comment">// Create a reference to pthread_create, not just the gthr weak symbol.</span></span><br><span class="line">    <span class="keyword">auto</span> __depend = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>(*)()&gt;(&amp;pthread_create);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">auto</span> __depend = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 创建执行函数，并且将参数进行传递</span></span><br><span class="line">        _M_start_thread(_S_make_state(  <span class="comment">// 创建状态</span></span><br><span class="line">                __make_invoker(         <span class="comment">// 创建执行函数，并执行</span></span><br><span class="line">                        <span class="built_in">std</span>::forward&lt;_Callable&gt;(__f),   <span class="comment">// callable 类型转换</span></span><br><span class="line">                        <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...) <span class="comment">// 参数类型转换</span></span><br><span class="line">                        ),</span><br><span class="line">                        __depend);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 用来执行的包装器 (forwarded tuple elements...)</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tuple&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Invoker</span> &#123;</span></span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Tp&gt;</span><br><span class="line">    <span class="keyword">using</span> __decayed_tuple = tuple&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;_Tp&gt;::type...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回一个可调用的包装器，里面有：</span></span><br><span class="line">    <span class="comment">// tuple&#123;DECAY_COPY(__callable), DECAY_COPY(__args)...&#125;.</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    <span class="keyword">static</span> _Invoker&lt;__decayed_tuple&lt;_Callable, _Args...&gt;&gt;</span><br><span class="line">    __make_invoker(_Callable &amp;&amp;__callable, _Args &amp;&amp;... __args) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;__decayed_tuple&lt;_Callable, _Args...&gt;&#123;</span><br><span class="line">                <span class="built_in">std</span>::forward&lt;_Callable&gt;(__callable), <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>thread</code> 构造函数接收一个 <code>callable</code> 类型的参数作为执行函数，这个是必选参数。后面可以可选附加若干个 <code>Args</code> 类型的参数来填充 <code>callable</code> 函数。不过需要注意的是，<strong>向线程中执行函数传递引用类型的参数</strong>可不是容易的事，例如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">buffer</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">([](<span class="built_in">string</span> buf) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        buf.append(<span class="string">&quot;world!&quot;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// &gt;: 3 - helloworld!</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;, <span class="built_in">buffer</span>)</span></span>;</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; <span class="built_in">buffer</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// &gt;: 1 - hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见变量 <code>buffer</code> 在线程 <code>t2</code> 中并没有得到修改。那么试试引用传递：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 会出现编译错误！</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  thread t3([](string &amp;buf) &#123;</span></span><br><span class="line"><span class="comment">     *      buf.append(&quot;world!&quot;);</span></span><br><span class="line"><span class="comment">     *      cout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; string buf: &quot; &lt;&lt; &quot; - &quot; &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">     *  &#125;, buffer);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写在一般的函数调用中，当然是没有问题的，不过在多线程中却是不可行的，那么该怎样传递引用类型，然后在线程中完成访问呢？这里需要使用 <code>ref()</code> 函数将参数转换成引用类型的形式，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t_ref</span><span class="params">([](<span class="built_in">string</span> &amp;buf) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        buf.append(<span class="string">&quot; world!&quot;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// &gt;: 4 - hello world!</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;, ref(<span class="built_in">buffer</span>))</span></span>;</span><br><span class="line">    t_ref.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; <span class="built_in">buffer</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// &gt;: 1 - hello world!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，就可以在线程内部，对外部变量进行修改。当然，除此之外，还可以使用这样一种方式来完成相同的目的：<strong>传递一个类的成员函数作为线程函数，并提供一个对象指针作为第一个参数</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">(<span class="built_in">string</span> &amp;name)</span> </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;hello~ &quot;</span> + name;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Task</span> task;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="string">&quot;Cherry&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(&amp;<span class="built_in">Task</span>::do_something, &amp;task, <span class="built_in">std</span>::ref(name))</span></span>;</span><br><span class="line">    t4.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// &gt;: Cherry -&gt; hello~ Cherry -&gt; hello~ Cherry</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，传入线程构造函数的有 <code>Task</code> 的成员函数 <code>do_something</code> 函数指针，以及一个 <code>Task</code> 类的实例 <code>task</code>，在剩余的参数中，把相应的参数列表传了进来，从而实现在 <code>Task</code> 的成员函数中对外部变量进行修改。</p>
<h1 id="2-权限转移"><a href="#2-权限转移" class="headerlink" title="2. 权限转移"></a>2. 权限转移</h1><p>创建一个线程之后，如果想转移所有权，那么需要等待线程结束才能进行。那么可以通过线程权限转移，使用 <code>move</code> 函数来移动一个 <code>thread</code> 所有权到另一个 <code>thread</code> 对象中去，来实现控制。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; ownership! + &quot;</span> &lt;&lt; ++count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        this_thread::sleep_for(chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(do_something)</span></span>;</span><br><span class="line">    this_thread::sleep_for(chrono::seconds(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    thread t2 = <span class="built_in">move</span>(t1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t1.joinable() ? &quot;</span> &lt;&lt; t1.joinable() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: t1.joinable() ? 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t2.joinable() ? &quot;</span> &lt;&lt; t2.joinable() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: t2.joinable() ? 1</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2 ownership! + 1</span></span><br><span class="line"><span class="comment">     * 2 ownership! + 2</span></span><br><span class="line"><span class="comment">     * t1.joinable() ? 0</span></span><br><span class="line"><span class="comment">     * t2.joinable() ? 1</span></span><br><span class="line"><span class="comment">     * 2 ownership! + 3</span></span><br><span class="line"><span class="comment">     * 2 ownership! + 4</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>);<span class="comment">// 在这里空转，不让 main 线程结束掉，否则会丢失输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>t1</code> 首先获取了执行函数 <code>do_something</code> ，然后执行两秒钟后，重新将 <code>do_something</code> 转移给了 <code>t2</code> ，此时 <code>t1</code> 便不再有绑定执行函数了。从 <code>joinable</code> 也可看出来 <code>t1</code> 已经变成不可 <code>join</code> 的对象。不仅如此，在权限转移过程中，并没有让原来执行的过程中断或重启，从输出 <code>1, 2, 3 ,4 ...</code> 连续性中可以看出。</p>
<p>被转移走权限的 <code>t1</code> 就好像一个空壳，它虽然仍然是一个线程对象（还可以被 <code>move</code> ），但是它的执行函数已经木有了（就算 <code>move</code> ，接收的对象也接收不到任何东西），所以对它再进行线程上的操作是没有意义的。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; ownership! + &quot;</span> &lt;&lt; ++count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        this_thread::sleep_for(chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    thread t4 = <span class="built_in">move</span>(t1); <span class="comment">// 虽然转移了过来，但是线程 t4 并没有可执行的函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t4.joinable() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不仅如此，对一个拥有执行函数的 <code>thread</code> 对象进行 <code>move</code> 赋值时，也会报错，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; ownership! + &quot;</span> &lt;&lt; ++count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        this_thread::sleep_for(chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(do_something)</span></span>;</span><br><span class="line">    this_thread::sleep_for(chrono::seconds(<span class="number">2</span>));</span><br><span class="line">    thread t2 = <span class="built_in">move</span>(t1);</span><br><span class="line">    thread t3 = thread(do_something);</span><br><span class="line">    t3 = <span class="built_in">move</span>(t2); <span class="comment">// 会报错，因为 t3 已经和一个函数关联，这时候再给他一个会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这个是不可以被覆盖的，简而言之就是：<strong>可以通过</strong> <code>std::move()</code> <strong>转移一个线程所有权给一个未关联线程的</strong> <code>thread</code> <strong>对象，但是不能通过赋一个新值的方式丢弃一个线程</strong>。</p>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类的初识</title>
    <url>/2020/10/08/CPP%E7%B1%BB%E7%9A%84%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<p>这两天补了补C++关于类的内容，参考的是  <a href="https://book.douban.com/subject/25708312/">C++ Primer (5th)</a>。</p>
<blockquote>
<p>   类的基本思想是<strong>数据抽象（Data Abstraction）</strong>和<strong>封装（encapsulation）</strong>。数据抽象是一种依赖接口（interface）和实现（implementation）分离的编程技术。封装实现了类的接口和实现的分离。</p>
</blockquote>
<a id="more"></a>
<h1 id="1-定义抽象数据类型"><a href="#1-定义抽象数据类型" class="headerlink" title="1. 定义抽象数据类型"></a>1. 定义抽象数据类型</h1><p>假设有这么一个类：它是书籍的抽象，包括三个字段：</p>
<ul>
<li><code>isbn</code>：书籍的 <code>ISBN</code> 号</li>
<li><code>units_sold</code>：书籍的销售数量</li>
<li><code>revenue</code>：书籍的销售额</li>
</ul>
<p>那么这个类可以是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> bookNo; 			<span class="comment">// isbn</span></span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;<span class="comment">// 卖出去多少本</span></span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;;	<span class="comment">// 这本书所获得的收入</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 四个构造函数</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) : bookNo(s) &#123;&#125;;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p) : bookNo(s), units_sold(n), revenue(p * n) &#123;&#125;;</span><br><span class="line">    Sales_data(istream &amp;);</span><br><span class="line">    <span class="comment">// 两个成员函数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;;	<span class="comment">// 获取到这本书的 isbn 号，默认 inline 函数</span></span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;)</span></span>;<span class="comment">// 将两个 Sales_Data 出售量相加</span></span><br><span class="line">    <span class="comment">// 友元声明函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个非成员接口函数</span></span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.avg_price();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span> </span>&#123;</span><br><span class="line">    Sales_data sum = lhs;</span><br><span class="line">    sum.combine(rhs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-1-成员函数"><a href="#1-1-成员函数" class="headerlink" title="1.1 成员函数"></a>1.1 成员函数</h2><p>其中的 <code>double avg_price() const;</code> 、 <code>string isbn() const;</code>  、 <code>Sales_data &amp;combine(const Sales_data &amp;);</code> 均只有声明，并未具体定义。</p>
<blockquote>
<p>  成员函数必须在类的内部<strong>声明</strong>，但是不是必须在类的内部<strong>定义</strong>。而且定义在类内部的函数是隐式 <code>inline</code> 的。</p>
<p>  成员函数通过一个名为 <code>this</code> 的额外隐式参数来访问调用它的那个对象。</p>
</blockquote>
<p>例如，当我们在调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">total.isbn();</span><br></pre></td></tr></table></figure>
<p>实际上编译器会把 <code>total</code> 的地址传递给 <code>isbn()</code> 的隐式形参 <code>this</code>，可以当作以下调用过程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data::isbn(&amp;total);</span><br></pre></td></tr></table></figure>
<p>这一点可以类比 <code>Python</code> 中成员函数的 <code>self</code> 变量。在成员函数体内部去使用任何对象的成员，都会被看作是 <code>this</code> 的隐式引用过程。例如， <code>isbn()</code> 函数的调用可以等价为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;;</span><br></pre></td></tr></table></figure>
<p>而且，每个对象的 <code>this</code> 指针总是指向该对象自己，所以它是默认 <code>const</code> 的（一个常量指针），不允许改变 <code>this</code> 中的地址。</p>
<h2 id="1-2-const-成员函数"><a href="#1-2-const-成员函数" class="headerlink" title="1.2 const 成员函数"></a>1.2 <code>const</code> 成员函数</h2><blockquote>
<p>  紧随参数列表之后的 <code>const</code> 关键字，作用是修改隐式 <code>this</code> 指针的类型。</p>
</blockquote>
<p>例如 <code>isbn()</code> 函数，函数签名末尾附带了一个 <code>const</code> ，这个 <code>const</code> 意思是说，在这个函数内部，不允许修改调用者的内容（当然也有例外，例如声明了 <code>mutable</code> 的成员😮）。简而言之 <code>const</code> 放在函数签名之后意思是：对象只能读不能写。</p>
<blockquote>
<p>  常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p>
</blockquote>
<h2 id="1-3-定义一个返回-this-对象的函数"><a href="#1-3-定义一个返回-this-对象的函数" class="headerlink" title="1.3 定义一个返回 this 对象的函数"></a>1.3 定义一个返回 <code>this</code> 对象的函数</h2><p>来，直接看例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;rhs)</span> </span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，功能类似于 <code>+=</code>，其返回值为 <code>Sales_data &amp;</code> 一个引用类型，那么最后返回值为 <code>*this</code>，也就把调用者给带了回来。这样写的好处在于，可以这样子用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">data.combine(b).combine(c).combine(e).......</span><br></pre></td></tr></table></figure>
<h2 id="1-4-定义类相关的非成员函数"><a href="#1-4-定义类相关的非成员函数" class="headerlink" title="1.4 定义类相关的非成员函数"></a>1.4 定义类相关的非成员函数</h2><p>例如上面例子中的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>三个函数，这三个函数并不是成员函数，但是它们做了一些辅助工作，所以它们和 <code>Sales_data</code> 类相关，这样的函数<strong>一般都要放到类声明的头文件内</strong>，这样方便用户引入一个头文件就可以使用了。</p>
<h2 id="1-5-定义构造函数"><a href="#1-5-定义构造函数" class="headerlink" title="1.5 定义构造函数"></a>1.5 定义构造函数</h2><p>关于构造函数，和 <code>Java</code> 它们都类似：没返回值，函数名和类名同名，可重载，如果一个都没有那么编译器会默认给补上，如果有任意一个那么编译器不补……在这里主要说一个不同的：</p>
<p><code>= default</code> 默认构造函数：这是 <code>C++11</code> 带来的新特性，当定义了其他（有参数）的构造函数后，如果还需要默认空参数列表的构造函数，可以使用 <code>Sales_data() = default;</code> 来让编译器继续补上。同样的，如果在类内部，那么该函数就是 <code>inline</code> 的。</p>
<p>初始值列表可以使用 <code>Sales_data(const string &amp;s) : bookNo(s) &#123;&#125;;</code> 这样的形式来定义，<code>:</code> 冒号加 <code>()</code> 定义法（自己想的名字😊）</p>
<h1 id="2-访问控制和封装"><a href="#2-访问控制和封装" class="headerlink" title="2. 访问控制和封装"></a>2. 访问控制和封装</h1><p>使用 <code>public</code> 、<code>protected</code> 、<code>private</code> 访问说明符来控制下面的内容是可以怎样访问的。</p>
<p>使用 <code>struct</code> 和 <code>class</code> 关键字来声明类，仅仅在访问方式上有所差别：</p>
<blockquote>
<p>  使用 <code>struct</code> 时，默认类的成员都是 <code>public</code> 的；使用 <code>class</code> 时，默认类的成员都是 <code>private</code> 的。所以仅仅通过编程风格就可决定使用哪一个。</p>
</blockquote>
<h2 id="2-1-友元"><a href="#2-1-友元" class="headerlink" title="2.1 友元"></a>2.1 友元</h2><p>这个东西就是方便了非本类的内容来访问本类的内容。例如：其他类或者其他不属于自己的函数，例如的例如：上面的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 友元声明函数</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这三个方法原来是没办法访问类内的私有变量的，例如 <code>revenue</code> 成员，但是加上 <code>friend</code> 之后就可以了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.avg_price();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>友元声明只能放到类的内部，但是类内出现的具体位置不限。而且友元不受访问控制的限制。</p>
<blockquote>
<p>  一般来说，最好在类的定义开始或者结束前的位置集中声明友元。</p>
</blockquote>
<p>除此之外，友元不能传递，例如 <code>B</code> 是 <code>A</code> 的友元，<code>C</code> 是 <code>B</code> 的友元，那么 <code>C</code> 也不能访问人家 <code>A</code> 的私有变量，谁的朋友就是谁的，不能乱来。</p>
<p>还有一个需要注意的地方，友元函数在类内声明之后，如果在同一个文件里实现，有两种选择，一种就是直接在类内实现，另一个就是类外内联。如果这两个都不满意，需要放到另外的文件夹里进行实现，在同一个文件里必须内联。</p>
<p>而且，如果是类的成员函数去调用类的友元函数，那么也是必须被声明过的（不过，并不是所有的编译器都要求这样的规定）。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//    X() &#123; f(); &#125; 错误的！f() 还没有声明！</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// void X::g() &#123; return f(); &#125; 错误的！因为 f() 还没有得到声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f(); &#125;</span><br></pre></td></tr></table></figure>
<p>（这里 CLion 有坑！暂时没填！具体现象就是：有时候不单独再声明一遍也可以直接使用友元函数，就是没语法提示，但有时候直接就是报错！换个构造函数、填充初始值都能让这个问题解决。具体参考下面的 <code>X.hh</code> 和 <code>X.cc</code>）</p>
<h2 id="2-X-聊点好玩的"><a href="#2-X-聊点好玩的" class="headerlink" title="2.X 聊点好玩的"></a>2.X 聊点好玩的</h2><p><strong>封装的好处</strong>，两个优点：</p>
<ul>
<li>确保用户代码不会无意间破坏封装对象的状态</li>
<li>被封装的具体实现，可以随时改变，只要对外的接口没变就行</li>
</ul>
<h1 id="3-其他特性"><a href="#3-其他特性" class="headerlink" title="3. 其他特性"></a>3. 其他特性</h1><h2 id="3-1-成员类型别名"><a href="#3-1-成员类型别名" class="headerlink" title="3.1 成员类型别名"></a>3.1 成员类型别名</h2><p>使用 <code>typedef type name</code> 或者 <code>using name = type</code> 来完成定义。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line"><span class="keyword">using</span> ScreenIndex = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt;::size_type;</span><br></pre></td></tr></table></figure>
<p>那么在下文中，就可以这样使用了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Screen(pos ht, pos wd, <span class="keyword">char</span> c) : <span class="built_in">height</span>(ht), <span class="built_in">width</span>(wd), contents(ht * wd, c) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(ScreenIndex index)</span></span>;</span><br></pre></td></tr></table></figure>
<p>而且用来定义类型的成员必须放在最前面，因为<strong>先定义后使用</strong>。</p>
<h2 id="3-2-内联函数-inline"><a href="#3-2-内联函数-inline" class="headerlink" title="3.2 内联函数 inline"></a>3.2 内联函数 <code>inline</code></h2><blockquote>
<p>   在类的内部定义的成员函数默认为 <code>inline</code> 类型，当然也有一些规模较小的函数适合于被声明成内联函数，然后放在类外进行定义。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line">    <span class="comment">// 声明一个友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Windows_Mgr</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用类型别名等价地去声明一个类型名字</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> contents[<span class="built_in">cursor</span>]; &#125;   <span class="comment">// 隐式内联函数</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">get</span><span class="params">(pos r, pos c)</span> <span class="keyword">const</span></span>;          	<span class="comment">// 显式内联函数</span></span><br><span class="line">    <span class="function">Screen &amp;<span class="title">move</span><span class="params">(pos r, pos c)</span></span>;                     <span class="comment">// 能在外面被设置为内联函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line">    pos <span class="built_in">height</span> = <span class="number">0</span>, <span class="built_in">width</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::move</span><span class="params">(pos r, pos c)</span> </span>&#123;</span><br><span class="line">    pos row = r * <span class="built_in">width</span>;</span><br><span class="line">    <span class="built_in">cursor</span> = row + c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">// 把自己返回回去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，使用内联函数时要注意：</p>
<p>要么在 <code>.hh</code> 头文件中写好 <code>inline</code> 函数的定义（和声明在同一个文件中），要么在 <code>.cc</code> 文件中不要写当作一个普通成员函数。</p>
<h2 id="3-3-可变数据成员"><a href="#3-3-可变数据成员" class="headerlink" title="3.3 可变数据成员"></a>3.3 可变数据成员</h2><p><code>mutable</code> 扭转一切，即便调用一个 <code>const</code> 方法，如果内部修改的变量是声明为 <code>mutable</code> 的，那么它也可以正常修改，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> assess_ctr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_somethings</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sales_data::do_somethings</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    assess_ctr++; <span class="comment">// 这样也是成立的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了~🥱这次就先到这里……😪😪😪</p>
<h1 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h1><p><code>Sales_data.hh</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/10/7.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/10/7 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CXX_EXE_SALES_DATA_HH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CXX_EXE_SALES_DATA_HH</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> assess_ctr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) : bookNo(s) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p) : bookNo(s), units_sold(n), revenue(p * n) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Sales_data(istream &amp;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span> </span>&#123;</span><br><span class="line">        Sales_data sum = lhs;</span><br><span class="line">        sum.combine(rhs);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">get_units</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_somethings</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="title">Sales_data::get_units</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> units_sold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sales_data::do_somethings</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    assess_ctr++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.avg_price();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//CXX_EXE_SALES_DATA_HH</span></span></span><br></pre></td></tr></table></figure>
<p><code>Sales_data.cc</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/10/7.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/10/7 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Sales_data.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (units_sold) <span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;rhs)</span> </span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sales_data::Sales_data(istream &amp;is) &#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>X.cc</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/10/8.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/10/8 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;X.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">X::get_id</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>X.hh</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/10/8.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/10/8 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CXX_EXE_X_HH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CXX_EXE_X_HH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">helloX</span><span class="params">(<span class="keyword">const</span> X &amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello World!&quot;</span> &lt;&lt; x.id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_id</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//CXX_EXE_X_HH</span></span></span><br></pre></td></tr></table></figure>
<p><code>CMakeLists.txt</code>:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(CXX_Exe)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cc</span><br><span class="line">        Sales_data.cc Sales_data.hh</span><br><span class="line">        Screen.hh Screen.cc</span><br><span class="line">        Windows_Mgr.hh Windows_Mgr.cc</span><br><span class="line">        X.hh X.cc</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C和C++使用对方编译的动态链接库</title>
    <url>/2020/10/04/C%E5%92%8CCPP%E4%BD%BF%E7%94%A8%E5%AF%B9%E6%96%B9%E7%BC%96%E8%AF%91%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</url>
    <content><![CDATA[<p>C使用C++编译出来的动态链接库，C++使用C编译出来的动态链接库，C使用C编译出来的动态链接库，C++使用C++编译出来的动态链接库……</p>
<a id="more"></a>
<p>最近和师兄们搭伴做加密系统，自己负责加密算法部分，师兄们负责更加底层的硬件接口部分。但是因为个人原因我不大喜欢 <code>C</code> 语言，当然是相比较于 <code>C++</code> 而言，所以自己就用了 <code>C++</code> 去实现加密算法。这么一来，就涉及到和师兄写的程序之间接口问题，于是乎就研究了下怎样导出动态链接库以供他人使用。</p>
<p>对于 <code>C</code> 和 <code>C++</code> 之间的关系，可不是 <code>Java</code> 和 <code>JavaScript</code> 之间的关系，所以操作起来相对而言还是比较容易的，但是也有一些坑需要注意，要不然也不至于在<strong>2020</strong>年的国庆节折腾这折腾了两天😟，难度系数表如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>库\可执行程序</th>
<th>C++</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>C++</td>
<td>简单</td>
<td>不简单</td>
</tr>
<tr>
<td>C</td>
<td>相对简单</td>
<td>简单</td>
</tr>
</tbody>
</table>
</div>
<p>因为 <code>C/C++</code> 对系统环境比较敏感，这里列出写这篇文章时的系统情况：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE</td>
<td>CLion 2020.2.3</td>
</tr>
<tr>
<td>System</td>
<td>Windows 64</td>
</tr>
<tr>
<td>Environment</td>
<td>MinGW w64 6.0</td>
</tr>
<tr>
<td>Tool Chains</td>
<td>CMake 3.17.3</td>
</tr>
</tbody>
</table>
</div>
<p>噢，对了，还有重要的 <code>C</code> 和 <code>C++</code> 版本：</p>
<ul>
<li><code>C</code> ：C99</li>
<li><code>C++</code> ：C++17</li>
</ul>
<h1 id="1-C导出动态链接库给C-用"><a href="#1-C导出动态链接库给C-用" class="headerlink" title="1. C导出动态链接库给C++用"></a>1. C导出动态链接库给C++用</h1><blockquote>
<p>   什么？上来为什么要说这个？那肯定是因为简单啊！那为什么不说另外两个更简单的？那肯定是因为没做啊😉</p>
</blockquote>
<p>先来考虑这样一个需求：小张小明是朋友，小张喜欢 <code>C++</code> ，小明不得不用 <code>C</code> ，而小明需要给小张提供一些库，小张使用小明提供的库进行上层开发，那么也就是：</p>
<ul>
<li>小明使用 <code>C</code> 语言写了个驱动，导出 <code>DLL</code> 动态链接库</li>
<li>小张拿到小明导出的 <code>DLL</code> 动态链接库，引入到项目中，使用在 <code>DLL</code> 中编译好的函数（或数据结构）</li>
</ul>
<p>那么他俩可以这样做：</p>
<h2 id="1-1-小明的工作目录"><a href="#1-1-小明的工作目录" class="headerlink" title="1.1 小明的工作目录"></a>1.1 小明的工作目录</h2><p>小明的工作目录长这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:.</span><br><span class="line">│  CMakeLists.txt</span><br><span class="line">│  library.c</span><br><span class="line">│  library.h</span><br><span class="line">└─cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>其中的 <code>cmake-build-debug</code> 是用来存放 <code>CMake</code> 执行过程中产生的文件，可以暂时忽略不计，主要关注这几个文件的内容：</p>
<ol>
<li><code>CMakeLists.txt</code> 规定了怎样去编译这个库，怎样导出。这里主要说明了项目名称，使用的语言，<code>C</code> 语言的标准用哪一版，以及库的依赖文件和导出方式（<code>SHARED</code> )</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(C_Lib C)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"><span class="keyword">add_library</span>(C_Lib SHARED library.c library.h)</span><br></pre></td></tr></table></figure>
<ol>
<li><code>library.h</code> 函数的声明，简简单单，普普通通</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> C_LIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C_LIB_LIBRARY_H</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//C_LIB_LIBRARY_H</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>library.c</code> 函数的实现，更加朴素</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;library.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这些之后，点击编译项目或 <code>Ctrl+F9</code> 快捷键编译或者输入命令编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake.exe --build .\cmake-build-debug --target C_Lib -- -j 6</span><br></pre></td></tr></table></figure>
<p>完成后可以看到如下输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[100%] Built target C_Lib</span><br></pre></td></tr></table></figure>
<p>那么可以在 <code>cmake-build-debug</code> 目录下找到 <code>libC_Lib.dll</code> 文件，这个文件就是用来给小张用的。</p>
<p>好了，小明可以去吃苹果了🍎。 </p>
<h2 id="1-2-小张的工作目录"><a href="#1-2-小张的工作目录" class="headerlink" title="1.2 小张的工作目录"></a>1.2 小张的工作目录</h2><p>小张的工作目录长这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\SOURCE\C++\TEMP\CXX_EXE</span><br><span class="line">│  CMakeLists.txt</span><br><span class="line">│  libC_Lib.dll</span><br><span class="line">│  main.cpp</span><br><span class="line">└─cmake-build-debug	</span><br></pre></td></tr></table></figure>
<p>这里主要多了一个 <code>libC_Lib.dll</code> 文件，这个文件就是来自小明的，那么该如何使用里面定义的 <code>hello()</code> 方法？</p>
<ul>
<li>首先，需要导入到当前项目中，这里使用 <code>CMakeLists.txt</code> 来完成：</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(CXX_Exe)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(.) <span class="comment"># 从当前目录中寻找链接文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(CXX_Exe main.cpp library.h)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(CXX_Exe libC_Lib.dll) <span class="comment"># 将 libC_Lib.dll 链接到 CXX_Exe 目标文件中</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用头文件 <code>library.h</code> 中引入函数声明</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> C_LIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C_LIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//C_LIB_LIBRARY_H</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>C++</code> 源文件 <code>main.cpp</code> 中使用 <code>hello()</code> 函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;library.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hello(); <span class="comment">// &gt;: Hello, World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不过！重点之一来了！</strong>为什么在头文件 <code>library.h</code> 中写一个 <code>extern &quot;C&quot;</code> 呢？是因为 <code>C</code> 的编译链接过程，<strong>中间代码不会修改函数名称</strong>，而 <code>C++</code> 在这个过程中<strong>将会修改</strong>！因此，为了让 <code>C++</code> 识别出来 <code>C</code> 函数，需要使用 <code>extern &quot;C&quot;</code> 来指明，这个函数是 <code>C</code> 过来的。</p>
<p>否则会异常退出：<code>undefined reference to &#39;hello()&#39; collect2.exe: error: ld returned 1 exit status</code>。</p>
<p><strong>重点之二，</strong> 在 <code>CLion</code> 中，仅仅在 <code>CMakeLists.txt</code> 中声明怎样链接，怎样找动态链接库是不够的，还需要在 <code>Run Configurations</code> 设置中去添加环境变量 <code>PATH=&#123;DLL文件所在的目录&#125;</code> 才可以，要不然就直接放到 <code>CLion</code> 已知的环境目录下。</p>
<p>否则会异常退出： <code>Process finished with exit code -1073741515 (0xC0000135)</code> 。</p>
<p>至此，小张小明合作愉快，任务完成🙂。</p>
<h1 id="2-C-导出动态链接库给C用"><a href="#2-C-导出动态链接库给C用" class="headerlink" title="2. C++导出动态链接库给C用"></a>2. C++导出动态链接库给C用</h1><p>还是小张和小明，还是 <code>C</code> 和 <code>C++</code> ，只不过这次换成了小张提供动态链接库给小明使用。</p>
<h2 id="2-1-小张的工作目录"><a href="#2-1-小张的工作目录" class="headerlink" title="2.1 小张的工作目录"></a>2.1 小张的工作目录</h2><p>小张需要提供动态链接库，他的工作目录长这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:.</span><br><span class="line">│  CMakeLists.txt</span><br><span class="line">│  library.cpp</span><br><span class="line">│  library.h</span><br><span class="line">└─cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>还是跟之前一样， <code>cmake-build-debug</code> 里面找动态链接文件，而 <code>CMakeLists.txt</code> 里面规定了怎样去编译这个程序。</p>
<p>挨着牌的来康康每个文件写了啥：</p>
<ul>
<li><code>CMakeLists.txt</code> </li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(CXX_Lib)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>) <span class="comment"># 设置 C++ 标准为 17</span></span><br><span class="line"><span class="keyword">add_library</span>(CXX_Lib SHARED library.cpp library.h) <span class="comment"># 规定了依赖哪些文件去产生动态链接文件，以及动态链接文件类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>library.h</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CXX_LIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CXX_LIB_LIBRARY_H</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="comment">// 声明下面这个函数，是要按照 C 语言的标准去导出的，不要改名啦~</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//CXX_LIB_LIBRARY_H</span></span></span><br></pre></td></tr></table></figure>
<p>这里的不同在于，直接在动态链接库的头文件中声明了 <code>extern &quot;C&quot;</code> 而不是在用到动态链接文件的地方。</p>
<ul>
<li><code>library.cpp</code> </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;library.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经历和小明一样的编译过程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake.exe --build .\cmake-build-debug --target CXX_Lib -- -j 6</span><br></pre></td></tr></table></figure>
<p>然后在 <code>cmake-build-debug</code> 目录下找到 <code>libCXX_Lib.dll</code> 文件，然后丢给小明，然后小张去喝牛奶🥛了。</p>
<h2 id="2-2-小明的工作目录"><a href="#2-2-小明的工作目录" class="headerlink" title="2.2 小明的工作目录"></a>2.2 小明的工作目录</h2><p>小明拿到小张的动态链接文件后，直接放到工作目录下，然后他的工作目录就长这样了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:.</span><br><span class="line">|   CMakeLists.txt</span><br><span class="line">|   libCXX_Lib.dll</span><br><span class="line">|   library.h</span><br><span class="line">|   main.c</span><br><span class="line">\---cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>其中的 <code>libCXX_Lib.dll</code> 就是小张那取过来的。</p>
<ul>
<li>一样的流程，首先使用 <code>CMakeLists.txt</code> 导入到项目中</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(C_Exe C)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(.) <span class="comment"># 从哪里找链接文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(C_Exe main.c library.h)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(C_Exe libCXX_Lib.dll) <span class="comment"># 使用这个动态链接库</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后声明头文件 <code>library.h</code> </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CXX_LIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CXX_LIB_LIBRARY_H</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//CXX_LIB_LIBRARY_H</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>最后使用 <code>main.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;library.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hello(); <span class="comment">// &gt;: Hello, World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然小明这里没有了 <code>extern &quot;C&quot;</code> 的注意事项，但是仍然需要在 <code>CLion</code> 的 <code>Run Configurations</code> 里面配置 <code>PATH=&#123;DLL文件所在的目录&#125;</code> 才能使用，否则还是报 <code>Process finished with exit code -1073741515 (0xC0000135)</code>。</p>
<p>好了，小明终于可以去休息了，我也去休息一下🍗🍖🥩~~~</p>
<hr>
<p>写完后突然想起来，我和师兄为啥不统一一下语言呢？🤔省时省力还省得这两天折腾来折腾去。</p>
<p>不过想想，有了这个经验，以后可以专门给 <code>Java</code> 、<code>Python</code> 等程序写动态链接库，也未尝不是件好事。</p>
<p>真是让人恍然大明白！😮</p>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>CMake</tag>
        <tag>DLL</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Commit Message规范参考</title>
    <url>/2020/10/03/Git-commit-message%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<p>磨刀不误砍柴工，整完规范再打工。</p>
<a id="more"></a>
<p>规范的 <code>Git commit</code> 标准能方便大家的交流和协作，以及方便对版本进行<strong>回顾</strong>和<strong>发布</strong>。 这里主要参考来自 <code>angular</code> 的 <code>git commit</code> 日志作为基本规范。</p>
<h1 id="1-日志基本规范"><a href="#1-日志基本规范" class="headerlink" title="1. 日志基本规范"></a>1. 日志基本规范</h1><p><code>&lt;type&gt;(&lt;scope&gt;) : &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;</code></p>
<p>说明如下：</p>
<ul>
<li><p><code>type</code> ：表示提交的类型，比如是修复了 <code>bug</code> 还是新增功（漏）能（洞），可选的列表如下：</p>
<ul>
<li><code>feat</code> ： 新增功能</li>
<li><code>fix</code> ： 修复问题</li>
<li><code>docs</code> ：修改文档，例如 <code>README</code>，<code>CHANGELOG</code>，<code>CONTRIBUTE</code> 等</li>
<li><code>style</code> ：格式化程序，例如修改空格、缩进，不改变程序逻辑</li>
<li><code>refactor</code> ：代码重构，但没有新功能，也没有修复问题</li>
<li><code>perf</code> ：优化，例如提升性能，优化体验</li>
<li><code>test</code> ：测试用例</li>
<li><code>chore</code> ：改变构建流程，例如增加依赖库、工具等</li>
<li><code>revert</code> ：回到上一个版本</li>
</ul>
</li>
<li><p><code>scope</code> ：可选内容，表示修改范围</p>
</li>
<li><code>subject</code> ：标题，描述主要变更内容，<strong>50</strong>字符以内</li>
<li><code>body</code> ：主体内容，更详细的说明，<strong>72</strong>字符以内，需要包括：<ul>
<li>为什么修改？</li>
<li>如何解决？</li>
<li>是否存在副作用？风险？</li>
</ul>
</li>
<li><code>footer</code> ：如果有的话，可以链接到一个 <code>issue</code> 或者相关文档或程序</li>
</ul>
<h1 id="2-分支规范"><a href="#2-分支规范" class="headerlink" title="2. 分支规范"></a>2. 分支规范</h1><p><strong>基本原则：</strong><code>master</code> 要设置为保护分支，不直接在 <code>master</code> 上进行代码修改和提交。</p>
<p>对于一般的 <code>feature</code> 更新和 <code>bugfix</code> ，都要从 <code>master</code> 分支上 <code>checkout</code> 下来一个开发分支进行操作，完成之后再合并回 <code>master</code> 上，并且打上 <code>tag</code> 标签，最后删除开发分支。</p>
<p>需要注意的是，分支命名规则有：</p>
<ol>
<li>分支版本命名规则：<code>分支类型_分支发布时间_分支功能</code></li>
<li>分支类型包括：<code>feature</code> ，<code>bugfix</code> ，<code>refactor</code> 三种类型</li>
<li>时间使用 <code>yyyyMMdd</code> 格式，不足补零</li>
<li>下划线命名法</li>
</ol>
<p>对于标签的管理，要使用 <code>3</code> 个数来表示，例如：<code>v1.2.3</code> ，有如下规范：</p>
<pre><code>1. 新功能添加使用第 `2` 位版本号，`bug` 修复使用第 `3` 位
 2. 例如：`v1.2.3-alpha-1`，`v-1.2.3-beta-1` 等
</code></pre><h1 id="3-工作流程示例"><a href="#3-工作流程示例" class="headerlink" title="3. 工作流程示例"></a>3. 工作流程示例</h1><ol>
<li><p>创建一个 <code>feature</code> 或者 <code>bugfix</code> 分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b feature_20201003_helloworld</span><br><span class="line">git checkout -b bugfix_20201003_store_key</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交代码到本地 <code>Git</code> 仓库，并填写规范的 <code>Git Commit Message</code> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add *</span><br><span class="line">git commit -m <span class="string">&quot;feat: 新增helloworld。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将代码同步到远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin feature_20201003_helloworld</span><br></pre></td></tr></table></figure>
</li>
<li><p>打上 <code>tag</code> 并同步</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag v0.0.1</span><br><span class="line">git push origin v0.0.1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>emmmm，还是多实践比较好，记是记不住😑……</p>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>开发规范</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Group Task 3 | Speaking Is More Important</title>
    <url>/2020/10/07/Group-task-3-Speaking-is-more-important/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="啊偶，密码不大对" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">哦吼？需要密码才能看~🤔</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="1d43703d9b3d9978a5880f7c4b20fd62b3026bf8385b56d6a917aceefa7a78cf">f09366631cbbc7d465e403bed5c067c10b79d1451227a60a2ac8ed210a516d7ddbc1a6e66ab174bddaf5cde66df72a994642066f9d045e4807595af0cc5083afa11661a8a757cfef6e54db4b4079d8233939f27c35a5e88f871de4d848e8b5cc037c8223c3aeb7081ce8e457745f1ce85e74b16ee1740199cdcf0883fc378025ef9de7fd599ab5ce93cb450b9c4c1b5f2ba6e42fbf91af68567f000d0e50f143bbdf06347e3f5cac77d15a6f8e1f38b16bcdd48f866894f96087f81d15825225f823d45f0c329e0cfe3b9730a30d1c3ce9b4aa3099e660386d829dbb2b4d9e55f37dc90a87a62d16c496203a6f5cff6a905fdaf20896ee40fcf1a1732f0b9c8f14770a920d3e9b6e3f4d4792cedfbeb392e55c716faa2a01d0a70fd0c38f0cfb6ce305573a3d9ec813c75e6accd2c53c3fd2124be60b2d4c20ccd711dfe8ef0aa86cef90e437c2e0e49437b301ff0ca40f16e428922f928143642fd2e0c70306152f24dc9c071a8b3511cda064f0fc122c064185d251bad5455e2aca7b22a4bf0232652fa9936be2a4acec9d5954466ca3df19de2e368802503ec82233f5bc3341125b70ba1e64a83bf75fdcd239a9e661864307cc839cb2d15833d2f95c37330523a8223c890ecb7f3fdaf5c3226e53c18c5c0c43db2b0443560dbe4c4b7466db9a00824d3ffd4497fbcfc3aa70e0e0cbeb3cc5289ebdd277a23c7e5d960e834c7b24335eeab32751c54e0369f7dc690968705ecd87f031a4424670812fed832558a3ed5ab4d6cf2ff100b8f9c96e30449dd964da1a58a6fa03ab05ec800e6cd8c744dce1c200ec257e1b8a7e87bc37b15b6a774493994e9b94b32bdf05e468de7d5d8a9c6be7aeef17ad6c70269f055dc37dcf5181c477b7c00e64c7624e5d4a80f81428a503a4c1a6138df9904de89c3c5a4878a35354f8337668a0ce18e741e5f5b5f9c2c3f3ce4c7db3d99a4f39cf5bc3087bc93e95365d8d14cbe38c599666a0bfe40df20ba928e2a87bcbd88a7c3f507c01638acb8ff811b97307ea79fa7a267c116a518ae847a69af5b985e59d1550515fb3efca029d36f7d00a29262507e4f67ab8b6ee19ad5d9eed6b2d5e23c29050e87c80a6d9d28a6fdda50e40c8dbfdf58b3709e4795ee8ad53b802c3d3dddd7f704eb594dcaa5e485a524ddd780e317b12e2ce7a040476cc6ef439f608d101b99038b1975b9cca2e75c9d2003b7295c0421b1c23c93db16a9d3350b74dff9e37b0a92e63ab5509f4dd4125d191de7d16739b9689cfa2b3b1ef4ea69ea1513221fb78043608c57b7aadf59d4385711c0e44992917f29a57a0a336dce97aef2141a9e5823e7e3eb9bbcc723da0d1ac2c566cc3bc4572b32c010593ab549cc727cfe4c2296b82ee66d768bd5c5560ccd9e2f179b46d769542ca87b59513b713f48e87871bf406869cea3b31f6c1a700d4f319180ab20a73125e5f7ab87864da0a68802c393fc362808daa497c3e8cec080b0bd55361c3cf6739a9ee6ddb7761656ce267ae437e5d0853731c5ee3fc18b0350deac8c2d899ede35ab5bf3bcb96c89c5a23ffd2044bf4e1e037d3188c4129f608f5890c6f1c144bd35c7714c01730169050f7ed78dfe816ab7a30f4939ab89fa8b863bb1e6ca3fc3b6245d9ee0879f016654479173fde7740763e98b0dd28b2e426cb207144b275ccddc1f327b7c9564d7988c1c41aaba203a003cbfdca23c9bfc8d13a83aa5b136493e75eff2e1053ee76c9cf0dc12bae16b150e19bbc04c5216d27522fc2c96b2d363b660b3cf52b5e4937098103be85f7158dde2e40c1eaee76462df95bd649d77555a51ebb544fd011c21984d1f4c6da6dd9c741d7ab0aea4f29bc534a1acc89192af328d4e79210184cd402e7bc40e8e5d5291bafe4d08904fe31885fe78a775d9753b89c50fae393e3d449a00b1dcfeb355fe50302ee61c89864cc0ee23988a17d1ef80d61e423e0b05da73b188b6a7f3b80156944e9428add4b0da1f9d79f0b791a58344a81cf4d2ff8dce2398ec3d9e7fa661e0803f2bbc9404757aa0382e76d0caca7e59f21e45e206201984ef41fa5e3e9538381b21b9c919c405891b3c451cd15a623a6b2a4f3f7f3164c67c89655ce53ffbc39d3301508de3f15f344a078bfcaf3231af795b0ebcd44da4f3c29e428ae32ec4a3b1bbd98620b587fa18ce39b52e16512b795868a72f869a1fefd061f13f07508c2bb713e0f1bd007ce3b3beedcab71a9614e2ca0f302b9f88339f63ab9e8647796bc19e339438a7268fd546cff8ea38941fcc049d45af396bc53df965f9cac0081fb0583ecda92bd1a69f23f6c697b6694262975c3a7bd6a323961b62291871a66815b4a75a9f1735740f44fb76f1db9216954e0fe623feb3f3d65f344191bb26e4aeac42fac4b8ddda7a8612cbd3903ca5302517680bae049f1c3bdbf6076c44b012c8f43760a990d984eb52d06ba42e1dcca2debf9e30f8307f44339b4d738f92dee3a275b9ebf8eb5c1f53afd66046848dd36efabd0b8001d78410b078387f4d0ba53a4e272f5fda32561a8e90b55108338829726881d6d988fd926784d8b95dce920b8bfff14d7dccc40bd8cb3db8f97b3466c50810fa5142448d87168595b92d128acee6e554f9e877d7561da96bc9ae87d88bd02b760aff8312a349241ff6b0039ba96ab383f8c022dc00dc691e2611c3b7309731bb397b5f80d69ad2b77219946801273cb42e7bfc7da31ef92f27e50fd2ea34a7bb61bf050e6dfcc1563defa270691f27aa9c70079d7dc03a67c1836755a56deec2028738c420761b2da21b59122f60e6979265bfa82aa311bd22c5189f42a4d300494fe95a296c8a0efd866a6f836d583f3722adeaf8af3cbcba47ede341676aca12b19bd49787fae17be442b5d75ad0f084896385b2e78c309b99c1f53b706db4d69d2267f7dd63e65f1591707b86dd2a16f6afbb761868f128cb1999ee114e8efbf75a10b6884af050cd5f19f2039d1fa678a7e28cadbaf60940c2cd54f18ccce5361bc65cb9873e02988f171b7e13872ab0474111078a8e34e3c7a17bbefc4c368f910660b6569881c4ae493293d116ca5897281ba3c27c5e61818fdc53e18a05604d39eaaa1f2e3326a4fdc09d95cd384d1c787d615a821bc8591c8e7ec0e9f260f40b7ca158da5edff41736dd0225932f120b7224e9d55e9d2a721b10bbd3c2c3a4ce98592af1539e3cc375392acace66b6c4ef64870c4734f53b6aee19d903f342f63fbd69e70975a52462af459a8ee5094b4f030eaf33ee47b14a2e901c3ed6bef0ed8dd6154db9eb0daa46e2f8991f26f5ac1302f9a307590102ce56817cc444e5db6e1ee7c5f47fa5e5fcdfa5606c2d55adcaa586294f1bcdc8be5ce7ff7aab47e1addbcc9f781a4abb66da63a8a3b8bbc2399b59761b7876f9d21d5ad81241dda01e0782c5bc83d70ecbab1ce1dc3acffedeeccedd4f039b8dde95af542af176aac49573e2e3c088fc67d18105f88d5fe5152737660a83a1ea1d807cc1d9b31a4cb5871c66d18f64b6ad27e62efd85907a318d79d5d0357d2d081ab29e02424f6e5438a90dbe2a33d8eeeed560462317cd3f295105e3d4d3a2a6ffcad490c265e5d2762f42f4b9c1112c2a1658d31e1547802337a83a7e5dce0d1db40f0580421608a3d6cbb33b853cd4d3a0f7bb4b955fe43a656bd421458b099472e1b7827100ef1ca97d8023647b51dd7f69946a9c901b873fc4bb860d2eecb7900e70d166425937b37c9f6d57249bda7d89a1add36c0b3984f212123386dd610cf0965dbd36b5a32b069b6592041c78734ef1ae20d06ffc2c47466952983b4cb0ea73c4e3a8b60d5f266edbc02353a7ab1a1e398b4bd68dc63a2468403cc9dc820d2e5afc6d313d392aa35318a2cf1ffc4c3652226b48cd9271ce76bb812dec891d9b814dd6d782ac83fb85b099ac412f1bf32bdfad81550b8615cc5dc995c15fa5fa009445d68d0c07316a1a67642446cb4e9017393f776ab03f35bf8bbf2287b378fddc78932dd5e29a2b2493a037e95f8333556d90b77bf852e3cd58ebac223c61d37aad57856b055d8d28fd83ace109bdc588e86ac754c7374036ccc1c04d2ba2b5fbcd739657238f136fe9c35e636a71280676bed6f18716afc0d142a47ec0ad2f86b798e8ee88cf502077d1fa3d7dc22804e192c755eb2cf5d90aeafd1065b12e34c193e66b7b5c5eade794e8c407518dc377d2397358be79773e76b7e0b34f08f60e3a7ae989cd16b0b54af84d8ed5e280c881d7e9910ad0c1d9c5101c67f386ddd7457b2360c5017b77fc0b81d871150a5537330713534537f3b48feaebffe52769bd99badbe15c47efa2d262a2db38d6ebaaf359e050a68f023533174f719da94939f407b45cb80d476d9a3efb9051759a81dcf98536284ba286f428f21d436b8ce1996ab7ae2498382b2623f21433be10d25c6f29ee9cc216398e5317705d0d49c0f68f0cb8efcebda9309e5093759ae9633b487b9d43908caa3988f1772200a5723d215e1c3fcc565c8c3c0cbc050ba2419ca3171ff8fb8bc7b2b2e04c450138c04062e69f93ff04eb67103de142617997fe69ffc053728d03399f8eff6c65dc8f804144c11a27ee2a0c6bf913324c722638cf68b6cf411a80d128aed37c9875db41a2a91588505bc1374f3fbac1380082b37117638a76232d155332cff96cbb3c0fe70b8856bc7e2b0abfa5ec7b12ebb5c63e45cda9465bc456c4378d069024e961549d2d2f375a48d1d777130429326887c5442d9afd908796f9321200d266e0d8b2f4eb1317e22e5679140e90371d6c60c5cc0c6fe41e8292454686f3170d8f12c17c6a5ed0e7fdf570b26c5f7cd9e28a58f40536ef98953ba5a9daf1ac22cd01212a77b33ba268b7ed8356a98f5f93f44b2d0f5cbbe99e4ee798cc43cd0a79b78276389f6b699467ae91a2305811cc586b59fec10d3f705a0d4cf20ecad57573ec8ecbc9324fbc7cda19ac2be2dd0690e10d02640f9704f6256351bdb353c115bf6307b6dda8143ba591288db12de8f17f5e9591227b4791bd225ce006fe1e48289ed908c5d3bbdbfc4526bc5c13cb600a17dcdd03b3fa0e9525efb8d8308c4e1052240e0665a8da62bb0d72adc831bade5c1cb240ea38c9f3b9d3a6c6a37c7ba1ab122c66a5beda47deb00fd451cbb7f75554a52542be2ec2c88533972e5ecaae992ab8f36b2772c78a44d09882f24d3358e40da141e1f1fde3160f854a7f865d81f5b4906c96a6aabd604126c9724ac88d1b48cc7417e18c7ef5f7653a75000ee2f2a677c852d9ae37816a159d751af4d8a303fd88f909c356269516ac3a331528fc7e4188304648b054fc9be1c4dbde31c7de12d3190541683c0b41c427af268aa7cbdb6dd7bf5bf07403df8b1abd162f8ad09dbeffefcfccaf4c94aec82129f012ae11addbaaa0512a7f98622031dba06d991d7276583bd859dea6c88026a9ac370873dc3c5289b405a4a3b3594d0bc4dd4b4379b3a089dc354fa23f107d1932f6ca29f1b8eb312cc55faa91ff550f1913ee553a56a3173236f97436822c8c4aea98a7ad49a720973d4789cb76f17f11d3a064328fa6dd808d071261d605236bfb10e25a078ea6d20ed43530f3e8e9c2d1a82daa7ebbd3f1b94b9ea19a13c4c27c1c94c42cff513a7e8f37371fa18de0957b744cd73f93292d081a39daa00e8d3f27b4e0290167e39aa09758df22377ec4c6bcba4159bc242c955945011a0c1ba0b40c8276db171fb8e41e40406ec6ead6d38d01cf523b84a8374bad333f497ae1974341c0f0e780aca3b483fc4041962dc7530e47f20bb076c18d521ac6fae43dfe35fd0dec1836e22a701ae097a4b3307b83e2c1cf6dbaed4d17afc7d89d71a8e2c72ae26ee19cb8d0dbaccd05e75a54a4cf254778d1e664bb8795079b57ed14552e7c17022cb429bac8ec8ba158fa8dac9770156895463f6ec7447db0e604802c93b6877aa6e8888caf7bcfc22289436e4f88f0bde9a7c37970b0161aa2525fc1fa5c02c9e0a326bba5e21a71b3fe5ba8e1e86b00d5eab930adce5f4a0ff67d1a4d3c52392f3cbcf927c0edff5d9d0ee20ba8d0fdefb53f9cc56f88d4026f383dc18e6fd63c7af1d596b92b95cdff326ea0987204b572d33c95c37c0c0993d7aab92d16ed61e45cfef5aaa4be9355cbd028191c1b153ec0df3545ac09cff1c5f5b9d091c3610fb6f97c4f06bbb18fc62ed8b7cc04c23aa0649bfc3a4c563855d7f15d276c7f7087b7e43e601276e23a23a293bd98816d1b68adbd9fcea37f74541bed289d63740a303f73da65dc1275ffc4654b5c9dffdafa761bfebcffe42e7e54dc83bbf8ad6a848511ac3403dab8d38fb5d2ce25428d466670d345197cca99b194cbaaf083e94a9a33419df00a08bbad3378cfdb2d5024bfd1cea444d0a0f2d96296082e0954eb657c6e1d193eaee59bd50bf91630a90ad097f861d0ab7bef088bc16130de83cd3d1aed997daae56630c8619ab648f43183bdea7689ce6c9a814c724572f142c939a3479217c1085210392ab5604af1892c42c83aa1feae998891f9ac06e60c43308d32926661f49c19bf4bec75ee649dcf6780741a444ca98203f942e158e6517e82ae3eba669e1744f4261e54ecbb2dd5e192f039ce1af811fcb5b87ac83a732d454c5b3db5cf9cb3bfc5451283b0d1a1a1d6c8ecc2f0e58e82759bf85f951d4c46d6ea34d9aaf4c8ef4512df98075c88c5f1c55c7aa8f2d03710c09fc87212c330423ba87de1164c8860dcabe78bd3ed7a9d82672e28da72c128950f86bbd56be08f7dfa5054074ec8b7107990acbbb8049313e2b380160a8c8d8c05198a9200a99db3f4d751848f4922886bd70491c86d274bdbd6cab94084b44f752bd680e0b9deb4fe4ab5d8b65d1a0b569fdec070c096f6480acd3aa29e2264f29557e6bac2fed64e62f6b1adc1c823bf1ddf828bc25a9d9a4ae0174bdf39b51a3ebd8265a65ed80edd4bdd87777a6a23484700364ca195e77bd0bd2ef1ddc0c5254d55b45766ab98b542880e957c53f6b96fa59eb5a9be597895a4fd72c415281348217d18df7bacd48b0b1e760e0c4df60a12c3432a1f818efc6c66baafc5d84c8617a5c28ac5fb81b9426cff6962350552fcfad906c2d85fb7fb2226a6cc26f039b96295a5aed994b713492f5b1bfbcbd1e3cb903db8e6528cc95abe9c133dd445692c5f23b383230873d4014dfc68c9ae5a9af7e2c5886a47610dc3747dfb6744ff8151e295194f06b41cb09c3afcd0f93fabf58dbd816bd406c06892960a7fae2f2c1db9c86f9d1533baa787b83baf137874ae699e0701aa384040d6bf0fd294cc0a470c3fd616929c39370481f479a664005a69f4aff32dc8aba413a8f5391bd9efab10f3dd87916f9aeaa4d4f116c4a3baa6d27ea5facc124a62430a490ce1b5c</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>Private</tag>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <url>/2020/08/28/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1. 准备环境"></a>1. 准备环境</h1><p>所需软件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.js	-&gt; v12.18.3</span><br><span class="line">npm     -&gt; 6.14.6 </span><br><span class="line">Git     -&gt; 2.16.2.windows1</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 <code>Hexo</code></h1><p>首先在自己的磁盘里创建一个目录，例如 <code>C:\Blog</code>，打开命令行工具，然后输入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:                      <span class="comment"># 进入C盘</span></span><br><span class="line"><span class="built_in">cd</span> Blog	                <span class="comment"># 进入 Blog 文件夹</span></span><br><span class="line">npm install -g hexo-cli <span class="comment"># 安装 hexo 这个过程超级漫长，建议去喝一杯咖啡，如果没有修改 npm 的镜像源的话</span></span><br></pre></td></tr></table></figure><br>假如上面的过程没有出现什么幺蛾子，没有报错，也没有警告，那么恭喜，现在来到了 <code>hexo</code> 软件。</p>
<h1 id="3-在-Github-创建-Pages"><a href="#3-在-Github-创建-Pages" class="headerlink" title="3. 在 Github 创建 Pages"></a>3. 在 <code>Github</code> 创建 <code>Pages</code></h1><p>这里有两种创建的方法，可以创建<strong>仓库</strong>归属的 <code>Pages</code>，也可以创建<strong>帐户</strong>归属的 <code>Pages</code>，这里创建的是后者（账户归属），不为别的，因为好看。两者的区别主要在：</p>
<ol>
<li>仓库归属的最终访问路径为：<code>https://github.com/&#123;username&#125;/&#123;repo&#125;</code></li>
<li>账户归属的最终访问路径为：<code>https://&#123;username&#125;.github.io/</code></li>
</ol>
<p>在创建过程中，需要把仓库名称设置为自己的账户名称这样才能实现上面的第二种。</p>
<h1 id="4-创建本地博客并本地预览"><a href="#4-创建本地博客并本地预览" class="headerlink" title="4. 创建本地博客并本地预览"></a>4. 创建本地博客并本地预览</h1><p>回到第 2 步的命令行中，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog     <span class="comment"># 初始化博客仓库</span></span><br><span class="line">hexo new HelloHexo <span class="comment"># 创建第一篇文章</span></span><br></pre></td></tr></table></figure>
<p>然后可以到目录 <code>C:\Blog\source\_post</code> 目录下看到 <code>HelloHexo.md</code> 文件，找一个称手的 <code>MarkDown</code> 编辑器，通过修改该文件内容来完成内容编写。</p>
<p>修改完成后，继续回到上面的命令行中，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean    <span class="comment"># （可选）清除缓存，方便后面重新生成 hexo c</span></span><br><span class="line">hexo generate <span class="comment"># 生成相关页面，也可以 hexo g</span></span><br><span class="line">hexo server   <span class="comment"># 启动本地预览，也可以 hexo s</span></span><br></pre></td></tr></table></figure>
<p>然后就可以在 <code>http://localhost:4000/</code> 中看到自己的博客预览了，如果成功看到，那么恭喜，可以再喝一杯咖啡了😝。</p>
<h1 id="5-2020年9月1日更新"><a href="#5-2020年9月1日更新" class="headerlink" title="5.  2020年9月1日更新"></a>5.  2020年9月1日更新</h1><p>当使用 <code>hexo s</code> 来启动本地服务，然后进去网页报类似于 <code>(node:23020) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency</code> 错误时，需要将 <code>node</code> 从 <code>14</code> 版本降为 <code>12</code> 版本。</p>
<p>如果在 <code>git bash</code> 中使用 <code>Ctrl + c</code> 快捷键终止服务未响应的话，需要更新 <code>git</code> 。</p>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT主题配置</title>
    <url>/2020/08/30/Hexo-NexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>首先安装</strong></p>
<p>首先安装好 <code>NexT</code> ，从 <a href="https://github.com/theme-next/hexo-theme-next">这里</a> 下载克隆最新的 <code>NexT</code> ，然后把内容解压到 <code>Hexo</code> 安装目录下的 <code>theses</code> 文件夹中，并且重命名为 <code>next</code>。</p>
<a id="more"></a>
<p><strong>配置文件</strong> </p>
<p>完成上面步骤后，在 <code>Hexo</code> 的安装目录下，有一个文件夹 <code>themes</code> 该文件夹中存放着主题文件，在 <code>themes\next\</code> 文件夹下有配置文件 <code>_config.yml</code> （以后称为 <strong>NexT 配置文件</strong>） ，在该文件中，内容可以说是巨大无比，抽取关键内容，可以对以下内容进行配置。NexT配置<a href="https://theme-next.org/docs/theme-settings/">详细文档</a></p>
<h2 id="1-网站图标"><a href="#1-网站图标" class="headerlink" title="1 网站图标"></a>1 网站图标</h2><p>找到自己中意的图标后，先调整尺寸，一般都是 <code>16 * 16</code> 用作网站小图标，<code>32 * 32</code> 及以上用作站点图标（用户头像类似），然后保存在 <code>&#123;Hexo_home&#125;\source\image\</code> 下。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/icon-16.png</span>            <span class="comment"># 小图标</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/icon-32.png</span>           <span class="comment"># 中等图标</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/icon-32.png</span> <span class="comment"># 适配 Apple 设备</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/icon.svg</span>   <span class="comment"># safari 浏览器的小图标，需要用 svg 格式</span></span><br></pre></td></tr></table></figure>
<h2 id="2-版权声明"><a href="#2-版权声明" class="headerlink" title="2. 版权声明"></a>2. 版权声明</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="3-主题样式以及暗黑模式"><a href="#3-主题样式以及暗黑模式" class="headerlink" title="3. 主题样式以及暗黑模式"></a>3. 主题样式以及暗黑模式</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模式</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暗黑模式</span></span><br><span class="line"><span class="attr">darkmode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="4-菜单栏"><a href="#4-菜单栏" class="headerlink" title="4. 菜单栏"></a>4. 菜单栏</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否打开某一个菜单栏，打开的话只需要将前面的 # 注释去掉</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment"># sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment"># commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否显示图标、是否显示角标</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="5-社交链接"><a href="#5-社交链接" class="headerlink" title="5. 社交链接"></a>5. 社交链接</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据需要进行添加就好了</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/hxz1998</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">huxz1998@163.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br></pre></td></tr></table></figure>
<h2 id="6-阅读更多（Read-More）"><a href="#6-阅读更多（Read-More）" class="headerlink" title="6. 阅读更多（Read More）"></a>6. 阅读更多（Read More）</h2><p>这个功能类似于 <strong>全文展开</strong> ，第一步打开 <strong>阅读全文</strong> 按钮：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">read_more_btn:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>第二步，在某一个文章中，添加 <code>&lt;!-- more --&gt;</code> 标签，该标签前面的内容将会被展示，后面的内容将会被折叠。</p>
<h2 id="7-字数统计，阅读时长-amp-本地查询"><a href="#7-字数统计，阅读时长-amp-本地查询" class="headerlink" title="7. 字数统计，阅读时长 &amp; 本地查询"></a>7. 字数统计，阅读时长 &amp; 本地查询</h2><p>参考 <strong>配置Hexo</strong> 一文。</p>
<h2 id="8-访客统计"><a href="#8-访客统计" class="headerlink" title="8. 访客统计"></a>8. 访客统计</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span>      </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>              <span class="comment"># 首先打开该插件</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>      <span class="comment"># 是否显示访客</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span> <span class="comment"># 该数字前面的图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>         <span class="comment"># 总浏览量</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span>     <span class="comment"># 还是图标~</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>          <span class="comment"># 文章浏览量</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span>      <span class="comment"># 仍旧是图标</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu分区方案</title>
    <url>/2020/09/30/Ubuntu%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>在安装了五次系统之后……</p>
<a id="more"></a>
<p>自打到了实验室，我已经安装了五次 <code>Ubuntu20.04</code> 系统，事情是这样的：</p>
<p><strong>第一次安装：</strong>老师发给一台电脑，台式机，一块 <code>1T</code> 机械硬盘，一条 <code>8G</code> 内存，这对我来说已经够用了，毕竟不跑深度学习也不打游戏，装个 <code>Linux</code> 写写程序，做做项目绰绰有余，于是乎拿了U盘就装上了 <code>Ubuntu20.04</code>，装好之后，安装用的一堆IDE，编译器，从 <code>Github</code> 上 <code>clone</code> 到本地程序，跑了个样例程序，通过，心里一阵开心。可是这都是假的，安装好之后重新启动，竟然卡在了启动界面，第一次安装失败告终……</p>
<p><strong>第二次安装：</strong>鉴于上次安装失败，这次在每个步骤上都谨小慎微（其实没啥要注意的，因为都是傻瓜式安装），这次，安装好后之后就直接重启系统，发现没有问题，安装软件过程也没有问题，再次开心😊。可是好景不长，由于创建 <code>Python</code> 虚拟环境报错，决定重新尝试安装 <code>Python3</code> 来解决问题，重新安装肯定要先卸载呀，结果问题就出在这里，卸载之后就……直接把 <code>Linux</code> 的桌面环境给删掉了😭，（）于是就有了第三次的故事……</p>
<p><strong>第三次安装：</strong>鉴于前两次失败的故事，这次更加地谨小慎微，下载，安装，配置，拉取代码……终于，功夫不负有心人，这次安装很成功，成功在机器上安装好了 <code>Ubuntu20.04</code> ，运行了第一个加密算法，并得到了结果，美滋滋😋。不过，天总有不测风云，所以才有了下次的故事……</p>
<p><strong>第四次安装：</strong>今天下午来到实验室，研讨结束后，老师突然来了句：前几天买了固态硬盘（<code>1T</code>）和内存条（<code>8G</code>），加上去把机器升下级。我……（内心是快乐还是崩溃，老师不知道，我也不知道），开心是因为硬件得到了升级呀，更好的工作环境当然开心，崩溃是因为，又双叒叕要重装系统了……本想着有了前三次的教训，这次可以很顺利安装过来，不过，呜呜呜：这次又在硬盘分区上翻车了😣。</p>
<p>这不，立刻回来对硬盘分区进行研究，康康到底该咋分区，然后给自己也写个记录，以免以后一直去查别人的教程。</p>
<ol>
<li>首先是 <code>boot</code> 引导分区：<code>10G (10240)</code> ，<code>ext4</code> 格式，空间起始位置，主分区</li>
<li>然后是根目录 <code>/</code> ：<code>300G (307200)</code> ，<code>ext4</code> 格式，空间起始位置，逻辑分区</li>
<li>紧接着是交换空间 <code>swap</code> ：<code>32G(32768)</code> ，<code>swap</code> 格式，空间起始位置，逻辑分区</li>
<li>最后是家目录 <code>home</code>：<code>1000 - 10 - 300 - 32 = 658G (673792)</code>，<code>ext4</code> 格式，空间起始位置，逻辑分区</li>
</ol>
<p>说到这里，突发奇想地，对于 <code>Ubuntu20.04</code> 而言，是不是有个省时省力的方法：索性<strong>不分区</strong>，全部根目录 <code>/</code> ，这样更省力，省的这会儿满了，那会儿不够用了，省去了解决杂七杂八问题的时间，去看点书不好么？😐</p>
<p>等待第五次安装的验证结果。</p>
<hr>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World！</title>
    <url>/2020/08/27/hello-world/</url>
    <content><![CDATA[<h2 id="震惊！-○´･д･-ﾉ"><a href="#震惊！-○´･д･-ﾉ" class="headerlink" title="震惊！(○´･д･)ﾉ"></a>震惊！(○´･д･)ﾉ</h2><p>咩哈哈哈哈哈，可可可可算弄好了。<br>明天见~我的宝宝理。</p>
<h2 id="晚安安"><a href="#晚安安" class="headerlink" title="晚安安"></a>晚安安</h2><blockquote>
<p>晚安啦，我亲爱的宝贝~爱你爱你。</p>
</blockquote>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>初出茅庐</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全领域国际会议</title>
    <url>/2020/09/19/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E5%9B%BD%E9%99%85%E4%BC%9A%E8%AE%AE/</url>
    <content><![CDATA[<p>了解一下信息安全领域的国际顶会</p>
<a id="more"></a>
<h1 id="四大信息安全国际会议"><a href="#四大信息安全国际会议" class="headerlink" title="四大信息安全国际会议"></a>四大信息安全国际会议</h1><h2 id="1-CCS（Computer-and-Communications-Security）"><a href="#1-CCS（Computer-and-Communications-Security）" class="headerlink" title="1. CCS（Computer and Communications Security）"></a>1. <a href="https://dl.acm.org/conference/ccs">CCS（Computer and Communications Security）</a></h2><h3 id="通用信息"><a href="#通用信息" class="headerlink" title="通用信息"></a>通用信息</h3><p>名称：计算机与通信安全</p>
<p>日期：1993-今</p>
<p>位置：美国</p>
<h3 id="论文提交信息"><a href="#论文提交信息" class="headerlink" title="论文提交信息"></a>论文提交信息</h3><p>摘要：</p>
<p>全文：</p>
<p>演示方式：</p>
<h3 id="组织机构信息"><a href="#组织机构信息" class="headerlink" title="组织机构信息"></a>组织机构信息</h3><p>赞助者：SIGSAC</p>
<p>组织者：ACM</p>
<p>组织委员会：Committee on Publication Ethics (COPE)</p>
<p>学术委员会：ACM</p>
<p>其他委员会：</p>
<h3 id="参与者信息"><a href="#参与者信息" class="headerlink" title="参与者信息"></a>参与者信息</h3><p>参与者数量：</p>
<p>参会者要求：</p>
<p>会议VIP</p>
<p>其他成员</p>
<h3 id="会议程序"><a href="#会议程序" class="headerlink" title="会议程序"></a>会议程序</h3><p>会议手册：</p>
<p>邀请：</p>
<blockquote>
<p>  We invite submissions from academia, government, and industry presenting novel research on all theoretical and practical aspects of computer security, as well as case studies and implementation experiences.</p>
</blockquote>
<p>征文：<a href="https://www.acm.org/publications/authors/calls-for-papers">https://www.acm.org/publications/authors/calls-for-papers</a></p>
<hr>
<h2 id="2-USENIX-Security"><a href="#2-USENIX-Security" class="headerlink" title="2. USENIX Security"></a>2. <a href="https://www.usenix.org/conference/usenixsecurity21">USENIX Security</a></h2><h3 id="通用信息-1"><a href="#通用信息-1" class="headerlink" title="通用信息"></a>通用信息</h3><p>名称：USENIX 安全</p>
<p>日期：1975-今</p>
<p>位置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">USENIX Association</span><br><span class="line">2560 Ninth St., Suite 215</span><br><span class="line">Berkeley, CA 94710</span><br><span class="line">USA</span><br></pre></td></tr></table></figure>
<h3 id="论文提交信息-1"><a href="#论文提交信息-1" class="headerlink" title="论文提交信息"></a>论文提交信息</h3><p>摘要：</p>
<p>全文：</p>
<p>演示方式：</p>
<h3 id="组织机构信息-1"><a href="#组织机构信息-1" class="headerlink" title="组织机构信息"></a>组织机构信息</h3><p>赞助者：USENIX</p>
<p>组织者：Michael Bailey, Rachel Greenstadt</p>
<p>组织委员会：Yousra Aafer, <em>University of Waterloo</em>, Ruba Abu-Salma, <em>University College London and Inria</em> …</p>
<p>学术委员会：</p>
<p>其他委员会：Srdjan Capkun, <em>ETH Zurich</em></p>
<h3 id="参与者信息-1"><a href="#参与者信息-1" class="headerlink" title="参与者信息"></a>参与者信息</h3><p>参与者数量：</p>
<p>参会者要求：</p>
<p>会议VIP：</p>
<p>其他成员</p>
<h3 id="会议程序-1"><a href="#会议程序-1" class="headerlink" title="会议程序"></a>会议程序</h3><p>会议手册：<a href="https://www.usenix.org/conferences/coc">https://www.usenix.org/conferences/coc</a></p>
<p>邀请：</p>
<blockquote>
<p>Invited talks and panel discussions will be held in parallel with the refereed paper sessions. Please submit topic suggestions and talk and panel proposals via email to <a href="mailto:sec21it@usenix.org">sec21it@usenix.org</a> by Thursday, February 4, 2021.</p>
</blockquote>
<p>征文：<a href="https://www.usenix.org/conference/usenixsecurity21/call-for-papers">https://www.usenix.org/conference/usenixsecurity21/call-for-papers</a></p>
<hr>
<h2 id="3-IEEE-Symposium-on-Security-and-Privacy"><a href="#3-IEEE-Symposium-on-Security-and-Privacy" class="headerlink" title="3. IEEE Symposium on Security and Privacy"></a>3. <a href="http://www.ieee-security.org/TC/SP-Index.html">IEEE Symposium on Security and Privacy</a></h2><h3 id="通用信息-2"><a href="#通用信息-2" class="headerlink" title="通用信息"></a>通用信息</h3><p>名称：IEEE 安全隐私研讨会</p>
<p>日期：1980-今</p>
<p>位置：美国</p>
<h3 id="论文提交信息-2"><a href="#论文提交信息-2" class="headerlink" title="论文提交信息"></a>论文提交信息</h3><p>摘要：</p>
<p>全文：</p>
<p>演示方式：</p>
<h3 id="组织机构信息-2"><a href="#组织机构信息-2" class="headerlink" title="组织机构信息"></a>组织机构信息</h3><p>赞助者：IEEE Computer Security Technical Committee on Security and Privacy</p>
<p>组织者：2019：Sean Peisert</p>
<p>组织委员会：IEEE Computer Security Technical Committee</p>
<p>学术委员会：Technical Committee on Security and Privacy</p>
<p>其他委员会：</p>
<h3 id="参与者信息-2"><a href="#参与者信息-2" class="headerlink" title="参与者信息"></a>参与者信息</h3><p>参与者数量：</p>
<p>参会者要求：</p>
<p>会议VIP：</p>
<p>其他成员</p>
<h3 id="会议程序-2"><a href="#会议程序-2" class="headerlink" title="会议程序"></a>会议程序</h3><p>会议手册：<a href="https://www.usenix.org/conferences/coc">https://www.usenix.org/conferences/coc</a></p>
<p>邀请：</p>
<p>征文：<a href="https://www.ieee-security.org/TC/SP2021/cfpapers.html">https://www.ieee-security.org/TC/SP2021/cfpapers.html</a></p>
<hr>
<h2 id="4-NDSS"><a href="#4-NDSS" class="headerlink" title="4. NDSS"></a>4. <a href="https://www.ndss-symposium.org/">NDSS</a></h2><h3 id="通用信息-3"><a href="#通用信息-3" class="headerlink" title="通用信息"></a>通用信息</h3><p>名称：Network and Distributed System Security Symposium</p>
<p>日期：1992-今</p>
<p>位置：美国</p>
<h3 id="论文提交信息-3"><a href="#论文提交信息-3" class="headerlink" title="论文提交信息"></a>论文提交信息</h3><p>摘要：<a href="https://www.ndss-symposium.org/ndss2020/templates/">https://www.ndss-symposium.org/ndss2020/templates/</a></p>
<p>全文：</p>
<p>演示方式：</p>
<h3 id="组织机构信息-3"><a href="#组织机构信息-3" class="headerlink" title="组织机构信息"></a>组织机构信息</h3><p>赞助者：NFS、Google、Intel、Internet Society、CISCO</p>
<p>组织者：NDSS 2020</p>
<p>组织委员会：Trent Jaeger, co-chair, <em>Pennsylvania State University</em></p>
<p>学术委员会：NDSS 2020 Program Committee</p>
<p>其他委员会：</p>
<h3 id="参与者信息-3"><a href="#参与者信息-3" class="headerlink" title="参与者信息"></a>参与者信息</h3><p>参与者数量：</p>
<p>参会者要求：</p>
<ol>
<li><p>University Researchers and Educators</p>
</li>
<li><p>Chief Technology and Privacy Officers</p>
</li>
<li><p>Security Analysts and System Administrators</p>
</li>
<li><p>Operations and Security Managers</p>
</li>
</ol>
<p><em>Attendance is limited to foster maximum exchange of information and ideas.</em></p>
<p>会议VIP：</p>
<p>其他成员</p>
<h3 id="会议程序-3"><a href="#会议程序-3" class="headerlink" title="会议程序"></a>会议程序</h3><p>会议手册：<a href="https://www.ndss-symposium.org/ndss2020/coronavirus-covid-19-update/">https://www.ndss-symposium.org/ndss2020/coronavirus-covid-19-update/</a></p>
<p>邀请：</p>
<p>征文：<a href="https://www.ndss-symposium.org/ndss-2021/call-for-papers/">https://www.ndss-symposium.org/ndss-2021/call-for-papers/</a></p>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>初出茅庐</tag>
        <tag>信息安全会议</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Hexo</title>
    <url>/2020/08/29/%E9%85%8D%E7%BD%AEHexo/</url>
    <content><![CDATA[<p><strong>配置文件 <code>_config.yml</code></strong></p>
<p>在 <code>Hexo</code> 的安装目录下， 有一个文件 <code>_config.yml</code> （以后称为 <strong>Hexo 配置文件</strong> ，在该文件中，可以对以以下内容进行配置。</p>
<a id="more"></a>
<h2 id="1-站点信息"><a href="#1-站点信息" class="headerlink" title="1. 站点信息"></a>1. 站点信息</h2><p>在这个配置中，可以对站点的基本信息进行修改。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">CHerrY</span> <span class="comment"># 站点标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;门前大桥下，C#C++，快来快来数一数，Java煮青蛙~&#x27;</span>  <span class="comment"># 子标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;算法分析，基础架构&#x27;</span> <span class="comment"># 站点描述，用来展示给访客的</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&#x27;算法分析分享，技术博客，LeetCode，个人博客&#x27;</span>  <span class="comment"># 给搜索引擎用的</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">CHerrY</span>  <span class="comment"># 作者信息，博客中的作者默认署名</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment"># 语言信息，Hexo支持多种语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span>    <span class="comment"># 时区配置，默认使用计算机的当地时间</span></span><br></pre></td></tr></table></figure>
<h2 id="2-URL-配置"><a href="#2-URL-配置" class="headerlink" title="2. URL 配置"></a>2. <code>URL</code> 配置</h2><p>该配置将会影响到博客内 <strong>图片</strong> 的访问、外链等信息。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://hxz1998.github.io/</span> <span class="comment"># 站点域名，如果有的话可以设置自己的域名</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span>                         <span class="comment"># 配置根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>  <span class="comment"># URL 组成格式</span></span><br></pre></td></tr></table></figure>
<h2 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3. 扩展"></a>3. 扩展</h2><p>对 <code>Hexo</code> 进行扩展所用到的配置，每一个插件需要去查看插件自己的说明文档。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插件扩展到： https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment"># 主题扩展到： https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span> <span class="comment"># 设置主题为 next</span></span><br></pre></td></tr></table></figure>
<h2 id="4-部署分发"><a href="#4-部署分发" class="headerlink" title="4. 部署分发"></a>4. 部署分发</h2><p>将博客部署到哪里，就配置这里~</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span> <span class="comment"># 部署服务类型，在这里我使用的是 Github 和 Gitee，因此选 git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># 仓库名称“们”，之所以使用“们”，是因为可以同步多个git仓库</span></span><br><span class="line">    <span class="attr">gitee:</span> <span class="string">https://gitee.com/hxz1998/hxz1998.git</span>  </span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://github.com/hxz1998/hxz1998.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h2 id="5-字数统计，阅读时长（可选）"><a href="#5-字数统计，阅读时长（可选）" class="headerlink" title="5. 字数统计，阅读时长（可选）"></a>5. 字数统计，阅读时长（可选）</h2><p><strong>下面内容在Hexo配置文件中并不存在，别害怕，自己添加就完事儿了。</strong> 这里主要对博客的一些额外的功能进行配置，需要结合 <code>hexo-symbols-count-time</code> 插件进行使用。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>     <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure>
<h3 id="5-1-hexo-symbols-count-time-安装"><a href="#5-1-hexo-symbols-count-time-安装" class="headerlink" title="5.1 hexo-symbols-count-time 安装"></a>5.1 <code>hexo-symbols-count-time</code> 安装</h3><p>打开心心念念的命令行终端，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time	<span class="comment"># 过程很快，没有多大</span></span><br></pre></td></tr></table></figure>
<p>等待安装完成，<strong>重新生成</strong> 、启动 <code>Hexo</code> 即可查看效果。</p>
<h3 id="5-2-配置-NexT-中的内容"><a href="#5-2-配置-NexT-中的内容" class="headerlink" title="5.2 配置 NexT 中的内容"></a>5.2 配置 <code>NexT</code> 中的内容</h3><p>将 <code>symbol_count_time</code> 启用：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>   <span class="comment"># 分隔的元数据</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>   <span class="comment"># 文章字数 </span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span> <span class="comment"># 总字数</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>                 <span class="comment"># 平均字长（字符以字为单位）</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>               <span class="comment"># 每分钟字数</span></span><br></pre></td></tr></table></figure>
<p>上面的数字都可以修改，当然，还可以参考来自 <a href="https://github.com/theme-next/hexo-symbols-count-time">官方</a> 指导：</p>
<blockquote>
<p><strong>注意对于中国用户：</strong>因为在有关中国语文平均字长<code>~1.5</code>，如果你在大多数情况下，写中国的职位（不含混合英文），建议设置<code>awl</code>到<code>2</code>和<code>wpm</code>到<code>300</code>。<br>但是，如果您通常将自己的帖子与英语混在一起，则<code>awl</code>to <code>4</code>和<code>wpm</code>to <code>275</code>会很好。</p>
</blockquote>
<h2 id="6-搜索（可选）"><a href="#6-搜索（可选）" class="headerlink" title="6. 搜索（可选）"></a>6. 搜索（可选）</h2><p>同样的，这是一个在 <strong>Hexo配置文件中并不存在的内容，需要额外添加。</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span> </span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span>  <span class="comment"># 将搜索索引放到哪里</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span>       <span class="comment"># 搜索字段</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span>     <span class="comment"># 是否检索内容</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span>      <span class="comment"># 生成格式</span></span><br></pre></td></tr></table></figure>
<p> 配置完之后，仍然需要额外配置 <code>NexT</code> 主题的配置文件 <code>next\_config.xml</code> 才可以生效。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span>	</span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>	</span><br></pre></td></tr></table></figure>
<h3 id="6-1-hexo-generator-searchdb-安装"><a href="#6-1-hexo-generator-searchdb-安装" class="headerlink" title="6.1 hexo-generator-searchdb 安装"></a>6.1 <code>hexo-generator-searchdb</code> 安装</h3><p>继续使用上面心心念念的终端，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>等待安装完成，<strong>重新生成</strong> 、再次启动 <code>Hexo</code> 即可查看效果。</p>
<h2 id="7-标签云"><a href="#7-标签云" class="headerlink" title="7. 标签云"></a>7. 标签云</h2><p>首先要建立存放标签的页面，打开喜欢用的命令行终端，并输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>然后就可以在 <code>Hexo_home\source\</code> 文件夹下看到有 <code>tags\index.md</code> 文件，对该文件进行修改成如下内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 标签云              # 展示标题</span><br><span class="line">date: 2020-08-27 23:03:38 # 创建时间，一般不需要改</span><br><span class="line">type: &quot;tags&quot;              # <span class="xml"><span class="tag">&lt;<span class="name">---</span> 这个才是添加的重点！</span></span></span><br></pre></td></tr></table></figure>
<p>然后刷新就可以在主页面菜单中看到 <strong>标签</strong> 这一栏了。</p>
<h2 id="8-分类"><a href="#8-分类" class="headerlink" title="8. 分类"></a>8. 分类</h2><p>对于分类页面的建立，和上面 <strong>第七条</strong> 一样。</p>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>ZUC算法了解</title>
    <url>/2020/09/22/ZUC%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>ZUC算法是一个<strong>面向字的流加密</strong>算法。它使用一个<strong>128</strong>位的初始密钥 <code>key</code> 和一个<strong>128</strong>位的初始向量 <code>iv</code> 来作为输入，可以输出若干个<strong>32</strong>位字的密钥流，也就就是说每<strong>32</strong>位字在这里称为一个密钥字。这样产生的密钥流可以用于加密和解密。</p>
<a id="more"></a>
<blockquote>
<p>  以下内容参考自 ZUC 标准文档</p>
</blockquote>
<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在ZUC算法中，有两个执行阶段，分别是<strong>初始化阶段</strong>和<strong>工作阶段</strong>。在初始化阶段中， <code>key</code> 和 <code>iv</code> 被初始化完成。在工作阶段中，每个<strong>时钟脉冲</strong>都能产生一个<strong>32位字</strong>的密钥流输出。</p>
<h1 id="2-符号与约定"><a href="#2-符号与约定" class="headerlink" title="2. 符号与约定"></a>2. 符号与约定</h1><h2 id="2-1-数制表示"><a href="#2-1-数制表示" class="headerlink" title="2.1 数制表示"></a>2.1 数制表示</h2><p>下文使用<strong>十进制</strong>、<strong>十六进制</strong>、<strong>二进制</strong>进行表示例如：</p>
<script type="math/tex; mode=display">
\begin{align*}
a &= 123456 \space\space\space\space十进制表示法\\\\ 
&= 0x1E240\space\space\space\space 十六进制表示\\\\
&= 00011110001001000000_2 二进制表示
\end{align*}</script><h2 id="2-2-比特序"><a href="#2-2-比特序" class="headerlink" title="2.2 比特序"></a>2.2 比特序</h2><p>在下文中，所有数据变量的左侧是高有效位（字节），右侧为低有效位（字节）。例如：$a = 100110101100110010100100_2$，那么它的最高有效位是$1$（最左侧的），最低有效位是$0$（最右侧的）。</p>
<h2 id="2-3-符号约定"><a href="#2-3-符号约定" class="headerlink" title="2.3 符号约定"></a>2.3 符号约定</h2><script type="math/tex; mode=display">
\begin{align*}
+ &| 两个整数相加\\\\
ab &| 两个整数相乘 \\\\
= &| 赋值\\\\
mod &| 模二加\\\\
\oplus &| 异或运算\\\\
\boxplus &| 模 2^32 加法运算\\\\
a||b &| 将字符串 a 和 b 串联 \\\\
a_H &| a 的高**16**为\\\\
a_L &| a 的低**16**位\\\\
a <<<_n k &| 循环左移\\\\
a>>1 &| 右移\\\\
(a_1, a_2, ..., a_n,)\to(b_1, b_2, ... b_n) &| 将向量 a_i 挨个赋值给 b_i\\\\
\end{align*}</script><h1 id="3-算法描述"><a href="#3-算法描述" class="headerlink" title="3. 算法描述"></a>3. 算法描述</h1><h2 id="3-1-算法结构"><a href="#3-1-算法结构" class="headerlink" title="3.1 算法结构"></a>3.1 算法结构</h2><p>如下图所示，<code>ZUC</code> 算法有三层结构，第一层是一个16级线性反馈移位寄存器（LSFR，linear feedback shift register）。中间是一个比特重组层（BR，bit-reorganization）。最下层是一个非线性函数$F$。</p>
<p><img data-src="https://s1.ax1x.com/2020/09/22/wOM9TU.jpg" alt="ZUC算法结构"></p>
<h2 id="3-2-线性反馈移位寄存器（LSFR）"><a href="#3-2-线性反馈移位寄存器（LSFR）" class="headerlink" title="3.2 线性反馈移位寄存器（LSFR）"></a>3.2 线性反馈移位寄存器（LSFR）</h2><p>线性反馈移位寄存器（LSFR）有<strong>16</strong>个<strong>31</strong>比特的单元（$s_0, s_1, … , s_{15}, s_i\in {1, 2, 3, … , 2^{31}-1}$），它的运行有两种模式：初始化模式和工作模式。</p>
<p>在<strong>初始化阶段</strong>，LFSR读入一个<strong>31</strong>位的输入字 <code>u</code> ，它通过从非线性函数 <code>F</code> 的<strong>32</strong>位输出 <code>W</code> 中删除最右边的位来获得，例如：<code>u = W &gt;&gt; 1</code>，具体的工作方式如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
& \space LSFRWithInitializationMode(u): \\\\
& 1. \qquad v = 2^{15}s_{15}+2^{17}s_{13}+2^{21}s_{10}+2^{20}s_{4}+(1 + 2^8)s_0\space mod(2^{31}-1) \\\\
& 2. \qquad s_{16} = (v + u)\space mod(2^{31} - 1) \\\\
& 3. \qquad if s_{16}=0, then\space set\space s_{16}=2^{31} - 1 \\\\
& 4. \qquad(s_1, s_2, ... s_{16})\to(s_0, s_1, ... , s_{15})\\\\
\end{align*}</script><p>在<strong>工作阶段</strong>，LSFR不会接收任何输入，并且按照下面方式工作：</p>
<script type="math/tex; mode=display">
\begin{align*}
&LFSRWithWorkMode() \\\\
&1. \qquad s_{16} = 2^{15}s_{15}+2^{17}s_{13}+2^{21}s_{10}+2^{20}s_{4}+(1+2^8)s_0\space mod(2^{31} - 1)\\\\
&2. \qquad if\space s_{16}=0,\space then \space set \space s_{16}=2^{31} - 1\\\\
&3. \qquad(s_1, s_2, ... s_{16})\to(s_0, s_1, ... , s_{15})\\\\
\end{align*}</script><p><strong>Tips：</strong>在 <code>LFSRWithInitializationMode</code> 函数中的 Step.1 ，可以使用如下操作来实现：</p>
<script type="math/tex; mode=display">
v=(s_{15}<<<_{31}15)+(s_{13}<<<_{31}17)+(s_{10}<<<_{31}21)+(s_{4}<<<_{31}20)+(s_{0}<<<_{31}8)+s_{0}\space mod(2^{31}-1)</script><p>当然，可以类比着对 <code>LFSRWithWordMode()</code> 中的 Step.1 进行实现。</p>
<h2 id="3-3-比特重组（BR）"><a href="#3-3-比特重组（BR）" class="headerlink" title="3.3 比特重组（BR）"></a>3.3 比特重组（BR）</h2><p>中间层是一个比特重组算法。它从<strong>LFSR</strong>中提取出来 <code>128</code> 比特，然后组成 <code>4</code> 个 <code>32</code> 位的字，前三个字是提供给底层非线性 <code>F</code> 函数使用的，最后一个字用来生成密钥流。重组后的 $X_0, X_1, X_2, X_3$，如下所示：</p>
<script type="math/tex; mode=display">
\begin{align*}
&Bitreorganization() \\\\
&1. \qquad X_0 = s_{15H}||s_{14L}\\\\
&2. \qquad X_1 = s_{11L}||s_{9H}\\\\
&3. \qquad X_2 = s_{7L}||s_{5H}\\\\
&4. \qquad X_3 = s_{2L}||s_{0H}
\end{align*}</script><p>注意：这里的 $s_i$ 是 <code>31</code> 比特的整数类型，所以 $s_{iH}$ 表示的是 $s_i$ 的 <code>30...15</code> 位而不是 <code>31...16</code> 位。</p>
<h2 id="3-4-非线性函数-F"><a href="#3-4-非线性函数-F" class="headerlink" title="3.4 非线性函数 F"></a>3.4 非线性函数 F</h2><p>非线性函数 <code>F</code> 有两个 <code>32</code> 比特的记忆单元 $R_1$ 和 $R_2$，输入为 <code>3</code> 个 <code>32</code> 比特的字：$X_0, X_1, X_2$，输出一个 <code>32</code> 比特的字 <code>W</code>。具体描述如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
&F(X_0, X_1, X_2) \\\\
&1. \qquad W = (X_0\oplus R_1)\boxplus R_2 \\\\
&2. \qquad W_1 = (R_1\boxplus X_1) \\\\
&3. \qquad W_2 = (R_2\oplus X_2) \\\\
&4. \qquad R_1 = S(L_1(W_{1L}||W_{2H})) \\\\
&5. \qquad R_2 = S(L_2(W_{2L}||W_{1H}))
\end{align*}</script><p>这里的 <code>S</code> 是一个 <code>32*32</code> 大小的 <code>S-Box</code>，而 $L_1$，$L_2$ 是线性变换。</p>
<h3 id="3-4-1-S-Box"><a href="#3-4-1-S-Box" class="headerlink" title="3.4.1 S-Box"></a>3.4.1 S-Box</h3><p><code>32*32</code>大小的 <code>S-Box</code>（<code>S</code>），其实是四个大小为 <code>8*8</code>的 <code>S-boxes</code> 并置而成，例如：$S=(S_0, S_1, S_2, S_3)$，这里的 $S_0 = S_2,S_1 = S_3$。那么 $S_0$ 和 $S_1$ 具体内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> S0[<span class="number">256</span>] = &#123;</span><br><span class="line">    <span class="number">0x3e</span>,<span class="number">0x72</span>,<span class="number">0x5b</span>,<span class="number">0x47</span>,<span class="number">0xca</span>,<span class="number">0xe0</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x04</span>,<span class="number">0xd1</span>,<span class="number">0x54</span>,<span class="number">0x98</span>,<span class="number">0x09</span>,<span class="number">0xb9</span>,<span class="number">0x6d</span>,<span class="number">0xcb</span>,</span><br><span class="line">    <span class="number">0x7b</span>,<span class="number">0x1b</span>,<span class="number">0xf9</span>,<span class="number">0x32</span>,<span class="number">0xaf</span>,<span class="number">0x9d</span>,<span class="number">0x6a</span>,<span class="number">0xa5</span>,<span class="number">0xb8</span>,<span class="number">0x2d</span>,<span class="number">0xfc</span>,<span class="number">0x1d</span>,<span class="number">0x08</span>,<span class="number">0x53</span>,<span class="number">0x03</span>,<span class="number">0x90</span>,</span><br><span class="line">    <span class="number">0x4d</span>,<span class="number">0x4e</span>,<span class="number">0x84</span>,<span class="number">0x99</span>,<span class="number">0xe4</span>,<span class="number">0xce</span>,<span class="number">0xd9</span>,<span class="number">0x91</span>,<span class="number">0xdd</span>,<span class="number">0xb6</span>,<span class="number">0x85</span>,<span class="number">0x48</span>,<span class="number">0x8b</span>,<span class="number">0x29</span>,<span class="number">0x6e</span>,<span class="number">0xac</span>,</span><br><span class="line">    <span class="number">0xcd</span>,<span class="number">0xc1</span>,<span class="number">0xf8</span>,<span class="number">0x1e</span>,<span class="number">0x73</span>,<span class="number">0x43</span>,<span class="number">0x69</span>,<span class="number">0xc6</span>,<span class="number">0xb5</span>,<span class="number">0xbd</span>,<span class="number">0xfd</span>,<span class="number">0x39</span>,<span class="number">0x63</span>,<span class="number">0x20</span>,<span class="number">0xd4</span>,<span class="number">0x38</span>,</span><br><span class="line">    <span class="number">0x76</span>,<span class="number">0x7d</span>,<span class="number">0xb2</span>,<span class="number">0xa7</span>,<span class="number">0xcf</span>,<span class="number">0xed</span>,<span class="number">0x57</span>,<span class="number">0xc5</span>,<span class="number">0xf3</span>,<span class="number">0x2c</span>,<span class="number">0xbb</span>,<span class="number">0x14</span>,<span class="number">0x21</span>,<span class="number">0x06</span>,<span class="number">0x55</span>,<span class="number">0x9b</span>,</span><br><span class="line">    <span class="number">0xe3</span>,<span class="number">0xef</span>,<span class="number">0x5e</span>,<span class="number">0x31</span>,<span class="number">0x4f</span>,<span class="number">0x7f</span>,<span class="number">0x5a</span>,<span class="number">0xa4</span>,<span class="number">0x0d</span>,<span class="number">0x82</span>,<span class="number">0x51</span>,<span class="number">0x49</span>,<span class="number">0x5f</span>,<span class="number">0xba</span>,<span class="number">0x58</span>,<span class="number">0x1c</span>,</span><br><span class="line">    <span class="number">0x4a</span>,<span class="number">0x16</span>,<span class="number">0xd5</span>,<span class="number">0x17</span>,<span class="number">0xa8</span>,<span class="number">0x92</span>,<span class="number">0x24</span>,<span class="number">0x1f</span>,<span class="number">0x8c</span>,<span class="number">0xff</span>,<span class="number">0xd8</span>,<span class="number">0xae</span>,<span class="number">0x2e</span>,<span class="number">0x01</span>,<span class="number">0xd3</span>,<span class="number">0xad</span>,</span><br><span class="line">    <span class="number">0x3b</span>,<span class="number">0x4b</span>,<span class="number">0xda</span>,<span class="number">0x46</span>,<span class="number">0xeb</span>,<span class="number">0xc9</span>,<span class="number">0xde</span>,<span class="number">0x9a</span>,<span class="number">0x8f</span>,<span class="number">0x87</span>,<span class="number">0xd7</span>,<span class="number">0x3a</span>,<span class="number">0x80</span>,<span class="number">0x6f</span>,<span class="number">0x2f</span>,<span class="number">0xc8</span>,</span><br><span class="line">    <span class="number">0xb1</span>,<span class="number">0xb4</span>,<span class="number">0x37</span>,<span class="number">0xf7</span>,<span class="number">0x0a</span>,<span class="number">0x22</span>,<span class="number">0x13</span>,<span class="number">0x28</span>,<span class="number">0x7c</span>,<span class="number">0xcc</span>,<span class="number">0x3c</span>,<span class="number">0x89</span>,<span class="number">0xc7</span>,<span class="number">0xc3</span>,<span class="number">0x96</span>,<span class="number">0x56</span>,</span><br><span class="line">    <span class="number">0x07</span>,<span class="number">0xbf</span>,<span class="number">0x7e</span>,<span class="number">0xf0</span>,<span class="number">0x0b</span>,<span class="number">0x2b</span>,<span class="number">0x97</span>,<span class="number">0x52</span>,<span class="number">0x35</span>,<span class="number">0x41</span>,<span class="number">0x79</span>,<span class="number">0x61</span>,<span class="number">0xa6</span>,<span class="number">0x4c</span>,<span class="number">0x10</span>,<span class="number">0xfe</span>,</span><br><span class="line">    <span class="number">0xbc</span>,<span class="number">0x26</span>,<span class="number">0x95</span>,<span class="number">0x88</span>,<span class="number">0x8a</span>,<span class="number">0xb0</span>,<span class="number">0xa3</span>,<span class="number">0xfb</span>,<span class="number">0xc0</span>,<span class="number">0x18</span>,<span class="number">0x94</span>,<span class="number">0xf2</span>,<span class="number">0xe1</span>,<span class="number">0xe5</span>,<span class="number">0xe9</span>,<span class="number">0x5d</span>,</span><br><span class="line">    <span class="number">0xd0</span>,<span class="number">0xdc</span>,<span class="number">0x11</span>,<span class="number">0x66</span>,<span class="number">0x64</span>,<span class="number">0x5c</span>,<span class="number">0xec</span>,<span class="number">0x59</span>,<span class="number">0x42</span>,<span class="number">0x75</span>,<span class="number">0x12</span>,<span class="number">0xf5</span>,<span class="number">0x74</span>,<span class="number">0x9c</span>,<span class="number">0xaa</span>,<span class="number">0x23</span>,</span><br><span class="line">    <span class="number">0x0e</span>,<span class="number">0x86</span>,<span class="number">0xab</span>,<span class="number">0xbe</span>,<span class="number">0x2a</span>,<span class="number">0x02</span>,<span class="number">0xe7</span>,<span class="number">0x67</span>,<span class="number">0xe6</span>,<span class="number">0x44</span>,<span class="number">0xa2</span>,<span class="number">0x6c</span>,<span class="number">0xc2</span>,<span class="number">0x93</span>,<span class="number">0x9f</span>,<span class="number">0xf1</span>,</span><br><span class="line">    <span class="number">0xf6</span>,<span class="number">0xfa</span>,<span class="number">0x36</span>,<span class="number">0xd2</span>,<span class="number">0x50</span>,<span class="number">0x68</span>,<span class="number">0x9e</span>,<span class="number">0x62</span>,<span class="number">0x71</span>,<span class="number">0x15</span>,<span class="number">0x3d</span>,<span class="number">0xd6</span>,<span class="number">0x40</span>,<span class="number">0xc4</span>,<span class="number">0xe2</span>,<span class="number">0x0f</span>,</span><br><span class="line">    <span class="number">0x8e</span>,<span class="number">0x83</span>,<span class="number">0x77</span>,<span class="number">0x6b</span>,<span class="number">0x25</span>,<span class="number">0x05</span>,<span class="number">0x3f</span>,<span class="number">0x0c</span>,<span class="number">0x30</span>,<span class="number">0xea</span>,<span class="number">0x70</span>,<span class="number">0xb7</span>,<span class="number">0xa1</span>,<span class="number">0xe8</span>,<span class="number">0xa9</span>,<span class="number">0x65</span>,</span><br><span class="line">    <span class="number">0x8d</span>,<span class="number">0x27</span>,<span class="number">0x1a</span>,<span class="number">0xdb</span>,<span class="number">0x81</span>,<span class="number">0xb3</span>,<span class="number">0xa0</span>,<span class="number">0xf4</span>,<span class="number">0x45</span>,<span class="number">0x7a</span>,<span class="number">0x19</span>,<span class="number">0xdf</span>,<span class="number">0xee</span>,<span class="number">0x78</span>,<span class="number">0x34</span>,<span class="number">0x60</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> S1[<span class="number">256</span>] = &#123;</span><br><span class="line">    <span class="number">0x55</span>,<span class="number">0xc2</span>,<span class="number">0x63</span>,<span class="number">0x71</span>,<span class="number">0x3b</span>,<span class="number">0xc8</span>,<span class="number">0x47</span>,<span class="number">0x86</span>,<span class="number">0x9f</span>,<span class="number">0x3c</span>,<span class="number">0xda</span>,<span class="number">0x5b</span>,<span class="number">0x29</span>,<span class="number">0xaa</span>,<span class="number">0xfd</span>,<span class="number">0x77</span>,</span><br><span class="line">    <span class="number">0x8c</span>,<span class="number">0xc5</span>,<span class="number">0x94</span>,<span class="number">0x0c</span>,<span class="number">0xa6</span>,<span class="number">0x1a</span>,<span class="number">0x13</span>,<span class="number">0x00</span>,<span class="number">0xe3</span>,<span class="number">0xa8</span>,<span class="number">0x16</span>,<span class="number">0x72</span>,<span class="number">0x40</span>,<span class="number">0xf9</span>,<span class="number">0xf8</span>,<span class="number">0x42</span>,</span><br><span class="line">    <span class="number">0x44</span>,<span class="number">0x26</span>,<span class="number">0x68</span>,<span class="number">0x96</span>,<span class="number">0x81</span>,<span class="number">0xd9</span>,<span class="number">0x45</span>,<span class="number">0x3e</span>,<span class="number">0x10</span>,<span class="number">0x76</span>,<span class="number">0xc6</span>,<span class="number">0xa7</span>,<span class="number">0x8b</span>,<span class="number">0x39</span>,<span class="number">0x43</span>,<span class="number">0xe1</span>,</span><br><span class="line">    <span class="number">0x3a</span>,<span class="number">0xb5</span>,<span class="number">0x56</span>,<span class="number">0x2a</span>,<span class="number">0xc0</span>,<span class="number">0x6d</span>,<span class="number">0xb3</span>,<span class="number">0x05</span>,<span class="number">0x22</span>,<span class="number">0x66</span>,<span class="number">0xbf</span>,<span class="number">0xdc</span>,<span class="number">0x0b</span>,<span class="number">0xfa</span>,<span class="number">0x62</span>,<span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0xdd</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x06</span>,<span class="number">0x36</span>,<span class="number">0xc9</span>,<span class="number">0xc1</span>,<span class="number">0xcf</span>,<span class="number">0xf6</span>,<span class="number">0x27</span>,<span class="number">0x52</span>,<span class="number">0xbb</span>,<span class="number">0x69</span>,<span class="number">0xf5</span>,<span class="number">0xd4</span>,<span class="number">0x87</span>,</span><br><span class="line">    <span class="number">0x7f</span>,<span class="number">0x84</span>,<span class="number">0x4c</span>,<span class="number">0xd2</span>,<span class="number">0x9c</span>,<span class="number">0x57</span>,<span class="number">0xa4</span>,<span class="number">0xbc</span>,<span class="number">0x4f</span>,<span class="number">0x9a</span>,<span class="number">0xdf</span>,<span class="number">0xfe</span>,<span class="number">0xd6</span>,<span class="number">0x8d</span>,<span class="number">0x7a</span>,<span class="number">0xeb</span>,</span><br><span class="line">    <span class="number">0x2b</span>,<span class="number">0x53</span>,<span class="number">0xd8</span>,<span class="number">0x5c</span>,<span class="number">0xa1</span>,<span class="number">0x14</span>,<span class="number">0x17</span>,<span class="number">0xfb</span>,<span class="number">0x23</span>,<span class="number">0xd5</span>,<span class="number">0x7d</span>,<span class="number">0x30</span>,<span class="number">0x67</span>,<span class="number">0x73</span>,<span class="number">0x08</span>,<span class="number">0x09</span>,</span><br><span class="line">    <span class="number">0xee</span>,<span class="number">0xb7</span>,<span class="number">0x70</span>,<span class="number">0x3f</span>,<span class="number">0x61</span>,<span class="number">0xb2</span>,<span class="number">0x19</span>,<span class="number">0x8e</span>,<span class="number">0x4e</span>,<span class="number">0xe5</span>,<span class="number">0x4b</span>,<span class="number">0x93</span>,<span class="number">0x8f</span>,<span class="number">0x5d</span>,<span class="number">0xdb</span>,<span class="number">0xa9</span>,</span><br><span class="line">    <span class="number">0xad</span>,<span class="number">0xf1</span>,<span class="number">0xae</span>,<span class="number">0x2e</span>,<span class="number">0xcb</span>,<span class="number">0x0d</span>,<span class="number">0xfc</span>,<span class="number">0xf4</span>,<span class="number">0x2d</span>,<span class="number">0x46</span>,<span class="number">0x6e</span>,<span class="number">0x1d</span>,<span class="number">0x97</span>,<span class="number">0xe8</span>,<span class="number">0xd1</span>,<span class="number">0xe9</span>,</span><br><span class="line">    <span class="number">0x4d</span>,<span class="number">0x37</span>,<span class="number">0xa5</span>,<span class="number">0x75</span>,<span class="number">0x5e</span>,<span class="number">0x83</span>,<span class="number">0x9e</span>,<span class="number">0xab</span>,<span class="number">0x82</span>,<span class="number">0x9d</span>,<span class="number">0xb9</span>,<span class="number">0x1c</span>,<span class="number">0xe0</span>,<span class="number">0xcd</span>,<span class="number">0x49</span>,<span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0x01</span>,<span class="number">0xb6</span>,<span class="number">0xbd</span>,<span class="number">0x58</span>,<span class="number">0x24</span>,<span class="number">0xa2</span>,<span class="number">0x5f</span>,<span class="number">0x38</span>,<span class="number">0x78</span>,<span class="number">0x99</span>,<span class="number">0x15</span>,<span class="number">0x90</span>,<span class="number">0x50</span>,<span class="number">0xb8</span>,<span class="number">0x95</span>,<span class="number">0xe4</span>,</span><br><span class="line">    <span class="number">0xd0</span>,<span class="number">0x91</span>,<span class="number">0xc7</span>,<span class="number">0xce</span>,<span class="number">0xed</span>,<span class="number">0x0f</span>,<span class="number">0xb4</span>,<span class="number">0x6f</span>,<span class="number">0xa0</span>,<span class="number">0xcc</span>,<span class="number">0xf0</span>,<span class="number">0x02</span>,<span class="number">0x4a</span>,<span class="number">0x79</span>,<span class="number">0xc3</span>,<span class="number">0xde</span>,</span><br><span class="line">    <span class="number">0xa3</span>,<span class="number">0xef</span>,<span class="number">0xea</span>,<span class="number">0x51</span>,<span class="number">0xe6</span>,<span class="number">0x6b</span>,<span class="number">0x18</span>,<span class="number">0xec</span>,<span class="number">0x1b</span>,<span class="number">0x2c</span>,<span class="number">0x80</span>,<span class="number">0xf7</span>,<span class="number">0x74</span>,<span class="number">0xe7</span>,<span class="number">0xff</span>,<span class="number">0x21</span>,</span><br><span class="line">    <span class="number">0x5a</span>,<span class="number">0x6a</span>,<span class="number">0x54</span>,<span class="number">0x1e</span>,<span class="number">0x41</span>,<span class="number">0x31</span>,<span class="number">0x92</span>,<span class="number">0x35</span>,<span class="number">0xc4</span>,<span class="number">0x33</span>,<span class="number">0x07</span>,<span class="number">0x0a</span>,<span class="number">0xba</span>,<span class="number">0x7e</span>,<span class="number">0x0e</span>,<span class="number">0x34</span>,</span><br><span class="line">    <span class="number">0x88</span>,<span class="number">0xb1</span>,<span class="number">0x98</span>,<span class="number">0x7c</span>,<span class="number">0xf3</span>,<span class="number">0x3d</span>,<span class="number">0x60</span>,<span class="number">0x6c</span>,<span class="number">0x7b</span>,<span class="number">0xca</span>,<span class="number">0xd3</span>,<span class="number">0x1f</span>,<span class="number">0x32</span>,<span class="number">0x65</span>,<span class="number">0x04</span>,<span class="number">0x28</span>,</span><br><span class="line">    <span class="number">0x64</span>,<span class="number">0xbe</span>,<span class="number">0x85</span>,<span class="number">0x9b</span>,<span class="number">0x2f</span>,<span class="number">0x59</span>,<span class="number">0x8a</span>,<span class="number">0xd7</span>,<span class="number">0xb0</span>,<span class="number">0x25</span>,<span class="number">0xac</span>,<span class="number">0xaf</span>,<span class="number">0x12</span>,<span class="number">0x03</span>,<span class="number">0xe2</span>,<span class="number">0xf2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-2-线性变换"><a href="#3-4-2-线性变换" class="headerlink" title="3.4.2 线性变换"></a>3.4.2 线性变换</h3><p>对于 $L_1$ 和 $L_2$ 线性变换而言，都是将 <code>32</code> 位的字转换成另一个 <code>32</code> 位的字，具体转换如下：</p>
<script type="math/tex; mode=display">
L_1(X)=X\oplus (X<<<_{32}2)\oplus (X<<<_{32}10)\oplus (X<<<_{32}18) \oplus(X<<<_{32}24)\\\\
L_2(X)=X\oplus (X<<<_{32}8)\oplus (X<<<_{32}14)\oplus (X<<<_{32}22) \oplus(X<<<_{32}30)</script><h2 id="3-5-密钥装入"><a href="#3-5-密钥装入" class="headerlink" title="3.5 密钥装入"></a>3.5 密钥装入</h2><p>密钥装入过程，将会把初始密钥 <code>k(128 bits)</code> 和 <code>iv(128 bits)</code> 扩展成 <code>16</code> 个 <code>31</code> 位整数，作为 <code>LFSR</code> 的初始状态。</p>
<p>装载过程如下：</p>
<script type="math/tex; mode=display">
k = k_0||k_1||k_2||...||k_{15}</script><p>和：</p>
<script type="math/tex; mode=display">
iv=iv_0||iv_1||...||iv_{15}</script><p>这里的 $k_i$ 和 $iv_i$ 均为 <code>8</code> 位的字节，然后构造 <code>D</code>， <code>D</code> 为 <code>240</code> 比特的常量，可以按照如下方式分成 <code>16</code> 个 <code>15</code> 位的子串：</p>
<script type="math/tex; mode=display">
\begin{align*}
d_0 = 100010011010111_2, \\\\
d_1 = 010011010111100_2,\\\\
d_2 = 110001001101011_2,\\\\
d_3 = 001001101011110_2,\\\\
d_4 = 101011110001001_2,\\\\
d_5 = 011010111100010_2,\\\\
d_6 = 111000100110101_2,\\\\
d_7 = 000100110101111_2,\\\\
d_8= 100110101111000_2,\\\\
d_9 = 010111100010011_2,\\\\
d_{10} = 110101111000100_2,\\\\
d_{11} = 001101011110001_2,\\\\
\end{align*}</script><p>那么 $D=d_0||d_1||…||d_{15}$。</p>
<p>对于 $s_i$，有：$s_i = k_i||d_i||iv_i$。</p>
<h1 id="3-6-ZUC算法执行过程"><a href="#3-6-ZUC算法执行过程" class="headerlink" title="3.6 ZUC算法执行过程"></a>3.6 ZUC算法执行过程</h1><p>两个阶段：初始化阶段和工作阶段。</p>
<h2 id="3-6-1-初始化阶段"><a href="#3-6-1-初始化阶段" class="headerlink" title="3.6.1 初始化阶段"></a>3.6.1 初始化阶段</h2><p>在初始化阶段，算法将 <code>128</code> 比特的 <code>key</code> 和 <code>iv</code> 载入并处理，然后装入到 <code>LFSR</code> 中，与此同时，设置 <code>32</code> 比特的记忆单元 $R_1$ 和 $R_2$（初始化为 <code>0</code>）。然后执行下面的操作 <code>31</code> 次。</p>
<script type="math/tex; mode=display">
\begin{align*}
&1. \qquad Bitreorganization()\\\\
&2. \qquad w=F(X_0,X_1,X_2)\\\\
&3. \qquad LFSRWithInitializationMode(w>>1)\\\\
\end{align*}</script><h3 id="3-6-2-工作阶段"><a href="#3-6-2-工作阶段" class="headerlink" title="3.6.2 工作阶段"></a>3.6.2 工作阶段</h3><p>初始化完成后，算法立刻进入工作阶段。在该阶段，算法执行下面操作一次，并且丢掉 <code>F</code> 的输出 <code>W</code>：</p>
<script type="math/tex; mode=display">
\begin{align*}
&1. \qquad Bitreorganization()\\\\
&2. \qquad F(X_0,X_1,X_2) \\\\
&3. \qquad LFSRWithWorkMode()\\\\
\end{align*}</script><p>然后算法再进入密钥流产生阶段，在每次迭代时，下面操作执行一次，并输出一次 <code>32</code> 比特的字 <code>Z</code> 作为输出。</p>
<script type="math/tex; mode=display">
\begin{align*}
&1. \qquad Bitreorganization()\\\\
&2. \qquad Z=F(X_0,X_1,X_2)\oplus X_3 \\\\
&3. \qquad LFSRWithWorkMode()\\\\
\end{align*}</script><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="A-C语言实现"><a href="#A-C语言实现" class="headerlink" title="A. C语言实现"></a>A. C语言实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ZUC.h&quot;</span></span></span><br><span class="line"><span class="comment">/* ——————————————————————- */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u32;</span><br><span class="line"><span class="comment">/* ——————————————————————- */</span></span><br><span class="line"><span class="comment">/* the state registers of LFSR */</span></span><br><span class="line">u32 LFSR_S0;</span><br><span class="line">u32 LFSR_S1;</span><br><span class="line">u32 LFSR_S2;</span><br><span class="line">u32 LFSR_S3;</span><br><span class="line">u32 LFSR_S4;</span><br><span class="line">u32 LFSR_S5;</span><br><span class="line">u32 LFSR_S6;</span><br><span class="line">u32 LFSR_S7;</span><br><span class="line">u32 LFSR_S8;</span><br><span class="line">u32 LFSR_S9;</span><br><span class="line">u32 LFSR_S10;</span><br><span class="line">u32 LFSR_S11;</span><br><span class="line">u32 LFSR_S12;</span><br><span class="line">u32 LFSR_S13;</span><br><span class="line">u32 LFSR_S14;</span><br><span class="line">u32 LFSR_S15;</span><br><span class="line"><span class="comment">/* the registers of F */</span></span><br><span class="line">u32 F_R1;</span><br><span class="line">u32 F_R2;</span><br><span class="line"><span class="comment">/* the outputs of BitReorganization */</span></span><br><span class="line">u32 BRC_X0;</span><br><span class="line">u32 BRC_X1;</span><br><span class="line">u32 BRC_X2;</span><br><span class="line">u32 BRC_X3;</span><br><span class="line"><span class="comment">/* the s-boxes */</span></span><br><span class="line">u8 S0[<span class="number">256</span>] = &#123;</span><br><span class="line">        <span class="number">0x3e</span>, <span class="number">0x72</span>, <span class="number">0x5b</span>, <span class="number">0x47</span>, <span class="number">0xca</span>, <span class="number">0xe0</span>, <span class="number">0x00</span>, <span class="number">0x33</span>, <span class="number">0x04</span>, <span class="number">0xd1</span>, <span class="number">0x54</span>, <span class="number">0x98</span>, <span class="number">0x09</span>, <span class="number">0xb9</span>, <span class="number">0x6d</span>, <span class="number">0xcb</span>,</span><br><span class="line">        <span class="number">0x7b</span>, <span class="number">0x1b</span>, <span class="number">0xf9</span>, <span class="number">0x32</span>, <span class="number">0xaf</span>, <span class="number">0x9d</span>, <span class="number">0x6a</span>, <span class="number">0xa5</span>, <span class="number">0xb8</span>, <span class="number">0x2d</span>, <span class="number">0xfc</span>, <span class="number">0x1d</span>, <span class="number">0x08</span>, <span class="number">0x53</span>, <span class="number">0x03</span>, <span class="number">0x90</span>,</span><br><span class="line">        <span class="number">0x4d</span>, <span class="number">0x4e</span>, <span class="number">0x84</span>, <span class="number">0x99</span>, <span class="number">0xe4</span>, <span class="number">0xce</span>, <span class="number">0xd9</span>, <span class="number">0x91</span>, <span class="number">0xdd</span>, <span class="number">0xb6</span>, <span class="number">0x85</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x29</span>, <span class="number">0x6e</span>, <span class="number">0xac</span>,</span><br><span class="line">        <span class="number">0xcd</span>, <span class="number">0xc1</span>, <span class="number">0xf8</span>, <span class="number">0x1e</span>, <span class="number">0x73</span>, <span class="number">0x43</span>, <span class="number">0x69</span>, <span class="number">0xc6</span>, <span class="number">0xb5</span>, <span class="number">0xbd</span>, <span class="number">0xfd</span>, <span class="number">0x39</span>, <span class="number">0x63</span>, <span class="number">0x20</span>, <span class="number">0xd4</span>, <span class="number">0x38</span>,</span><br><span class="line">        <span class="number">0x76</span>, <span class="number">0x7d</span>, <span class="number">0xb2</span>, <span class="number">0xa7</span>, <span class="number">0xcf</span>, <span class="number">0xed</span>, <span class="number">0x57</span>, <span class="number">0xc5</span>, <span class="number">0xf3</span>, <span class="number">0x2c</span>, <span class="number">0xbb</span>, <span class="number">0x14</span>, <span class="number">0x21</span>, <span class="number">0x06</span>, <span class="number">0x55</span>, <span class="number">0x9b</span>,</span><br><span class="line">        <span class="number">0xe3</span>, <span class="number">0xef</span>, <span class="number">0x5e</span>, <span class="number">0x31</span>, <span class="number">0x4f</span>, <span class="number">0x7f</span>, <span class="number">0x5a</span>, <span class="number">0xa4</span>, <span class="number">0x0d</span>, <span class="number">0x82</span>, <span class="number">0x51</span>, <span class="number">0x49</span>, <span class="number">0x5f</span>, <span class="number">0xba</span>, <span class="number">0x58</span>, <span class="number">0x1c</span>,</span><br><span class="line">        <span class="number">0x4a</span>, <span class="number">0x16</span>, <span class="number">0xd5</span>, <span class="number">0x17</span>, <span class="number">0xa8</span>, <span class="number">0x92</span>, <span class="number">0x24</span>, <span class="number">0x1f</span>, <span class="number">0x8c</span>, <span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xae</span>, <span class="number">0x2e</span>, <span class="number">0x01</span>, <span class="number">0xd3</span>, <span class="number">0xad</span>,</span><br><span class="line">        <span class="number">0x3b</span>, <span class="number">0x4b</span>, <span class="number">0xda</span>, <span class="number">0x46</span>, <span class="number">0xeb</span>, <span class="number">0xc9</span>, <span class="number">0xde</span>, <span class="number">0x9a</span>, <span class="number">0x8f</span>, <span class="number">0x87</span>, <span class="number">0xd7</span>, <span class="number">0x3a</span>, <span class="number">0x80</span>, <span class="number">0x6f</span>, <span class="number">0x2f</span>, <span class="number">0xc8</span>,</span><br><span class="line">        <span class="number">0xb1</span>, <span class="number">0xb4</span>, <span class="number">0x37</span>, <span class="number">0xf7</span>, <span class="number">0x0a</span>, <span class="number">0x22</span>, <span class="number">0x13</span>, <span class="number">0x28</span>, <span class="number">0x7c</span>, <span class="number">0xcc</span>, <span class="number">0x3c</span>, <span class="number">0x89</span>, <span class="number">0xc7</span>, <span class="number">0xc3</span>, <span class="number">0x96</span>, <span class="number">0x56</span>,</span><br><span class="line">        <span class="number">0x07</span>, <span class="number">0xbf</span>, <span class="number">0x7e</span>, <span class="number">0xf0</span>, <span class="number">0x0b</span>, <span class="number">0x2b</span>, <span class="number">0x97</span>, <span class="number">0x52</span>, <span class="number">0x35</span>, <span class="number">0x41</span>, <span class="number">0x79</span>, <span class="number">0x61</span>, <span class="number">0xa6</span>, <span class="number">0x4c</span>, <span class="number">0x10</span>, <span class="number">0xfe</span>,</span><br><span class="line">        <span class="number">0xbc</span>, <span class="number">0x26</span>, <span class="number">0x95</span>, <span class="number">0x88</span>, <span class="number">0x8a</span>, <span class="number">0xb0</span>, <span class="number">0xa3</span>, <span class="number">0xfb</span>, <span class="number">0xc0</span>, <span class="number">0x18</span>, <span class="number">0x94</span>, <span class="number">0xf2</span>, <span class="number">0xe1</span>, <span class="number">0xe5</span>, <span class="number">0xe9</span>, <span class="number">0x5d</span>,</span><br><span class="line">        <span class="number">0xd0</span>, <span class="number">0xdc</span>, <span class="number">0x11</span>, <span class="number">0x66</span>, <span class="number">0x64</span>, <span class="number">0x5c</span>, <span class="number">0xec</span>, <span class="number">0x59</span>, <span class="number">0x42</span>, <span class="number">0x75</span>, <span class="number">0x12</span>, <span class="number">0xf5</span>, <span class="number">0x74</span>, <span class="number">0x9c</span>, <span class="number">0xaa</span>, <span class="number">0x23</span>,</span><br><span class="line">        <span class="number">0x0e</span>, <span class="number">0x86</span>, <span class="number">0xab</span>, <span class="number">0xbe</span>, <span class="number">0x2a</span>, <span class="number">0x02</span>, <span class="number">0xe7</span>, <span class="number">0x67</span>, <span class="number">0xe6</span>, <span class="number">0x44</span>, <span class="number">0xa2</span>, <span class="number">0x6c</span>, <span class="number">0xc2</span>, <span class="number">0x93</span>, <span class="number">0x9f</span>, <span class="number">0xf1</span>,</span><br><span class="line">        <span class="number">0xf6</span>, <span class="number">0xfa</span>, <span class="number">0x36</span>, <span class="number">0xd2</span>, <span class="number">0x50</span>, <span class="number">0x68</span>, <span class="number">0x9e</span>, <span class="number">0x62</span>, <span class="number">0x71</span>, <span class="number">0x15</span>, <span class="number">0x3d</span>, <span class="number">0xd6</span>, <span class="number">0x40</span>, <span class="number">0xc4</span>, <span class="number">0xe2</span>, <span class="number">0x0f</span>,</span><br><span class="line">        <span class="number">0x8e</span>, <span class="number">0x83</span>, <span class="number">0x77</span>, <span class="number">0x6b</span>, <span class="number">0x25</span>, <span class="number">0x05</span>, <span class="number">0x3f</span>, <span class="number">0x0c</span>, <span class="number">0x30</span>, <span class="number">0xea</span>, <span class="number">0x70</span>, <span class="number">0xb7</span>, <span class="number">0xa1</span>, <span class="number">0xe8</span>, <span class="number">0xa9</span>, <span class="number">0x65</span>,</span><br><span class="line">        <span class="number">0x8d</span>, <span class="number">0x27</span>, <span class="number">0x1a</span>, <span class="number">0xdb</span>, <span class="number">0x81</span>, <span class="number">0xb3</span>, <span class="number">0xa0</span>, <span class="number">0xf4</span>, <span class="number">0x45</span>, <span class="number">0x7a</span>, <span class="number">0x19</span>, <span class="number">0xdf</span>, <span class="number">0xee</span>, <span class="number">0x78</span>, <span class="number">0x34</span>, <span class="number">0x60</span></span><br><span class="line">&#125;;</span><br><span class="line">u8 S1[<span class="number">256</span>] = &#123;</span><br><span class="line">        <span class="number">0x55</span>, <span class="number">0xc2</span>, <span class="number">0x63</span>, <span class="number">0x71</span>, <span class="number">0x3b</span>, <span class="number">0xc8</span>, <span class="number">0x47</span>, <span class="number">0x86</span>, <span class="number">0x9f</span>, <span class="number">0x3c</span>, <span class="number">0xda</span>, <span class="number">0x5b</span>, <span class="number">0x29</span>, <span class="number">0xaa</span>, <span class="number">0xfd</span>, <span class="number">0x77</span>,</span><br><span class="line">        <span class="number">0x8c</span>, <span class="number">0xc5</span>, <span class="number">0x94</span>, <span class="number">0x0c</span>, <span class="number">0xa6</span>, <span class="number">0x1a</span>, <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0xe3</span>, <span class="number">0xa8</span>, <span class="number">0x16</span>, <span class="number">0x72</span>, <span class="number">0x40</span>, <span class="number">0xf9</span>, <span class="number">0xf8</span>, <span class="number">0x42</span>,</span><br><span class="line">        <span class="number">0x44</span>, <span class="number">0x26</span>, <span class="number">0x68</span>, <span class="number">0x96</span>, <span class="number">0x81</span>, <span class="number">0xd9</span>, <span class="number">0x45</span>, <span class="number">0x3e</span>, <span class="number">0x10</span>, <span class="number">0x76</span>, <span class="number">0xc6</span>, <span class="number">0xa7</span>, <span class="number">0x8b</span>, <span class="number">0x39</span>, <span class="number">0x43</span>, <span class="number">0xe1</span>,</span><br><span class="line">        <span class="number">0x3a</span>, <span class="number">0xb5</span>, <span class="number">0x56</span>, <span class="number">0x2a</span>, <span class="number">0xc0</span>, <span class="number">0x6d</span>, <span class="number">0xb3</span>, <span class="number">0x05</span>, <span class="number">0x22</span>, <span class="number">0x66</span>, <span class="number">0xbf</span>, <span class="number">0xdc</span>, <span class="number">0x0b</span>, <span class="number">0xfa</span>, <span class="number">0x62</span>, <span class="number">0x48</span>,</span><br><span class="line">        <span class="number">0xdd</span>, <span class="number">0x20</span>, <span class="number">0x11</span>, <span class="number">0x06</span>, <span class="number">0x36</span>, <span class="number">0xc9</span>, <span class="number">0xc1</span>, <span class="number">0xcf</span>, <span class="number">0xf6</span>, <span class="number">0x27</span>, <span class="number">0x52</span>, <span class="number">0xbb</span>, <span class="number">0x69</span>, <span class="number">0xf5</span>, <span class="number">0xd4</span>, <span class="number">0x87</span>,</span><br><span class="line">        <span class="number">0x7f</span>, <span class="number">0x84</span>, <span class="number">0x4c</span>, <span class="number">0xd2</span>, <span class="number">0x9c</span>, <span class="number">0x57</span>, <span class="number">0xa4</span>, <span class="number">0xbc</span>, <span class="number">0x4f</span>, <span class="number">0x9a</span>, <span class="number">0xdf</span>, <span class="number">0xfe</span>, <span class="number">0xd6</span>, <span class="number">0x8d</span>, <span class="number">0x7a</span>, <span class="number">0xeb</span>,</span><br><span class="line">        <span class="number">0x2b</span>, <span class="number">0x53</span>, <span class="number">0xd8</span>, <span class="number">0x5c</span>, <span class="number">0xa1</span>, <span class="number">0x14</span>, <span class="number">0x17</span>, <span class="number">0xfb</span>, <span class="number">0x23</span>, <span class="number">0xd5</span>, <span class="number">0x7d</span>, <span class="number">0x30</span>, <span class="number">0x67</span>, <span class="number">0x73</span>, <span class="number">0x08</span>, <span class="number">0x09</span>,</span><br><span class="line">        <span class="number">0xee</span>, <span class="number">0xb7</span>, <span class="number">0x70</span>, <span class="number">0x3f</span>, <span class="number">0x61</span>, <span class="number">0xb2</span>, <span class="number">0x19</span>, <span class="number">0x8e</span>, <span class="number">0x4e</span>, <span class="number">0xe5</span>, <span class="number">0x4b</span>, <span class="number">0x93</span>, <span class="number">0x8f</span>, <span class="number">0x5d</span>, <span class="number">0xdb</span>, <span class="number">0xa9</span>,</span><br><span class="line">        <span class="number">0xad</span>, <span class="number">0xf1</span>, <span class="number">0xae</span>, <span class="number">0x2e</span>, <span class="number">0xcb</span>, <span class="number">0x0d</span>, <span class="number">0xfc</span>, <span class="number">0xf4</span>, <span class="number">0x2d</span>, <span class="number">0x46</span>, <span class="number">0x6e</span>, <span class="number">0x1d</span>, <span class="number">0x97</span>, <span class="number">0xe8</span>, <span class="number">0xd1</span>, <span class="number">0xe9</span>,</span><br><span class="line">        <span class="number">0x4d</span>, <span class="number">0x37</span>, <span class="number">0xa5</span>, <span class="number">0x75</span>, <span class="number">0x5e</span>, <span class="number">0x83</span>, <span class="number">0x9e</span>, <span class="number">0xab</span>, <span class="number">0x82</span>, <span class="number">0x9d</span>, <span class="number">0xb9</span>, <span class="number">0x1c</span>, <span class="number">0xe0</span>, <span class="number">0xcd</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0xb6</span>, <span class="number">0xbd</span>, <span class="number">0x58</span>, <span class="number">0x24</span>, <span class="number">0xa2</span>, <span class="number">0x5f</span>, <span class="number">0x38</span>, <span class="number">0x78</span>, <span class="number">0x99</span>, <span class="number">0x15</span>, <span class="number">0x90</span>, <span class="number">0x50</span>, <span class="number">0xb8</span>, <span class="number">0x95</span>, <span class="number">0xe4</span>,</span><br><span class="line">        <span class="number">0xd0</span>, <span class="number">0x91</span>, <span class="number">0xc7</span>, <span class="number">0xce</span>, <span class="number">0xed</span>, <span class="number">0x0f</span>, <span class="number">0xb4</span>, <span class="number">0x6f</span>, <span class="number">0xa0</span>, <span class="number">0xcc</span>, <span class="number">0xf0</span>, <span class="number">0x02</span>, <span class="number">0x4a</span>, <span class="number">0x79</span>, <span class="number">0xc3</span>, <span class="number">0xde</span>,</span><br><span class="line">        <span class="number">0xa3</span>, <span class="number">0xef</span>, <span class="number">0xea</span>, <span class="number">0x51</span>, <span class="number">0xe6</span>, <span class="number">0x6b</span>, <span class="number">0x18</span>, <span class="number">0xec</span>, <span class="number">0x1b</span>, <span class="number">0x2c</span>, <span class="number">0x80</span>, <span class="number">0xf7</span>, <span class="number">0x74</span>, <span class="number">0xe7</span>, <span class="number">0xff</span>, <span class="number">0x21</span>,</span><br><span class="line">        <span class="number">0x5a</span>, <span class="number">0x6a</span>, <span class="number">0x54</span>, <span class="number">0x1e</span>, <span class="number">0x41</span>, <span class="number">0x31</span>, <span class="number">0x92</span>, <span class="number">0x35</span>, <span class="number">0xc4</span>, <span class="number">0x33</span>, <span class="number">0x07</span>, <span class="number">0x0a</span>, <span class="number">0xba</span>, <span class="number">0x7e</span>, <span class="number">0x0e</span>, <span class="number">0x34</span>,</span><br><span class="line">        <span class="number">0x88</span>, <span class="number">0xb1</span>, <span class="number">0x98</span>, <span class="number">0x7c</span>, <span class="number">0xf3</span>, <span class="number">0x3d</span>, <span class="number">0x60</span>, <span class="number">0x6c</span>, <span class="number">0x7b</span>, <span class="number">0xca</span>, <span class="number">0xd3</span>, <span class="number">0x1f</span>, <span class="number">0x32</span>, <span class="number">0x65</span>, <span class="number">0x04</span>, <span class="number">0x28</span>,</span><br><span class="line">        <span class="number">0x64</span>, <span class="number">0xbe</span>, <span class="number">0x85</span>, <span class="number">0x9b</span>, <span class="number">0x2f</span>, <span class="number">0x59</span>, <span class="number">0x8a</span>, <span class="number">0xd7</span>, <span class="number">0xb0</span>, <span class="number">0x25</span>, <span class="number">0xac</span>, <span class="number">0xaf</span>, <span class="number">0x12</span>, <span class="number">0x03</span>, <span class="number">0xe2</span>, <span class="number">0xf2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the constants D */</span></span><br><span class="line">u32 EK_d[<span class="number">16</span>] = &#123;</span><br><span class="line">        <span class="number">0x44D7</span>, <span class="number">0x26BC</span>, <span class="number">0x626B</span>, <span class="number">0x135E</span>, <span class="number">0x5789</span>, <span class="number">0x35E2</span>, <span class="number">0x7135</span>, <span class="number">0x09AF</span>,</span><br><span class="line">        <span class="number">0x4D78</span>, <span class="number">0x2F13</span>, <span class="number">0x6BC4</span>, <span class="number">0x1AF1</span>, <span class="number">0x5E26</span>, <span class="number">0x3C4D</span>, <span class="number">0x789A</span>, <span class="number">0x47AC</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ——————————————————————- */</span></span><br><span class="line"><span class="comment">/* c = a + b mod (2^31 – 1) */</span></span><br><span class="line"><span class="function">u32 <span class="title">AddM</span><span class="params">(u32 a, u32 b)</span> </span>&#123;</span><br><span class="line">    u32 c = a + b;</span><br><span class="line">    <span class="keyword">return</span> (c &amp; <span class="number">0x7FFFFFFF</span>) + (c &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* LFSR with initialization mode */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MulByPow2(x, k) ((((x) <span class="meta-string">&lt;&lt; k) | ((x) &gt;&gt; (31 - k))) &amp; 0x7FFFFFFF)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LFSRWithInitialisationMode</span><span class="params">(u32 u)</span> </span>&#123;</span><br><span class="line">    u32 f, v;</span><br><span class="line">    f = LFSR_S0;</span><br><span class="line">    v = MulByPow2(LFSR_S0, <span class="number">8</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S4, <span class="number">20</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S10, <span class="number">21</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S13, <span class="number">17</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S15, <span class="number">15</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    f = AddM(f, u);</span><br><span class="line"><span class="comment">/* update the state */</span></span><br><span class="line">    LFSR_S0 = LFSR_S1;</span><br><span class="line">    LFSR_S1 = LFSR_S2;</span><br><span class="line">    LFSR_S2 = LFSR_S3;</span><br><span class="line">    LFSR_S3 = LFSR_S4;</span><br><span class="line">    LFSR_S4 = LFSR_S5;</span><br><span class="line">    LFSR_S5 = LFSR_S6;</span><br><span class="line">    LFSR_S6 = LFSR_S7;</span><br><span class="line">    LFSR_S7 = LFSR_S8;</span><br><span class="line">    LFSR_S8 = LFSR_S9;</span><br><span class="line">    LFSR_S9 = LFSR_S10;</span><br><span class="line">    LFSR_S10 = LFSR_S11;</span><br><span class="line">    LFSR_S11 = LFSR_S12;</span><br><span class="line">    LFSR_S12 = LFSR_S13;</span><br><span class="line">    LFSR_S13 = LFSR_S14;</span><br><span class="line">    LFSR_S14 = LFSR_S15;</span><br><span class="line">    LFSR_S15 = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LFSR with work mode */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LFSRWithWorkMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    u32 f, v;</span><br><span class="line">    f = LFSR_S0;</span><br><span class="line">    v = MulByPow2(LFSR_S0, <span class="number">8</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S4, <span class="number">20</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S10, <span class="number">21</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S13, <span class="number">17</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S15, <span class="number">15</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"><span class="comment">/* update the state */</span></span><br><span class="line">    LFSR_S0 = LFSR_S1;</span><br><span class="line">    LFSR_S1 = LFSR_S2;</span><br><span class="line">    LFSR_S2 = LFSR_S3;</span><br><span class="line">    LFSR_S3 = LFSR_S4;</span><br><span class="line">    LFSR_S4 = LFSR_S5;</span><br><span class="line">    LFSR_S5 = LFSR_S6;</span><br><span class="line">    LFSR_S6 = LFSR_S7;</span><br><span class="line">    LFSR_S7 = LFSR_S8;</span><br><span class="line">    LFSR_S8 = LFSR_S9;</span><br><span class="line">    LFSR_S9 = LFSR_S10;</span><br><span class="line">    LFSR_S10 = LFSR_S11;</span><br><span class="line">    LFSR_S11 = LFSR_S12;</span><br><span class="line">    LFSR_S12 = LFSR_S13;</span><br><span class="line">    LFSR_S13 = LFSR_S14;</span><br><span class="line">    LFSR_S14 = LFSR_S15;</span><br><span class="line">    LFSR_S15 = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BitReorganization */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitReorganization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BRC_X0 = ((LFSR_S15 &amp; <span class="number">0x7FFF8000</span>) &lt;&lt; <span class="number">1</span>) | (LFSR_S14 &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">    BRC_X1 = ((LFSR_S11 &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>) | (LFSR_S9 &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    BRC_X2 = ((LFSR_S7 &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>) | (LFSR_S5 &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    BRC_X3 = ((LFSR_S2 &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>) | (LFSR_S0 &gt;&gt; <span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROT(a, k) (((a) <span class="meta-string">&lt;&lt; k) | ((a) &gt;&gt; (32 - k)))</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* L1 */</span></span><br><span class="line"><span class="function">u32 <span class="title">L1</span><span class="params">(u32 X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (X ^ ROT(X, <span class="number">2</span>) ^ ROT(X, <span class="number">10</span>) ^ ROT(X, <span class="number">18</span>) ^ ROT(X, <span class="number">24</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* L2 */</span></span><br><span class="line"><span class="function">u32 <span class="title">L2</span><span class="params">(u32 X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (X ^ ROT(X, <span class="number">8</span>) ^ ROT(X, <span class="number">14</span>) ^ ROT(X, <span class="number">22</span>) ^ ROT(X, <span class="number">30</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKEU32(a, b, c, d) (((u32)(a) &lt;&lt; 24) | ((u32)(b) &lt;&lt; 16)| ((u32)(c) &lt;&lt; 8) | ((u32)(d)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* F */</span></span><br><span class="line"><span class="function">u32 <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    u32 W, W1, W2, u, v;</span><br><span class="line">    W = (BRC_X0 ^ F_R1) + F_R2;</span><br><span class="line">    W1 = F_R1 + BRC_X1;</span><br><span class="line">    W2 = F_R2 ^ BRC_X2;</span><br><span class="line">    u = L1((W1 &lt;&lt; <span class="number">16</span>) | (W2 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    v = L2((W2 &lt;&lt; <span class="number">16</span>) | (W1 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    F_R1 = MAKEU32(S0[u &gt;&gt; <span class="number">24</span>], S1[(u &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>],</span><br><span class="line">                   S0[(u &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>], S1[u &amp; <span class="number">0xFF</span>]);</span><br><span class="line">    F_R2 = MAKEU32(S0[v &gt;&gt; <span class="number">24</span>], S1[(v &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>],</span><br><span class="line">                   S0[(v &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>], S1[v &amp; <span class="number">0xFF</span>]);</span><br><span class="line">    <span class="keyword">return</span> W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKEU31(a, b, c) (((u32)(a) &lt;&lt; 23) | ((u32)(b) &lt;&lt; 8) | (u32)(c))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialization</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *k, <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span> </span>&#123;</span><br><span class="line">    u32 w, nCount;</span><br><span class="line"><span class="comment">/* expand key */</span></span><br><span class="line">    LFSR_S0 = MAKEU31(k[<span class="number">0</span>], EK_d[<span class="number">0</span>], iv[<span class="number">0</span>]);</span><br><span class="line">    LFSR_S1 = MAKEU31(k[<span class="number">1</span>], EK_d[<span class="number">1</span>], iv[<span class="number">1</span>]);</span><br><span class="line">    LFSR_S2 = MAKEU31(k[<span class="number">2</span>], EK_d[<span class="number">2</span>], iv[<span class="number">2</span>]);</span><br><span class="line">    LFSR_S3 = MAKEU31(k[<span class="number">3</span>], EK_d[<span class="number">3</span>], iv[<span class="number">3</span>]);</span><br><span class="line">    LFSR_S4 = MAKEU31(k[<span class="number">4</span>], EK_d[<span class="number">4</span>], iv[<span class="number">4</span>]);</span><br><span class="line">    LFSR_S5 = MAKEU31(k[<span class="number">5</span>], EK_d[<span class="number">5</span>], iv[<span class="number">5</span>]);</span><br><span class="line">    LFSR_S6 = MAKEU31(k[<span class="number">6</span>], EK_d[<span class="number">6</span>], iv[<span class="number">6</span>]);</span><br><span class="line">    LFSR_S7 = MAKEU31(k[<span class="number">7</span>], EK_d[<span class="number">7</span>], iv[<span class="number">7</span>]);</span><br><span class="line">    LFSR_S8 = MAKEU31(k[<span class="number">8</span>], EK_d[<span class="number">8</span>], iv[<span class="number">8</span>]);</span><br><span class="line">    LFSR_S9 = MAKEU31(k[<span class="number">9</span>], EK_d[<span class="number">9</span>], iv[<span class="number">9</span>]);</span><br><span class="line">    LFSR_S10 = MAKEU31(k[<span class="number">10</span>], EK_d[<span class="number">10</span>], iv[<span class="number">10</span>]);</span><br><span class="line">    LFSR_S11 = MAKEU31(k[<span class="number">11</span>], EK_d[<span class="number">11</span>], iv[<span class="number">11</span>]);</span><br><span class="line">    LFSR_S12 = MAKEU31(k[<span class="number">12</span>], EK_d[<span class="number">12</span>], iv[<span class="number">12</span>]);</span><br><span class="line">    LFSR_S13 = MAKEU31(k[<span class="number">13</span>], EK_d[<span class="number">13</span>], iv[<span class="number">13</span>]);</span><br><span class="line">    LFSR_S14 = MAKEU31(k[<span class="number">14</span>], EK_d[<span class="number">14</span>], iv[<span class="number">14</span>]);</span><br><span class="line">    LFSR_S15 = MAKEU31(k[<span class="number">15</span>], EK_d[<span class="number">15</span>], iv[<span class="number">15</span>]);</span><br><span class="line"><span class="comment">/* set F_R1 and F_R2 to zero */</span></span><br><span class="line">    F_R1 = <span class="number">0</span>;</span><br><span class="line">    F_R2 = <span class="number">0</span>;</span><br><span class="line">    nCount = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">while</span> (nCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        BitReorganization();</span><br><span class="line">        w = F();</span><br><span class="line">        LFSRWithInitialisationMode(w &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        nCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateKeyStream</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *pKeyStream, <span class="keyword">unsigned</span> <span class="keyword">int</span> KeyStreamLen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    &#123;</span><br><span class="line">        BitReorganization();</span><br><span class="line">        F(); <span class="comment">/* discard the output of F */</span></span><br><span class="line">        LFSRWithWorkMode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KeyStreamLen; i++) &#123;</span><br><span class="line">        BitReorganization();</span><br><span class="line">        pKeyStream[i] = F() ^ BRC_X3;</span><br><span class="line">        LFSRWithWorkMode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-C-实现（和C基本一样）"><a href="#B-C-实现（和C基本一样）" class="headerlink" title="B. C++实现（和C基本一样）"></a>B. C++实现（和C基本一样）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ZUC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* state registers LFSR */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> LFSR_S[<span class="number">16</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* F registers */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> F_R1 ;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> F_R2 ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output of BR procedure */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> BRC_X[<span class="number">4</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* S-boxes */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> S0[<span class="number">256</span>] = &#123;</span><br><span class="line">    <span class="number">0x3e</span>,<span class="number">0x72</span>,<span class="number">0x5b</span>,<span class="number">0x47</span>,<span class="number">0xca</span>,<span class="number">0xe0</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x04</span>,<span class="number">0xd1</span>,<span class="number">0x54</span>,<span class="number">0x98</span>,<span class="number">0x09</span>,<span class="number">0xb9</span>,<span class="number">0x6d</span>,<span class="number">0xcb</span>,</span><br><span class="line">    <span class="number">0x7b</span>,<span class="number">0x1b</span>,<span class="number">0xf9</span>,<span class="number">0x32</span>,<span class="number">0xaf</span>,<span class="number">0x9d</span>,<span class="number">0x6a</span>,<span class="number">0xa5</span>,<span class="number">0xb8</span>,<span class="number">0x2d</span>,<span class="number">0xfc</span>,<span class="number">0x1d</span>,<span class="number">0x08</span>,<span class="number">0x53</span>,<span class="number">0x03</span>,<span class="number">0x90</span>,</span><br><span class="line">    <span class="number">0x4d</span>,<span class="number">0x4e</span>,<span class="number">0x84</span>,<span class="number">0x99</span>,<span class="number">0xe4</span>,<span class="number">0xce</span>,<span class="number">0xd9</span>,<span class="number">0x91</span>,<span class="number">0xdd</span>,<span class="number">0xb6</span>,<span class="number">0x85</span>,<span class="number">0x48</span>,<span class="number">0x8b</span>,<span class="number">0x29</span>,<span class="number">0x6e</span>,<span class="number">0xac</span>,</span><br><span class="line">    <span class="number">0xcd</span>,<span class="number">0xc1</span>,<span class="number">0xf8</span>,<span class="number">0x1e</span>,<span class="number">0x73</span>,<span class="number">0x43</span>,<span class="number">0x69</span>,<span class="number">0xc6</span>,<span class="number">0xb5</span>,<span class="number">0xbd</span>,<span class="number">0xfd</span>,<span class="number">0x39</span>,<span class="number">0x63</span>,<span class="number">0x20</span>,<span class="number">0xd4</span>,<span class="number">0x38</span>,</span><br><span class="line">    <span class="number">0x76</span>,<span class="number">0x7d</span>,<span class="number">0xb2</span>,<span class="number">0xa7</span>,<span class="number">0xcf</span>,<span class="number">0xed</span>,<span class="number">0x57</span>,<span class="number">0xc5</span>,<span class="number">0xf3</span>,<span class="number">0x2c</span>,<span class="number">0xbb</span>,<span class="number">0x14</span>,<span class="number">0x21</span>,<span class="number">0x06</span>,<span class="number">0x55</span>,<span class="number">0x9b</span>,</span><br><span class="line">    <span class="number">0xe3</span>,<span class="number">0xef</span>,<span class="number">0x5e</span>,<span class="number">0x31</span>,<span class="number">0x4f</span>,<span class="number">0x7f</span>,<span class="number">0x5a</span>,<span class="number">0xa4</span>,<span class="number">0x0d</span>,<span class="number">0x82</span>,<span class="number">0x51</span>,<span class="number">0x49</span>,<span class="number">0x5f</span>,<span class="number">0xba</span>,<span class="number">0x58</span>,<span class="number">0x1c</span>,</span><br><span class="line">    <span class="number">0x4a</span>,<span class="number">0x16</span>,<span class="number">0xd5</span>,<span class="number">0x17</span>,<span class="number">0xa8</span>,<span class="number">0x92</span>,<span class="number">0x24</span>,<span class="number">0x1f</span>,<span class="number">0x8c</span>,<span class="number">0xff</span>,<span class="number">0xd8</span>,<span class="number">0xae</span>,<span class="number">0x2e</span>,<span class="number">0x01</span>,<span class="number">0xd3</span>,<span class="number">0xad</span>,</span><br><span class="line">    <span class="number">0x3b</span>,<span class="number">0x4b</span>,<span class="number">0xda</span>,<span class="number">0x46</span>,<span class="number">0xeb</span>,<span class="number">0xc9</span>,<span class="number">0xde</span>,<span class="number">0x9a</span>,<span class="number">0x8f</span>,<span class="number">0x87</span>,<span class="number">0xd7</span>,<span class="number">0x3a</span>,<span class="number">0x80</span>,<span class="number">0x6f</span>,<span class="number">0x2f</span>,<span class="number">0xc8</span>,</span><br><span class="line">    <span class="number">0xb1</span>,<span class="number">0xb4</span>,<span class="number">0x37</span>,<span class="number">0xf7</span>,<span class="number">0x0a</span>,<span class="number">0x22</span>,<span class="number">0x13</span>,<span class="number">0x28</span>,<span class="number">0x7c</span>,<span class="number">0xcc</span>,<span class="number">0x3c</span>,<span class="number">0x89</span>,<span class="number">0xc7</span>,<span class="number">0xc3</span>,<span class="number">0x96</span>,<span class="number">0x56</span>,</span><br><span class="line">    <span class="number">0x07</span>,<span class="number">0xbf</span>,<span class="number">0x7e</span>,<span class="number">0xf0</span>,<span class="number">0x0b</span>,<span class="number">0x2b</span>,<span class="number">0x97</span>,<span class="number">0x52</span>,<span class="number">0x35</span>,<span class="number">0x41</span>,<span class="number">0x79</span>,<span class="number">0x61</span>,<span class="number">0xa6</span>,<span class="number">0x4c</span>,<span class="number">0x10</span>,<span class="number">0xfe</span>,</span><br><span class="line">    <span class="number">0xbc</span>,<span class="number">0x26</span>,<span class="number">0x95</span>,<span class="number">0x88</span>,<span class="number">0x8a</span>,<span class="number">0xb0</span>,<span class="number">0xa3</span>,<span class="number">0xfb</span>,<span class="number">0xc0</span>,<span class="number">0x18</span>,<span class="number">0x94</span>,<span class="number">0xf2</span>,<span class="number">0xe1</span>,<span class="number">0xe5</span>,<span class="number">0xe9</span>,<span class="number">0x5d</span>,</span><br><span class="line">    <span class="number">0xd0</span>,<span class="number">0xdc</span>,<span class="number">0x11</span>,<span class="number">0x66</span>,<span class="number">0x64</span>,<span class="number">0x5c</span>,<span class="number">0xec</span>,<span class="number">0x59</span>,<span class="number">0x42</span>,<span class="number">0x75</span>,<span class="number">0x12</span>,<span class="number">0xf5</span>,<span class="number">0x74</span>,<span class="number">0x9c</span>,<span class="number">0xaa</span>,<span class="number">0x23</span>,</span><br><span class="line">    <span class="number">0x0e</span>,<span class="number">0x86</span>,<span class="number">0xab</span>,<span class="number">0xbe</span>,<span class="number">0x2a</span>,<span class="number">0x02</span>,<span class="number">0xe7</span>,<span class="number">0x67</span>,<span class="number">0xe6</span>,<span class="number">0x44</span>,<span class="number">0xa2</span>,<span class="number">0x6c</span>,<span class="number">0xc2</span>,<span class="number">0x93</span>,<span class="number">0x9f</span>,<span class="number">0xf1</span>,</span><br><span class="line">    <span class="number">0xf6</span>,<span class="number">0xfa</span>,<span class="number">0x36</span>,<span class="number">0xd2</span>,<span class="number">0x50</span>,<span class="number">0x68</span>,<span class="number">0x9e</span>,<span class="number">0x62</span>,<span class="number">0x71</span>,<span class="number">0x15</span>,<span class="number">0x3d</span>,<span class="number">0xd6</span>,<span class="number">0x40</span>,<span class="number">0xc4</span>,<span class="number">0xe2</span>,<span class="number">0x0f</span>,</span><br><span class="line">    <span class="number">0x8e</span>,<span class="number">0x83</span>,<span class="number">0x77</span>,<span class="number">0x6b</span>,<span class="number">0x25</span>,<span class="number">0x05</span>,<span class="number">0x3f</span>,<span class="number">0x0c</span>,<span class="number">0x30</span>,<span class="number">0xea</span>,<span class="number">0x70</span>,<span class="number">0xb7</span>,<span class="number">0xa1</span>,<span class="number">0xe8</span>,<span class="number">0xa9</span>,<span class="number">0x65</span>,</span><br><span class="line">    <span class="number">0x8d</span>,<span class="number">0x27</span>,<span class="number">0x1a</span>,<span class="number">0xdb</span>,<span class="number">0x81</span>,<span class="number">0xb3</span>,<span class="number">0xa0</span>,<span class="number">0xf4</span>,<span class="number">0x45</span>,<span class="number">0x7a</span>,<span class="number">0x19</span>,<span class="number">0xdf</span>,<span class="number">0xee</span>,<span class="number">0x78</span>,<span class="number">0x34</span>,<span class="number">0x60</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> S1[<span class="number">256</span>] = &#123;</span><br><span class="line">    <span class="number">0x55</span>,<span class="number">0xc2</span>,<span class="number">0x63</span>,<span class="number">0x71</span>,<span class="number">0x3b</span>,<span class="number">0xc8</span>,<span class="number">0x47</span>,<span class="number">0x86</span>,<span class="number">0x9f</span>,<span class="number">0x3c</span>,<span class="number">0xda</span>,<span class="number">0x5b</span>,<span class="number">0x29</span>,<span class="number">0xaa</span>,<span class="number">0xfd</span>,<span class="number">0x77</span>,</span><br><span class="line">    <span class="number">0x8c</span>,<span class="number">0xc5</span>,<span class="number">0x94</span>,<span class="number">0x0c</span>,<span class="number">0xa6</span>,<span class="number">0x1a</span>,<span class="number">0x13</span>,<span class="number">0x00</span>,<span class="number">0xe3</span>,<span class="number">0xa8</span>,<span class="number">0x16</span>,<span class="number">0x72</span>,<span class="number">0x40</span>,<span class="number">0xf9</span>,<span class="number">0xf8</span>,<span class="number">0x42</span>,</span><br><span class="line">    <span class="number">0x44</span>,<span class="number">0x26</span>,<span class="number">0x68</span>,<span class="number">0x96</span>,<span class="number">0x81</span>,<span class="number">0xd9</span>,<span class="number">0x45</span>,<span class="number">0x3e</span>,<span class="number">0x10</span>,<span class="number">0x76</span>,<span class="number">0xc6</span>,<span class="number">0xa7</span>,<span class="number">0x8b</span>,<span class="number">0x39</span>,<span class="number">0x43</span>,<span class="number">0xe1</span>,</span><br><span class="line">    <span class="number">0x3a</span>,<span class="number">0xb5</span>,<span class="number">0x56</span>,<span class="number">0x2a</span>,<span class="number">0xc0</span>,<span class="number">0x6d</span>,<span class="number">0xb3</span>,<span class="number">0x05</span>,<span class="number">0x22</span>,<span class="number">0x66</span>,<span class="number">0xbf</span>,<span class="number">0xdc</span>,<span class="number">0x0b</span>,<span class="number">0xfa</span>,<span class="number">0x62</span>,<span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0xdd</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x06</span>,<span class="number">0x36</span>,<span class="number">0xc9</span>,<span class="number">0xc1</span>,<span class="number">0xcf</span>,<span class="number">0xf6</span>,<span class="number">0x27</span>,<span class="number">0x52</span>,<span class="number">0xbb</span>,<span class="number">0x69</span>,<span class="number">0xf5</span>,<span class="number">0xd4</span>,<span class="number">0x87</span>,</span><br><span class="line">    <span class="number">0x7f</span>,<span class="number">0x84</span>,<span class="number">0x4c</span>,<span class="number">0xd2</span>,<span class="number">0x9c</span>,<span class="number">0x57</span>,<span class="number">0xa4</span>,<span class="number">0xbc</span>,<span class="number">0x4f</span>,<span class="number">0x9a</span>,<span class="number">0xdf</span>,<span class="number">0xfe</span>,<span class="number">0xd6</span>,<span class="number">0x8d</span>,<span class="number">0x7a</span>,<span class="number">0xeb</span>,</span><br><span class="line">    <span class="number">0x2b</span>,<span class="number">0x53</span>,<span class="number">0xd8</span>,<span class="number">0x5c</span>,<span class="number">0xa1</span>,<span class="number">0x14</span>,<span class="number">0x17</span>,<span class="number">0xfb</span>,<span class="number">0x23</span>,<span class="number">0xd5</span>,<span class="number">0x7d</span>,<span class="number">0x30</span>,<span class="number">0x67</span>,<span class="number">0x73</span>,<span class="number">0x08</span>,<span class="number">0x09</span>,</span><br><span class="line">    <span class="number">0xee</span>,<span class="number">0xb7</span>,<span class="number">0x70</span>,<span class="number">0x3f</span>,<span class="number">0x61</span>,<span class="number">0xb2</span>,<span class="number">0x19</span>,<span class="number">0x8e</span>,<span class="number">0x4e</span>,<span class="number">0xe5</span>,<span class="number">0x4b</span>,<span class="number">0x93</span>,<span class="number">0x8f</span>,<span class="number">0x5d</span>,<span class="number">0xdb</span>,<span class="number">0xa9</span>,</span><br><span class="line">    <span class="number">0xad</span>,<span class="number">0xf1</span>,<span class="number">0xae</span>,<span class="number">0x2e</span>,<span class="number">0xcb</span>,<span class="number">0x0d</span>,<span class="number">0xfc</span>,<span class="number">0xf4</span>,<span class="number">0x2d</span>,<span class="number">0x46</span>,<span class="number">0x6e</span>,<span class="number">0x1d</span>,<span class="number">0x97</span>,<span class="number">0xe8</span>,<span class="number">0xd1</span>,<span class="number">0xe9</span>,</span><br><span class="line">    <span class="number">0x4d</span>,<span class="number">0x37</span>,<span class="number">0xa5</span>,<span class="number">0x75</span>,<span class="number">0x5e</span>,<span class="number">0x83</span>,<span class="number">0x9e</span>,<span class="number">0xab</span>,<span class="number">0x82</span>,<span class="number">0x9d</span>,<span class="number">0xb9</span>,<span class="number">0x1c</span>,<span class="number">0xe0</span>,<span class="number">0xcd</span>,<span class="number">0x49</span>,<span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0x01</span>,<span class="number">0xb6</span>,<span class="number">0xbd</span>,<span class="number">0x58</span>,<span class="number">0x24</span>,<span class="number">0xa2</span>,<span class="number">0x5f</span>,<span class="number">0x38</span>,<span class="number">0x78</span>,<span class="number">0x99</span>,<span class="number">0x15</span>,<span class="number">0x90</span>,<span class="number">0x50</span>,<span class="number">0xb8</span>,<span class="number">0x95</span>,<span class="number">0xe4</span>,</span><br><span class="line">    <span class="number">0xd0</span>,<span class="number">0x91</span>,<span class="number">0xc7</span>,<span class="number">0xce</span>,<span class="number">0xed</span>,<span class="number">0x0f</span>,<span class="number">0xb4</span>,<span class="number">0x6f</span>,<span class="number">0xa0</span>,<span class="number">0xcc</span>,<span class="number">0xf0</span>,<span class="number">0x02</span>,<span class="number">0x4a</span>,<span class="number">0x79</span>,<span class="number">0xc3</span>,<span class="number">0xde</span>,</span><br><span class="line">    <span class="number">0xa3</span>,<span class="number">0xef</span>,<span class="number">0xea</span>,<span class="number">0x51</span>,<span class="number">0xe6</span>,<span class="number">0x6b</span>,<span class="number">0x18</span>,<span class="number">0xec</span>,<span class="number">0x1b</span>,<span class="number">0x2c</span>,<span class="number">0x80</span>,<span class="number">0xf7</span>,<span class="number">0x74</span>,<span class="number">0xe7</span>,<span class="number">0xff</span>,<span class="number">0x21</span>,</span><br><span class="line">    <span class="number">0x5a</span>,<span class="number">0x6a</span>,<span class="number">0x54</span>,<span class="number">0x1e</span>,<span class="number">0x41</span>,<span class="number">0x31</span>,<span class="number">0x92</span>,<span class="number">0x35</span>,<span class="number">0xc4</span>,<span class="number">0x33</span>,<span class="number">0x07</span>,<span class="number">0x0a</span>,<span class="number">0xba</span>,<span class="number">0x7e</span>,<span class="number">0x0e</span>,<span class="number">0x34</span>,</span><br><span class="line">    <span class="number">0x88</span>,<span class="number">0xb1</span>,<span class="number">0x98</span>,<span class="number">0x7c</span>,<span class="number">0xf3</span>,<span class="number">0x3d</span>,<span class="number">0x60</span>,<span class="number">0x6c</span>,<span class="number">0x7b</span>,<span class="number">0xca</span>,<span class="number">0xd3</span>,<span class="number">0x1f</span>,<span class="number">0x32</span>,<span class="number">0x65</span>,<span class="number">0x04</span>,<span class="number">0x28</span>,</span><br><span class="line">    <span class="number">0x64</span>,<span class="number">0xbe</span>,<span class="number">0x85</span>,<span class="number">0x9b</span>,<span class="number">0x2f</span>,<span class="number">0x59</span>,<span class="number">0x8a</span>,<span class="number">0xd7</span>,<span class="number">0xb0</span>,<span class="number">0x25</span>,<span class="number">0xac</span>,<span class="number">0xaf</span>,<span class="number">0x12</span>,<span class="number">0x03</span>,<span class="number">0xe2</span>,<span class="number">0xf2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* D constants */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EK_d[<span class="number">16</span>] = &#123;</span><br><span class="line">    <span class="number">0x44D7</span>, <span class="number">0x26BC</span>, <span class="number">0x626B</span>, <span class="number">0x135E</span>, <span class="number">0x5789</span>, <span class="number">0x35E2</span>, <span class="number">0x7135</span>, <span class="number">0x09AF</span>,</span><br><span class="line">    <span class="number">0x4D78</span>, <span class="number">0x2F13</span>, <span class="number">0x6BC4</span>, <span class="number">0x1AF1</span>, <span class="number">0x5E26</span>, <span class="number">0x3C4D</span>, <span class="number">0x789A</span>, <span class="number">0x47AC</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">AddM</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> c = a + b;</span><br><span class="line">	<span class="keyword">return</span> (c &amp; <span class="number">0x7FFFFFFF</span>) + (c &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MulByPow2(x, k) ((((x) <span class="meta-string">&lt;&lt; k) | ((x) &gt;&gt; (31 - k))) &amp; 0x7FFFFFFF)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LFSR */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LFSRWithInitializationMode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> f, v;</span><br><span class="line"></span><br><span class="line">    f = LFSR_S[<span class="number">0</span>];</span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">0</span>], <span class="number">8</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">4</span>], <span class="number">20</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">10</span>], <span class="number">21</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">13</span>], <span class="number">17</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">15</span>], <span class="number">15</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    f = AddM(f, u);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update the state */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">        LFSR_S[i] = LFSR_S[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    LFSR_S[<span class="number">15</span>] = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LFSR with work mode */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LFSRWithWorkMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> f, v;</span><br><span class="line"></span><br><span class="line">    f = LFSR_S[<span class="number">0</span>];</span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">0</span>], <span class="number">8</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">4</span>], <span class="number">20</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">10</span>], <span class="number">21</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">13</span>], <span class="number">17</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">15</span>], <span class="number">15</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update state */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">        LFSR_S[i] = LFSR_S[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    LFSR_S[<span class="number">15</span>] = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bit Reorganization Procedure */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitReorganization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BRC_X[<span class="number">0</span>] = ((LFSR_S[<span class="number">15</span>] &amp; <span class="number">0x7FFF8000</span>) &lt;&lt; <span class="number">1</span>) | (LFSR_S[<span class="number">14</span>] &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">    BRC_X[<span class="number">1</span>] = ((LFSR_S[<span class="number">11</span>] &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>) | (LFSR_S[<span class="number">9</span>] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    BRC_X[<span class="number">2</span>] = ((LFSR_S[<span class="number">7</span>] &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>) | (LFSR_S[<span class="number">5</span>] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    BRC_X[<span class="number">3</span>] = ((LFSR_S[<span class="number">2</span>] &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>) | (LFSR_S[<span class="number">0</span>] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROT(a, k) (((a) <span class="meta-string">&lt;&lt; k) | ((a) &gt;&gt; (32 - k)))</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* linear transformation L1 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">L1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (X ^ ROT(X, <span class="number">2</span>) ^ ROT(X, <span class="number">10</span>) ^ ROT(X, <span class="number">18</span>) ^ ROT(X, <span class="number">24</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* linear transformation L2 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">L2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (X ^ ROT(X, <span class="number">8</span>) ^ ROT(X, <span class="number">14</span>) ^ ROT(X, <span class="number">22</span>) ^ ROT(X, <span class="number">30</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create 32-bit word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKEU32(a, b, c ,d) (\</span></span><br><span class="line">((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a) &lt;&lt; <span class="number">24</span>) \</span><br><span class="line">| ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(b) &lt;&lt; <span class="number">16</span>) \</span><br><span class="line">| ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(c) &lt;&lt; <span class="number">8</span>) \</span><br><span class="line">| ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(d)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* non-linear function F */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> W, W1, W2, u, v;</span><br><span class="line"></span><br><span class="line">    W = (BRC_X[<span class="number">0</span>] ^ F_R1) + F_R2;</span><br><span class="line">    W1 = F_R1 + BRC_X[<span class="number">1</span>];</span><br><span class="line">    W2 = F_R2 ^ BRC_X[<span class="number">2</span>];</span><br><span class="line">    u = L1((W1 &lt;&lt; <span class="number">16</span>) | (W2 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    v = L2((W2 &lt;&lt; <span class="number">16</span>) | (W1 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    F_R1 = MAKEU32(S0[u &gt;&gt; <span class="number">24</span>], S1[(u &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>], S0[(u &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>], S1[u &amp; <span class="number">0xFF</span>]);</span><br><span class="line">    F_R2 = MAKEU32(S0[v &gt;&gt; <span class="number">24</span>], S1[(v &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>], S0[(v &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>], S1[v &amp; <span class="number">0xFF</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKEU31(a, b, c) ( \</span></span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">0</span>) \</span><br><span class="line">    | (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a)) &lt;&lt; <span class="number">23</span>) \</span><br><span class="line">    | ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(b) &lt;&lt; <span class="number">8</span>) \</span><br><span class="line">    | (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">0</span>) \</span><br><span class="line">    | (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(c)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialization</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *k, <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* expand key */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">        LFSR_S[i] = MAKEU31(k[i], EK_d[i], iv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* set F_R1 and F_R2 to zero */</span></span><br><span class="line">    F_R1 = <span class="number">0</span>;</span><br><span class="line">    F_R2 = <span class="number">0</span>;	</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nCount = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">while</span> (nCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        BitReorganization();</span><br><span class="line">        w = F();</span><br><span class="line">        LFSRWithInitializationMode(w &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        nCount--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BitReorganization();</span><br><span class="line">    F();</span><br><span class="line">    LFSRWithWorkMode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateKeyStream</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *pKeyStream, <span class="keyword">unsigned</span> <span class="keyword">int</span> KeyStreamLen)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* working cycles */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; KeyStreamLen; ++i)&#123;</span><br><span class="line">        BitReorganization();</span><br><span class="line">        pKeyStream[i] = F() ^ BRC_X[<span class="number">3</span>];</span><br><span class="line">        LFSRWithWorkMode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>ZUC</tag>
        <tag>加密算法</tag>
        <tag>信息安全</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
</search>
