<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>23种设计模式的一句话描述</title>
    <url>/2020/11/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%8F%8F%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>  内容参考自《设计模式：可复用面向对象软件的基础》</p>
</blockquote>
<p>来一句话概括23种设计模式。</p>
<a id="more"></a>
<h1 id="1-创建型"><a href="#1-创建型" class="headerlink" title="1. 创建型"></a>1. 创建型</h1><h2 id="1-1-抽象工厂（Abstract-Factory）"><a href="#1-1-抽象工厂（Abstract-Factory）" class="headerlink" title="1.1 抽象工厂（Abstract Factory）"></a>1.1 抽象工厂（Abstract Factory）</h2><p>提供一个接口，来创建一些列相关或相互依赖的对象，而无须指定它们具体的类。</p>
<h2 id="1-2-生成器（Builder）"><a href="#1-2-生成器（Builder）" class="headerlink" title="1.2 生成器（Builder）"></a>1.2 生成器（Builder）</h2><p>将以复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h2 id="1-3-工厂方法（Factory-Method）"><a href="#1-3-工厂方法（Factory-Method）" class="headerlink" title="1.3 工厂方法（Factory Method）"></a>1.3 工厂方法（Factory Method）</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法让一个类的实例化延迟到其子类。</p>
<h2 id="1-4-原型（Prototype）"><a href="#1-4-原型（Prototype）" class="headerlink" title="1.4 原型（Prototype）"></a>1.4 原型（Prototype）</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h2 id="1-5-单件模式（Singleton）"><a href="#1-5-单件模式（Singleton）" class="headerlink" title="1.5 单件模式（Singleton）"></a>1.5 单件模式（Singleton）</h2><p>保证一个类只有一个实例，并提供一个访问它的全局访问点。</p>
<h1 id="2-结构型"><a href="#2-结构型" class="headerlink" title="2. 结构型"></a>2. 结构型</h1><h2 id="2-1-适配器（Adapter）"><a href="#2-1-适配器（Adapter）" class="headerlink" title="2.1 适配器（Adapter）"></a>2.1 适配器（Adapter）</h2><p>将一个类的接口转换成客户希望的另一个接口。适配器模式使得原来由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<h2 id="2-2-桥接模式（Bridge）"><a href="#2-2-桥接模式（Bridge）" class="headerlink" title="2. 2 桥接模式（Bridge）"></a>2. 2 桥接模式（Bridge）</h2><p>将抽象部分与它的实现部分分离，使它们可以独立地变化。</p>
<h2 id="2-3-组合模式（Composite）"><a href="#2-3-组合模式（Composite）" class="headerlink" title="2.3 组合模式（Composite）"></a>2.3 组合模式（Composite）</h2><p>将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<h2 id="2-4-装饰者模式（Decorator）"><a href="#2-4-装饰者模式（Decorator）" class="headerlink" title="2.4 装饰者模式（Decorator）"></a>2.4 装饰者模式（Decorator）</h2><p>动态地给一个对象添加一些额外的职责。</p>
<h2 id="2-5-外观模式（Facade）"><a href="#2-5-外观模式（Facade）" class="headerlink" title="2.5 外观模式（Facade）"></a>2.5 外观模式（Facade）</h2><p>为子系统中的一组接口提供一个一致的界面，外观模式提供了一个高层接口，这个接口使得这一子接口更加容易使用。</p>
<h2 id="2-6-享元模式（Flyweight）"><a href="#2-6-享元模式（Flyweight）" class="headerlink" title="2.6 享元模式（Flyweight）"></a>2.6 享元模式（Flyweight）</h2><p>运用共享技术有效地支持大量细粒度的对象。</p>
<h2 id="2-7-代理模式（Proxy）"><a href="#2-7-代理模式（Proxy）" class="headerlink" title="2.7 代理模式（Proxy）"></a>2.7 代理模式（Proxy）</h2><p>为其他对象提供一种代理以控制这个对象的访问。</p>
<h1 id="3-行为型"><a href="#3-行为型" class="headerlink" title="3. 行为型"></a>3. 行为型</h1><h2 id="3-1-责任链（Chain-of-Responsibilities）"><a href="#3-1-责任链（Chain-of-Responsibilities）" class="headerlink" title="3.1 责任链（Chain of Responsibilities）"></a>3.1 责任链（Chain of Responsibilities）</h2><p>使每个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链去传递请求，直到有一个对象处理它为止。</p>
<h2 id="3-2-命令模式（Command）"><a href="#3-2-命令模式（Command）" class="headerlink" title="3.2 命令模式（Command）"></a>3.2 命令模式（Command）</h2><p>将一个请求封装成一个对象，从而使得可以用不同请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。</p>
<h2 id="3-3-解释器模式（Interpreter）"><a href="#3-3-解释器模式（Interpreter）" class="headerlink" title="3.3 解释器模式（Interpreter）"></a>3.3 解释器模式（Interpreter）</h2><p>定义一个语言，定义它的文法表示，并定义一个解释器，使用这个解释器来解释语言中的句子。</p>
<h2 id="3-4-迭代器（Iterator）"><a href="#3-4-迭代器（Iterator）" class="headerlink" title="3.4 迭代器（Iterator）"></a>3.4 迭代器（Iterator）</h2><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
<h2 id="3-5-中介者模式（Mediator）"><a href="#3-5-中介者模式（Mediator）" class="headerlink" title="3.5 中介者模式（Mediator）"></a>3.5 中介者模式（Mediator）</h2><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互。</p>
<h2 id="3-6-备忘录模式（Memento）"><a href="#3-6-备忘录模式（Memento）" class="headerlink" title="3.6 备忘录模式（Memento）"></a>3.6 备忘录模式（Memento）</h2><p>在不破坏封装性的条件下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原来保存的状态。</p>
<h2 id="3-7-观察者模式（Observer）"><a href="#3-7-观察者模式（Observer）" class="headerlink" title="3.7 观察者模式（Observer）"></a>3.7 观察者模式（Observer）</h2><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并自动更新。</p>
<h2 id="3-8-状态模式（State）"><a href="#3-8-状态模式（State）" class="headerlink" title="3.8 状态模式（State）"></a>3.8 状态模式（State）</h2><p>允许一个对象在其内部状态改变时改变它的行为。看起来像是修改了它的类。</p>
<h2 id="3-9-策略模式（Strategy）"><a href="#3-9-策略模式（Strategy）" class="headerlink" title="3.9 策略模式（Strategy）"></a>3.9 策略模式（Strategy）</h2><p>定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换。本模式使得算法可以独立于它的客户而变化。</p>
<h2 id="4-0-模板方法模式（Template-Method）"><a href="#4-0-模板方法模式（Template-Method）" class="headerlink" title="4.0 模板方法模式（Template Method）"></a>4.0 模板方法模式（Template Method）</h2><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<h2 id="4-1-访问者（Visitor）"><a href="#4-1-访问者（Visitor）" class="headerlink" title="4.1 访问者（Visitor）"></a>4.1 访问者（Visitor）</h2><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的前提下定义作用于这些元素的新操作。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>开发规范</tag>
        <tag>阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中push_back和emplace_back的区别</title>
    <url>/2020/09/02/CPP%E4%B8%ADpush-back%E5%92%8Cemplace-back%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>在 <code>C++11</code> 之后，<code>vector</code> 容器中添加了新的方法：<code>emplace_back()</code> ，和 <code>push_back()</code> 一样的是都是在容器末尾添加一个新的元素进去，不同的是 <code>emplace_back()</code> 在效率上相比较于 <code>push_back()</code> 有了一定的提升。</p>
<a id="more"></a>
<h1 id="1-push-back-方法"><a href="#1-push-back-方法" class="headerlink" title="1. push_back() 方法"></a>1. <code>push_back()</code> 方法</h1><p>首先分析较为简单直观的 <code>push_back()</code> 方法。对于 <code>push_back()</code> 而言，最开始只有 <code>void push_back( const T&amp; value );</code> 这个函数声明，后来从 <code>C++11</code> ，新加了<code>void push_back( T&amp;&amp; value )</code> 函数，以下为 <code>C++</code> 中的源码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以下程序来自STL源码 bits/stl_vector.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @brief  Add data to the end of the %vector.</span></span><br><span class="line"><span class="comment"> *  @param  __x  Data to be added.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This is a typical stack operation.  The function creates an</span></span><br><span class="line"><span class="comment"> *  element at the end of the %vector and assigns the given data</span></span><br><span class="line"><span class="comment"> *  to it.  Due to the nature of a %vector this operation can be</span></span><br><span class="line"><span class="comment"> *  done in constant time if the %vector has preallocated space</span></span><br><span class="line"><span class="comment"> *  available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type &amp;__x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage) &#123;</span><br><span class="line">        <span class="comment">// 首先判断容器满没满，如果没满那么就构造新的元素，然后插入新的元素</span></span><br><span class="line">        _Alloc_traits::construct(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                                 __x);</span><br><span class="line">        ++<span class="keyword">this</span>-&gt;_M_impl._M_finish; <span class="comment">// 更新当前容器内元素数量</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果满了，那么就重新申请空间，然后拷贝数据，接着插入新数据 __x</span></span><br><span class="line">        _M_realloc_insert(<span class="built_in">end</span>(), __x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 C++ 版本为 C++11 及以上（也就是从 C++11 开始新加了这个方法），使用 emplace_back() 代替</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(value_type &amp;&amp;__x)</span> </span>&#123;</span><br><span class="line">    emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(__x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在 <code>C++20</code> 之后，对这两个重载方法进行了修改，变成了 <code>constexpr void push_back( const T&amp; value );</code> 以及 <code>constexpr void push_back( T&amp;&amp; value );</code> 。详情参考 <code>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1004r2.pdf</code> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1004r2.pdf">版本修改计划</a>。</p>
<h1 id="2-emplace-back-方法"><a href="#2-emplace-back-方法" class="headerlink" title="2. emplace_back() 方法"></a>2. <code>emplace_back()</code> 方法</h1><p><code>emplace_back()</code> 是从 <code>C++11</code> 起新增到 <code>vector</code> 中的方法，最初的函数声明为： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; class... Args &gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>
<p>之后在 <code>C++14</code> 之后，将无返回值 <code>void</code> 改为了返回对插入元素的引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; class... Args &gt;</span><br><span class="line"><span class="function">reference <span class="title">emplace_back</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>STL</code> 源码中，可以看到 <code>emplace_back()</code> 的实现是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以下程序来自STL源码 bits/vector.tcc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt; 201402L</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;::reference</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;::emplace_back(_Args &amp;&amp;... __args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage) &#123;</span><br><span class="line">        <span class="comment">// 同样判断容器是否满了，没满的话，执行构造函数，对元素进行构造，并执行类型转换</span></span><br><span class="line">        _Alloc_traits::construct(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                                 <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">        ++<span class="keyword">this</span>-&gt;_M_impl._M_finish; <span class="comment">// 更新当前容器大小</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 满了的话重新申请内存空间，将新的元素继续构造进来，并且进行类型转换</span></span><br><span class="line">        _M_realloc_insert(<span class="built_in">end</span>(), <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt; 201402L</span></span><br><span class="line">    <span class="keyword">return</span> back(); <span class="comment">// 在 C++14版本之后，添加返回值，返回最后一个元素的引用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>将 <code>emplace_back()</code> 和 <code>push_back()</code> 中区别最大的程序拎出来看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_Alloc_traits::construct(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                                 <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...); <span class="comment">// emplace_back()</span></span><br><span class="line">_Alloc_traits::construct(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                                 __x);                            <span class="comment">// push_back()</span></span><br></pre></td></tr></table></figure>
<p>对于 <code>std::forward()</code> 函数而言，本质上是一个类型转换函数，它的声明函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以下程序来自STL源码 bits/move.h</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an lvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp &amp;&amp;<span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type &amp;<span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp &amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在强制类型转换中，将参数 <code>__t</code> 传递给对应类 <code>_Tp</code> 的构造函数，然后调用了该类的构造函数从而完成对象创建过程。</strong></p>
<p>因此，在 <code>emplace_back()</code> 函数中，是支持直接将构造函数所需的参数传递过去，然后构建一个新的对象出来，然后填充到容器尾部的。</p>
<h1 id="3-直观区别"><a href="#3-直观区别" class="headerlink" title="3. 直观区别"></a>3. 直观区别</h1><p>声明一个 <code>Person</code> 类，里面只有一个字段 <code>_age</code> ，在容器中存储该类的对象，方便于查看整个函数调用过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age) : _age(age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct a person.&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;p) : _age(p._age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy-Construct&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;&amp;p) <span class="keyword">noexcept</span>: _age(p._age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move-Construct&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先使用 <code>push_back()</code> 方法添加创建好的元素，可以看出使用到了<strong>拷贝构造函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; person;</span><br><span class="line">    <span class="keyword">auto</span> p = Person(<span class="number">1</span>); <span class="comment">// &gt;: Construct a person.1</span></span><br><span class="line">    person.push_back(p);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Copy-Construct1 因为容器扩容，需要把前面的元素重新添加进来，因此需要拷贝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再使用 <code>emplace_back()</code> 函数添加元素进来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; person;</span><br><span class="line">    <span class="keyword">auto</span> p = Person(<span class="number">1</span>); <span class="comment">// &gt;: Construct a person.1</span></span><br><span class="line">    person.emplace_back(<span class="built_in">move</span>(p)); <span class="comment">// &gt;: Move-Construct1</span></span><br><span class="line">    person.emplace_back(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Construct a person.2  // 构建一个新的元素</span></span><br><span class="line"><span class="comment">     * &gt;: Move-Construct1       // 拷贝之前的元素过来，这个时候用的是 Person(const Person &amp;&amp;p)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到直接使用<strong>构造参数列表</strong>来添加元素的方法，它会使用到了移动构造函数 <code>move</code> 。这也是 <code>emplace_back()</code> 方法的一大特色。</p>
<h1 id="4-性能分析"><a href="#4-性能分析" class="headerlink" title="4. 性能分析"></a>4. 性能分析</h1><p><code>emplace_back()</code> 函数在原理上比 <code>push_back()</code> 有了一定的改进，包括在内存优化方面和运行效率方面。内存优化主要体现在使用了<strong>就地构造（直接在容器内构造对象，不用拷贝一个复制品再使用）+强制类型转换</strong>的方法来实现，在运行效率方面，由于省去了拷贝构造过程，因此也有一定的提升。</p>
<p>以下程序源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/3.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/3 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age) : _age(age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct a person.&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;p) : _age(p._age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy-Construct&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;&amp;p) <span class="keyword">noexcept</span>: _age(p._age) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move-Construct&quot;</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_EMPLACE_BACK</span></span><br><span class="line"><span class="comment">//#define TEST_PUSH_BACK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; person;</span><br><span class="line">    <span class="keyword">auto</span> p = Person(<span class="number">1</span>); <span class="comment">// &gt;: Construct a person.1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST_EMPLACE_BACK</span></span><br><span class="line">    person.emplace_back(<span class="built_in">move</span>(p)); <span class="comment">// &gt;: Move-Construct1</span></span><br><span class="line">    person.emplace_back(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Construct a person.2  // 构建一个新的元素</span></span><br><span class="line"><span class="comment">     * &gt;: Move-Construct1       // 拷贝之前的元素过来，这个时候用的是 Person(const Person &amp;&amp;p)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST_PUSH_BACK</span></span><br><span class="line">    person.push_back(p);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Copy-Construct1 因为容器扩容，需要把前面的元素重新添加进来，因此需要拷贝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>源码分析</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的顺序容器比较</title>
    <url>/2020/09/10/C++%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>容器就是特定类型对象的集合，顺序容器（Sequential Container）是一种提供了元素顺序存储访问的数据结构，顺序存储意味着在存储方式上仅仅依赖于先后加入容器的顺序。在 <code>C++</code> 的 <code>STL</code> 中，提供了 <code>vector, deque, list, forward_list, array</code> 这几种容器，当然还有 <code>string</code> 也可以视为一种容器，只不过只能存储 <code>char</code> 类型的数据。</p>
<a id="more"></a>
<blockquote>
<p>  本文主要参考自 <em>C++ Primer, 5th Edition</em>, [美] Stanley B. Lippman / [美] Josée Lajoie / [美] Barbara E. Moo</p>
</blockquote>
<h1 id="1-顺序容器类型"><a href="#1-顺序容器类型" class="headerlink" title="1. 顺序容器类型"></a>1. 顺序容器类型</h1><p>在 <code>STL</code> 中（截至 <code>C++11</code>，提供了如下所示几个顺序类型）</p>
<ol>
<li><code>vector</code>：可变大小数组。支持<strong>快速随机</strong>访问。在<strong>尾部</strong>插入元素较快，但其他位置插入很慢。</li>
<li><code>deque</code>：双端队列。支持快速随机访问。在头部、尾部插入元素都很快。</li>
<li><code>list</code>：双向链表。<strong>仅</strong>支持<strong>双向顺序</strong>访问。在<strong>任何位置</strong>删除、添加元素都很快。</li>
<li><code>forward_list</code>：单向链表。<strong>仅</strong>支持<strong>从头部开始</strong>的顺序访问。在链表<strong>任何位置</strong>插入、删除元素都很快。</li>
<li><code>array</code>：固定大小数组。支持<strong>快速随机</strong>访问，<strong>不能</strong>添加、删除元素。</li>
<li><code>string</code>：和 <code>vector</code> 类似，只不过只能存储 <code>char</code> 类型的数据。</li>
</ol>
<h1 id="2-性能分析"><a href="#2-性能分析" class="headerlink" title="2. 性能分析"></a>2. 性能分析</h1><p>除了 <code>array</code> 容器之外，其他容器均提供了高效的内存管理，可以在计算机资源允许的情况下任意添加删除元素到容器中。它们之间的主要区别在于存储策略的不同和操作接口的不同，从而间接导致了不同容器有不同的性能和应用场合。</p>
<p><code>string</code> 和 <code>vector</code> 是存储在一块连续的内存空间中的，因此它可以很方便的计算每一个元素的物理地址从而实现快速随机访问。但是也正是因为它们在连续空间中存储，当需要在中间位置 <code>i</code> 插入元素时，需要将 <code>i + 1</code> 及以后的每一个元素平移到它们的下一个位置，空出来 <code>i</code> 位置才可以插入进来保持空间的连续性。不仅如此，有时添加元素进来，需要<strong>扩容+拷贝元素</strong>到新存储空间中。</p>
<p><code>list</code> 和 <code>forward_list</code> 是两个使用<strong>链表</strong>来实现的数据结构，它们在添加元素时非常便利，但是访问时却不支持快速随机访问，需要从头部（<code>list</code>还支持从尾部向头部的查找）开始逐个遍历访问。除此之外，这俩数据结构在存储每一个元素时，都需要额外的空间来维持链表结构。</p>
<p><code>deque</code> 是一个不仅支持快速随机访问，而且支持在头部和尾部高效的删除或添加元素，在这一点和 <code>list</code> 与 <code>forward_list</code> 效率相当。</p>
<p><code>forward_list</code> 和 <code>array</code> 是 <code>C++11</code> 新添加的类型，<code>array</code> 是一种更加安全、易用的数组类型，在用法上和内置数组类似（并没有感觉到有什么大的区别）。<code>forward_list</code> 是单链表，为了达到最好的性能，没有维护 <code>size</code> 方法，因此计算它的大小时，只能手动实现。</p>
<blockquote>
<p>  一般来说，除非有更好的理由（例如需要高频率中间增加元素和删除元素），使用 <code>vector</code> 就是最好的选择了。</p>
</blockquote>
<h1 id="3-容器选择基本原则"><a href="#3-容器选择基本原则" class="headerlink" title="3. 容器选择基本原则"></a>3. 容器选择基本原则</h1><ol>
<li>一般选 <code>vector</code> 就可以啦，除非有更好理由。</li>
<li>如果空间的额外开销很重要，不要用 <code>list</code> 和 <code>forward_list</code>。</li>
<li>如果要求高频率随机访问元素，那么使用 <code>vector</code> 和 <code>deque</code> 更加合适。</li>
<li>如果需要在容器中间位置插入删除元素，使用 <code>list</code> 和 <code>forward_list</code> 更加合适。</li>
<li>如果只有在最初输入阶段需要插入删除元素，而后稳定下来仅仅需要随机访问，可以这样：<ol>
<li>如果需要在<strong>中间</strong>位置插入元素，那么使用 <code>list</code> 来构造输入阶段，再把它放到 <code>vector</code> 中去。</li>
<li>如果<strong>不需要在中间位置</strong>插入元素，那么直接使用 <code>vector</code> （或 <code>deque</code>）就可以了，因为在末尾（或头部）添加元素就很方便呀。</li>
</ol>
</li>
</ol>
<p>总的来说，容器操作类型（读取或增删）的占比决定了容器类型的选择，因此，在必要情况下进行性能测试也是不错的选择~</p>
<p>如果还是不清楚，那么就用<strong>迭代器</strong>来代替下标访问，因为迭代器是一个通用接口，可以任意替换具体实现而不影响程序使用，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/10.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/10 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  如果后面需要，可以只改一处地方，就完成了整个实现，如：</span></span><br><span class="line"><span class="comment">     *  vector&lt;int&gt; nums = &#123;1, 2, 3, 4, 5&#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = nums.<span class="built_in">begin</span>(); iter != nums.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// &gt;: 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的lambda表达式探究</title>
    <url>/2020/08/30/CPP%E4%B8%AD%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>在 <code>C++11</code> 及之后的版本中，<code>C++</code> 提供了 <code>lambda</code> 表达式，它是一种方便了参数传递和定义匿名函数的方法。该方法通常用于封装算法、执行异步方法 ，也就是说比较适用于少量的代码。以下原文：</p>
<blockquote>
<p>In C++11 and later, a lambda expression—often called a <em>lambda</em>—is a convenient way of defining an anonymous function object (a <em>closure</em>) right at the location where it is invoked or passed as an argument to a function. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous methods. This article defines what lambdas are, compares them to other programming techniques, describes their advantages, and provides a basic example. </p>
</blockquote>
<a id="more"></a>
<h1 id="1-Lambda-表达式的组成"><a href="#1-Lambda-表达式的组成" class="headerlink" title="1. Lambda 表达式的组成"></a>1. <code>Lambda</code> 表达式的组成</h1><p>先对 <code>lambda</code> 表达式有一个直观的认识，参考下面程序，该程序完成的是将输入的数组 <code>nums</code> 按照绝对值大小进行升序排列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) <span class="keyword">mutable</span> <span class="keyword">throw</span>() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="comment">// lambda 表达式函数体，在这里做到了将输入数组升序排列</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(b));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">// &gt;: 1 -1 2 3 4 5 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛开边边角角，单独拿出最重要的一部分来学习，<code>[](int a, int b) mutable throw() -&gt; bool&#123; // statement &#125;</code> 就是 <code>lambda</code> 表达式最原始的内容。在该表达式中，每一部分的含义如下叙述：</p>
<ol>
<li><code>[]</code> 捕获子句：用来捕获<strong>周围范围</strong>中出现的变量，也被称为<strong>引导</strong>子句，可以在其中声明获取的变量是按<strong>值</strong>访问还是<strong>引用</strong>来访问<del>，默认值为 <code>&amp;</code> ，上文中的例子和 <code>[&amp;]</code> 是一样的效果，</del>具体例子见下文。</li>
<li><code>()</code> 参数列表：用来获取参数，对于一个一般的 <code>lambda</code> 函数，使用起来和一般的指针函数没有区别，也是需要有参数列表的，具体例子见下文。</li>
<li><code>mutable</code> 可变类型（可选）：一般来说，在 <code>lambda</code> 体中调用运算符的变量，都是以 <code>const value</code> 来使用的，加上这个 <code>mutable</code> 之后，人家变成了变量来使用，具体栗子见下文。</li>
<li><code>throw()</code> 异常类型（可选）：和普通函数一样样，<code>lambda</code> 函数也可能引发异常，如果不会引发异常的话，直接声明 <code>noexcept</code> 就可以啦~</li>
<li><code>-&gt; bool</code> 返回类型（可选）：继续和普通函数一样</li>
<li><code>&#123;// statement &#125;</code> <code>lambda</code> 体：和一般的函数体一样。</li>
</ol>
<p>不难发现，<code>lambda</code> 函数和一般的函数没有太大区别，基本上只有在头部位置有特殊语法。</p>
<h1 id="2-捕获语句的使用-amp-可变规范-mutable"><a href="#2-捕获语句的使用-amp-可变规范-mutable" class="headerlink" title="2. 捕获语句的使用 &amp; 可变规范 mutable"></a>2. 捕获语句的使用 &amp; 可变规范 <code>mutable</code></h1><p>拿出栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>; <span class="comment">// 在上文中声明好变量 num</span></span><br><span class="line">    <span class="keyword">auto</span> f = [n = num]() &#123; <span class="comment">// 在下文中通过 捕获[] 来获取 num，并在 lambda 函数体中进行使用</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; ++num &lt;&lt; std::endl; // 错误的使用，因为 num 是不可变的常量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    f(); <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="keyword">auto</span> m = [num]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 将内部变量声明成 mutable 可变类型，此时可以修改内部变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    m(); <span class="comment">// &gt;: 2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del><code>mutable</code> 可变声明优势在于可以在内部直接改变外部变量，相当于使用了 <code>[&amp;num]</code> 引用方法。</del></p>
<p><strong>2020年9月1日 修正：</strong> 在 <code>C++14</code> 及以后的版本中，可以通过 <code>capture</code> 语句从周围（Surrounding Scope）捕获变量，在 <code>[]</code> 子句中指定要捕获哪些变量，以及按照何种方式使用它们。和普通语法一样，带有 <code>＆</code> 前缀的变量可以通过<strong>引用</strong>进行访问，而没有前缀 <code>＆</code> 的变量可以通过值进行访问。<strong>而空的捕获子句[]表示 <code>lambda</code> 表达式的主体在闭包范围内不访问外部任何变量。</strong> 当然~，也可以使用默认的捕获模式来指示如何捕获 <code>lambda</code> 中引用的任何外部变量：<code>[＆]</code> 表示周围所有变量都是通过引用捕获的，而 <code>[=]</code> 意味着它们按值所捕获。</p>
<p>一般情况下，<code>lambda</code>的函数调用运算符是<strong>常量值</strong>，但是使用 <code>mutable</code> 关键字可以修改默认值，<code>mutable</code> 使 <code>lambda</code> 表达式的函数体可以修改按值捕获的变量。</p>
<h1 id="3-参数列表"><a href="#3-参数列表" class="headerlink" title="3. 参数列表"></a>3. 参数列表</h1><p>再拿出一个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> y = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; y(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// &gt;: 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里开始，也就是参数列表开始，后面的内容都是可选项，也就是如果为空，那么就直接<strong>省略</strong>不写即可。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> empty = [] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Wow!空的~&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 啥也没有只有个函数体&#125;;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    empty(); <span class="comment">// &gt;: Wow!空的~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-特殊用法"><a href="#4-特殊用法" class="headerlink" title="4. 特殊用法"></a>4. 特殊用法</h1><h2 id="4-1-花里胡哨的-lambda-嵌套"><a href="#4-1-花里胡哨的-lambda-嵌套" class="headerlink" title="4.1 花里胡哨的 lambda 嵌套"></a>4.1 花里胡哨的 <code>lambda</code> 嵌套</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两层 lambda 嵌套，看起来挺花里胡哨</span></span><br><span class="line">    <span class="keyword">auto</span> embed_embed_lambda = [](<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; - - &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> [](<span class="keyword">int</span> c) &#123; <span class="keyword">return</span> c / <span class="number">2</span>; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; embed_embed_lambda(<span class="number">2</span>)(<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2 - - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-高阶-lambda-函数"><a href="#4-2-高阶-lambda-函数" class="headerlink" title="4.2 高阶 lambda 函数"></a>4.2 高阶 <code>lambda</code> 函数</h2><p>高阶函数是指，采用另一个 <code>lambda</code> 表达式作为其参数或返回 <code>lambda</code> 表达式的 <code>lambda</code> 表达式（不知不觉想起了俄罗斯套娃🤔）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回 function 对象的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> get_function = [](<span class="keyword">int</span> x) -&gt; <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用 function 为对象作为其参数的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> param_function = [](<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &amp;f, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> f(n) * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> ans = param_function(get_function(<span class="number">2</span>), <span class="number">3</span>); <span class="comment">// x = 2, n = 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.  总结"></a>5.  总结</h1><p>写到此处，关于 <code>C++</code> 的 <code>lambda</code> 语法规范和用法已经学习了一小部分，它作为一种方便灵活的方法随用随学也是阔以的。</p>
<blockquote>
<p>因为参数类型和函数模板参数一样可以被推导而无需和具体参数类型耦合，有利于重构代码；和使用auto声明变量的作用类似，它也允许避免书写过于复杂的参数类型。特别地，不需要显式指出参数类型使得使用高阶函数变得更加容易。</p>
</blockquote>
<p>以下程序源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/8/30.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/8/30 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b) <span class="keyword">mutable</span> <span class="keyword">throw</span>() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="comment">// lambda 表达式函数体，在这里做到了将输入数组升序排列</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(b));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">// &gt;: 1 -1 2 3 4 5 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>; <span class="comment">// 在上文中声明好变量 num</span></span><br><span class="line">    <span class="keyword">auto</span> f = [n = num]() &#123; <span class="comment">// 在下文中通过 捕获[] 来获取 num，并在 lambda 函数体中进行使用</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; ++num &lt;&lt; std::endl; // 错误的使用，因为 num 是不可变的常量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    f(); <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="keyword">auto</span> m = [num]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 将内部变量声明成 mutable 可变类型，此时可以修改内部变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    m(); <span class="comment">// &gt;: 2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> y = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; y(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// &gt;: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> empty = [] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Wow!空的~&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 啥也没有只有个函数体&#125;;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    empty(); <span class="comment">// &gt;: Wow!空的~</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个函数，然后直接使用 (5, 3)</span></span><br><span class="line">    <span class="keyword">int</span> n = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两层 lambda 嵌套，看起来挺花里胡哨</span></span><br><span class="line">    <span class="keyword">auto</span> embed_embed_lambda = [](<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; - - &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> [](<span class="keyword">int</span> c) &#123; <span class="keyword">return</span> c / <span class="number">2</span>; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; embed_embed_lambda(<span class="number">2</span>)(<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2 - - 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 function 对象的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> get_function = [](<span class="keyword">int</span> x) -&gt; <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 function 为对象作为其参数的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> param_function = [](<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &amp;f, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> f(n) * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ans = param_function(get_function(<span class="number">2</span>), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>2020年10月25日更新：</strong></p>
<p>今天在刷题时，突发奇想出这样的用法来，可以实现动态函数调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRestaurant</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;list2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; mapper;</span><br><span class="line">        <span class="keyword">auto</span> insert = [&amp;](<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;<span class="built_in">list</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span> &amp;item : <span class="built_in">list</span>) mapper.insert(item);</span><br><span class="line">        &#125;;</span><br><span class="line">        list1.<span class="built_in">size</span>() &gt; list2.<span class="built_in">size</span>() ? insert(list1) : insert(list2);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span> &amp;item : list1.<span class="built_in">size</span>() &gt; list2.<span class="built_in">size</span>() ? list2 : list1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapper.count(item)) ans.emplace_back(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实现的是查找两个列表中的共有元素。</p>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的unordered_map和map的区别</title>
    <url>/2020/09/01/CPP%E4%B8%AD%E7%9A%84unordered-map%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><code>unordered_map</code> 类模板和 <code>map</code> 类模板都是描述了这么一个对象：它是由 <code>std::pair&lt;const Key, value&gt;</code> 组成的可变长容器，这个容器中每个元素存储两个对象，也就是 <code>key</code> - <code>value</code> 对。</p>
<a id="more"></a>
<h1 id="1-unordered-map"><a href="#1-unordered-map" class="headerlink" title="1. unordered_map"></a>1. <code>unordered_map</code></h1><p>在头文件上，引入 <code>&lt;unordered_map&gt;</code> 来使用它。对于 <code>unordered_map</code> 而言，最大的特点在于内部实现上，使用到了<strong>哈希表</strong>（散列表、<code>hash_table</code> ）来进行映射存储，它的模板类声明及其参数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序来自STL源码 bits/unordered_map.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key,  <span class="comment">// key 类型 </span></span><br><span class="line">        <span class="keyword">typename</span> _Tp,    <span class="comment">// value 类型</span></span><br><span class="line">        <span class="keyword">typename</span> _Hash = hash &lt;_Key&gt;,     <span class="comment">// 哈希函数</span></span><br><span class="line">        <span class="keyword">typename</span> _Pred = equal_to &lt;_Key&gt;, <span class="comment">// 用于比较两者是否相同的函数</span></span><br><span class="line">        <span class="keyword">typename</span> _Alloc = allocator &lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">const</span> _Key, _Tp&gt;&gt;&gt; <span class="comment">// 分配器，描述了容器在内存管理上的细节，不应该自己来处理，除非写自己的容器</span></span><br><span class="line">class <span class="built_in">unordered_map</span> &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>unordered_map</code> 内部，使用的 <code>Hash Table</code> 对数据进行组织，通过把键值 <code>key</code> 映射到 <code>hash</code> 表中的一个位置进行访问，根据 <code>hash</code> 函数的特点， <code>unordered_map</code> 对于元素查找的时间复杂度可以达到 <code>O(1)</code> ，但是，它的元素排列是无序的。具体例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="comment">// 首先创建一个无序 map，它的 key 使用 int 类型，value 使用 string 类型</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; unorderedMap;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 三种插入新元素的方法，“茴”字有三种写法~</span></span><br><span class="line">    unorderedMap.insert(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="string">&quot;Alice&quot;</span>)); </span><br><span class="line">    unorderedMap[<span class="number">1</span>] = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    unorderedMap.insert(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">2</span>, <span class="string">&quot;Candy&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 对内部元素挨个输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = unorderedMap.<span class="built_in">begin</span>(); iter != unorderedMap.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * &gt;: 输出如下，可以得知它们在 key 的排序上并没有顺序</span></span><br><span class="line"><span class="comment">         * 2 - Candy</span></span><br><span class="line"><span class="comment">         * 0 - Alice</span></span><br><span class="line"><span class="comment">         * 1 - Bob</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>unordered_map</code> 由于建立了哈希表，所以它在最开始建立的时候比较耗时间，但是它查询速度快呀~，一般情况下用 <code>unordered_map</code> 是没有问题的。</p>
<h1 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. <code>map</code></h1><p>对于 <code>map</code> 而言，首先在头文件上，引用 <code>&lt;map&gt;</code> 进来，然后使用。它的类模板声明以及部分函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序来自C++源码 bits/stl_map.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key,  <span class="comment">// key 类型</span></span><br><span class="line">        <span class="keyword">typename</span> _Tp,    <span class="comment">// value 类型</span></span><br><span class="line">        <span class="keyword">typename</span> _Compare = <span class="built_in">std</span>::less&lt;_Key&gt;, <span class="comment">// 用于比较两个元素的比较函数</span></span><br><span class="line">        <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt; &gt; <span class="comment">// 分配器，同样的描述了容器在内存管理上的细节，不应该自己来处理，除非写自己的容器</span></span><br><span class="line">class <span class="built_in">map</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 将一个红黑树转换成 [multi]map.</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::<span class="keyword">template</span></span><br><span class="line">    rebind&lt;value_type&gt;::other _Pair_alloc_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree&lt;key_type, value_type, _Select1st&lt;value_type&gt;,</span><br><span class="line">    key_compare, _Pair_alloc_type&gt; _Rep_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>map</code> 的内部，使用了<strong>红黑树</strong>（<code>red-black tree</code>）来组织数据，因此默认的就已经实现了数据的排序。从下面例子中可以看出，它默认实现了在 <code>key</code> 上排序实现递增：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapper;</span><br><span class="line">    mapper.insert(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">    mapper[<span class="number">1</span>] = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    mapper.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">2</span>, <span class="string">&quot;Candy&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter : mapper) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; iter.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * &gt;: 输出如下，很明显的，它们在 key 的排序上是递增排列的</span></span><br><span class="line"><span class="comment">         * 0 - Alice</span></span><br><span class="line"><span class="comment">         * 1 - Bob</span></span><br><span class="line"><span class="comment">         * 2 - Candy</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，在存储上 <code>map</code> 却比较占用空间，因为在红黑树中，每一个节点都要额外保存父节点和子节点的连接，因此使得每一个节点都占用较大空间来维护红黑树性质。</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>两种数据结构特点如下表格~</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><code>unordered_map</code></th>
<th style="text-align:left"><code>map</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>查找</td>
<td><strong>快</strong>，Average：<code>O(1)</code> ，Worst Case：<code>O(n)</code></td>
<td style="text-align:left">恒定的 <code>log(n)</code></td>
</tr>
<tr>
<td>插入</td>
<td>和上面一样</td>
<td style="text-align:left"><code>log(n)</code> + 平衡二叉树所用时间</td>
</tr>
<tr>
<td>删除</td>
<td>还和上面一样</td>
<td style="text-align:left"><code>log(n)</code> + 平衡二叉树所用时间</td>
</tr>
<tr>
<td>是否排序</td>
<td>不排序</td>
<td style="text-align:left"><strong>排序</strong></td>
</tr>
<tr>
<td>实现方法</td>
<td>哈希表</td>
<td style="text-align:left">红黑树</td>
</tr>
<tr>
<td>适用于</td>
<td>查找操作频率高</td>
<td style="text-align:left">要求结果有序（按 <code>key</code> 排序）</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>源码分析</tag>
        <tag>STL</tag>
        <tag>哈希表</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>C++位运算</title>
    <url>/2020/10/24/CPP%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>快乐细腻的位运算，细致入微的内存表示。</p>
<a id="more"></a>
<p>该部分对编译器和操作系统密切相关，所以先介绍我的机器操作系统及编译环境情况：</p>
<ul>
<li>Windows10, x86_64</li>
<li>CMake Version: 3.17.3</li>
<li>MingW64 Version: w64 6.0</li>
</ul>
<h1 id="1-基本类型位数"><a href="#1-基本类型位数" class="headerlink" title="1. 基本类型位数"></a>1. 基本类型位数</h1><ul>
<li><p><code>char</code> ：在C++中，提供了基本的 <code>8</code> 位的 <code>char</code> 类型，也提供了 <code>16</code> 和 <code>32</code> 位的 <code>char</code> 类型</p>
</li>
<li><p><code>short</code> ：不同系统不一样，但至少 <code>16</code> 位</p>
</li>
<li><p><code>int</code> ：至少和 <code>short</code> 长度一致，在我的机器上是 <code>4</code> 字节，<code>32</code> 位</p>
</li>
<li><p><code>long</code> ：至少和 <code>int</code> 长度一致、至少 <code>32</code> 位，在我的机器上是 <code>4</code> 字节，<code>32</code> 位</p>
</li>
<li><p><code>long long</code> ：至少 <code>8</code> 字节，<code>64</code> 位，至少与 <code>long</code> 类型一样长</p>
</li>
<li><p><code>double</code> ：<code>8</code> 字节，<code>64</code> 位</p>
</li>
<li><p><code>float</code> ：<code>4</code> 字节，<code>32</code> 位</p>
</li>
</ul>
<p>字节（byte）通常是指<strong>8</strong>位的内存单元。但是在C++里面里面，说的不是一件事：</p>
<blockquote>
<p>  C++字节由至少能够容纳实现的基本字符集的相邻位组成，也就是说，可能取值的数目必须等于或超过字符数目。</p>
</blockquote>
<h1 id="2-无符号类型"><a href="#2-无符号类型" class="headerlink" title="2. 无符号类型"></a>2. 无符号类型</h1><p>无符号类型相比较于基本类型，只是扩大了表示范围（把本来用于表示负数的范围放到了正数这边来），使用位数不变。</p>
<p><code>unsigned</code> 只是一个关键字，用来修饰整型变量，不能用来修饰浮点数，与之相搭配的还有 <code>signed</code> 。</p>
<h1 id="3-位运算"><a href="#3-位运算" class="headerlink" title="3. 位运算"></a>3. 位运算</h1><h2 id="3-1-移位运算"><a href="#3-1-移位运算" class="headerlink" title="3.1 移位运算"></a>3.1 移位运算</h2><p>移位运算右侧的运算对象一定要是<strong>非负数</strong>，而且必须小于被运算的位数。<code>&lt;&lt;</code> 或者 <code>&gt;&gt;</code> 移出边界的位会被舍弃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> bits = <span class="number">155</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> offset = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// &lt;&lt;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *           1001 1011</span></span><br><span class="line"><span class="comment">     * 1001 1011 0000 0000</span></span><br><span class="line"><span class="comment">     * &gt;: 9b00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; (bits &lt;&lt; offset) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// &gt;&gt;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *           1001 1011</span></span><br><span class="line"><span class="comment">     * 0000 0000 0000 0000 1001 1011</span></span><br><span class="line"><span class="comment">     * &gt;: 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; (bits &gt;&gt; offset) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">short</span> neg_i = <span class="number">-308</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 308:</span></span><br><span class="line"><span class="comment">     *  0000 0001 0011 0100 (原码)</span></span><br><span class="line"><span class="comment">     * -308:</span></span><br><span class="line"><span class="comment">     *  1111 1110 1100 1011 (反码)</span></span><br><span class="line"><span class="comment">     *  1111 1110 1100 1100 (补码）</span></span><br><span class="line"><span class="comment">     *  1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">     * &gt;: fecc fffe</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">short</span>) (neg_i) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">short</span>) (neg_i &gt;&gt; offset) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意！</strong></p>
<p><code>&lt;&lt;</code> 运算符会在右侧插入值为 <code>0</code> 的二进制位</p>
<p><code>&gt;&gt;</code> 运算符行为则依赖于左侧运算对象的类型：</p>
<ul>
<li>无符号类型（<code>unsigned</code>），那么会在左侧直接插入 <code>0</code> 值二进制位</li>
<li>有符号类型（<code>signed</code>），那么会在左侧插入符号位的副本或者值为 <code>0</code> 的二进制位，很明显在我的机器上是插入符号位的副本。</li>
</ul>
<p>因为有符号类型运算结果的不确定性，最好还是对无符号数进行移位运算，起码右移叭。</p>
<h2 id="3-2-位求反运算"><a href="#3-2-位求反运算" class="headerlink" title="3.2 位求反运算"></a>3.2 位求反运算</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ~</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1001 1011</span></span><br><span class="line"><span class="comment">     * 0110 0100</span></span><br><span class="line"><span class="comment">     * &gt;: ffffff64</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; (~bits) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意！</strong> <code>char</code> 类型的运算对象首先提升成<code>int</code> 类型，提升时运算对象原来的位保持不变，往高位（high order position）添加 <code>0</code> 。</p>
<h2 id="3-3-与、或、异或运算"><a href="#3-3-与、或、异或运算" class="headerlink" title="3.3 与、或、异或运算"></a>3.3 与、或、异或运算</h2><p>平平无奇，正常运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> bits_o = <span class="number">132</span>;</span><br><span class="line">    <span class="comment">// |</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1001 1011</span></span><br><span class="line"><span class="comment">     * 1000 0100</span></span><br><span class="line"><span class="comment">     * 1001 1111</span></span><br><span class="line"><span class="comment">     * &gt;: 9f</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; (bits | bits_o) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &amp;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1001 1011</span></span><br><span class="line"><span class="comment">     * 1000 0100</span></span><br><span class="line"><span class="comment">     * 1000 0000</span></span><br><span class="line"><span class="comment">     * &gt;: 80</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; (bits &amp; bits_o) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ^</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1001 1011</span></span><br><span class="line"><span class="comment">     * 1000 0100</span></span><br><span class="line"><span class="comment">     * 0001 1111</span></span><br><span class="line"><span class="comment">     * &gt;: 1f</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; (bits ^ bits_o) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-结构体所占字节数（位数）计算"><a href="#4-结构体所占字节数（位数）计算" class="headerlink" title="4. 结构体所占字节数（位数）计算"></a>4. 结构体所占字节数（位数）计算</h1><p>结构体所占字节数（位数）的计算包括三种情况，分别是：</p>
<ul>
<li>结构体内部仅含有基本类型 <code>double</code> <code>float</code> <code>int</code> <code>char</code> <code>short</code> <code>long</code> <code>long long</code>。</li>
<li>结构体内含有结构体</li>
<li>结构体内含有数组</li>
</ul>
<p>不管是哪种情况，首先要遵循的三个基本原则：</p>
<ul>
<li>整体空间对齐原则：整体占用的空间是<strong>占用空间最大的成员所占字节数的整数倍</strong>。</li>
<li>数据对齐原则：内存按结构体成员的先后顺序排列，每个数据成员的对齐按照 <code>#program pack</code> 指定的数值和这个数据成员自身长度中比较小的那个数进行扩展对齐，Windows下默认为 <code>pack(8)</code> ，Linux下默认为 <code>pack(4)</code>。</li>
<li>结构体作为成员：结构体成员要从其内部最大元素大小的整数倍地址开始存储。</li>
</ul>
<p>根据这三种不同情况，开始分析计算：</p>
<h2 id="4-1-结构体内仅有基本类型"><a href="#4-1-结构体内仅有基本类型" class="headerlink" title="4.1 结构体内仅有基本类型"></a>4.1 结构体内仅有基本类型</h2><p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st4</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> c1;</span><br><span class="line">        <span class="keyword">double</span> d1;</span><br><span class="line">        <span class="keyword">int</span> i1;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(st4) is &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(st4) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: sizeof(st4) is 24</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st5</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> c1;</span><br><span class="line">        <span class="keyword">int</span> i1;</span><br><span class="line">        <span class="keyword">double</span> d1;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(st5) is &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(st5) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: sizeof(st5) is 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>st4</code> ，首先分配1个字节的空间给 <code>c1</code> ，然后到 <code>double</code> 类型的 <code>d1</code> 时，取 <code>min(#pragma pack(8), sizeof(double))</code> 的整数倍进行对齐，这里都是8，因此需要把 <code>c1</code> 后面的7个字节空出来，然后存放 <code>d1</code> ，到了 <code>int</code> 类型的 <code>i1</code> 时，仍然选择 <code>min(#pragma pack(8), sizeof(int))</code> 也就是4来进行对齐，前面已经存放了16个字节，已经是4的整数倍了，所以直接存放就好。最后检查整个空间是不是最大成员所占空间的整数倍，这里最大是8，因此再空出来4个字节，凑齐到24，完成空间分配。</p>
<p>对于 <code>st5</code> ，和上面正好不同，分配 <code>c1</code> 是一样的操作，都是1个字节，但是分配到 <code>i1</code> 时，需要空出来3个字节，再给 <code>i1</code> 进行空间分配，到了 <code>d1</code> 时，前面已经是8个字节了，是8的整数倍，不需要额外扩充对齐，因此直接存放8个字节就好，这样一来，它仅用了16个字节就完成了空间分配。</p>
<p>由此可见，虽然两者在功能上是一样的，都包含了相同的数据域，但是空间的占用是不同的，这也可以产生程序的空间优化。</p>
<h2 id="4-2-结构体内有结构体"><a href="#4-2-结构体内有结构体" class="headerlink" title="4.2 结构体内有结构体"></a>4.2 结构体内有结构体</h2><p>结构体内有结构体，这个问题可不是很简单，具体计算过程如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st66</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a2;</span><br><span class="line">        <span class="keyword">double</span> d2;</span><br><span class="line">        <span class="keyword">short</span> s2;</span><br><span class="line">        <span class="keyword">char</span> c2;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st6</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> c1;</span><br><span class="line">        st66 s;</span><br><span class="line">        <span class="keyword">int</span> i1;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(st66) is &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(st66) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: sizeof(st66) is 24</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(st6) is &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(st6) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: sizeof(st6) is 40</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s offset is &quot;</span> &lt;&lt; offsetof(st6, s) &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// &gt;: s offset is 8</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i1 offset is &quot;</span> &lt;&lt; offsetof(st6, i1) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: i1 offset is 32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在结构体 <code>st6</code> 中，包含有了 <code>st66</code> ，而且它们都有各自的数据域。从输出不难看出，结构体 <code>st6</code> 使用了 40 个字节，而内含的 <code>st66</code> 占据了 24 个字节，那么剩余的 <code>40 - 24 - 1 - 4 = 11</code> 个字节都哪里去了🧐？</p>
<p>首先看这个图，如果看懂了图就没必要再看下面的字了~😋</p>
<p><img data-src="https://s1.ax1x.com/2020/10/24/BZsf4H.jpg" alt="内存表示"></p>
<p>下面仔细说明：</p>
<ol>
<li>分配到 <code>c1</code> 时候，系统给了它 1 个字节，放到了 【0】 的位置，此时总共 1 字节。</li>
<li>分配到 <code>s</code> 时候，系统检查 <code>st66</code> 里面占用空间最大的数据成员所占字节数，<code>double = 8</code> ，那么此时产生偏移 7 ，把 <code>s</code> 放到了偏移为 <code>8</code> 的位置开始分配，开始进行成员空间分配：<ol>
<li>分配 <code>a2</code> ，系统给了它 4 个字节，那么它占据了 【8 - 11】位置，此时共计 12 字节</li>
<li>分配 <code>d2</code> ，此时 <code>min(pack(8), sizeof(double)) == 8</code>，那么把偏移放到 16 处，<code>d2</code> 被放到了 【16 - 23】 位置，此时共计 24 字节</li>
<li>分配 <code>s2</code> ，此时 <code>min(pack(8), sizeof(short)) == 2</code>，那么直接放到 【24 - 25】 位置就好了，此时共计 26 字节</li>
<li>分配 <code>c2</code> ，此时 <code>min(pack(8), sizeof(char)) == 1</code> ，那么直接放到 【26】 处就好，此时共计 27 字节</li>
</ol>
</li>
<li>现在分配完了 <code>s</code>，但是还没完，需要进行整体对齐，把到目前位置的空间进行调整，调整到 <code>min(max(int, double, short, char), 8) == 8</code> 的倍数，也就是 32，因此偏移此时到了 31。</li>
<li>分配 <code>i1</code> 此时 <code>min(pack(8), sizeof(int)) == 4</code> ，将 <code>i1</code> 放到 【32 - 35】就可以了，此时内存共占 36 个字节</li>
<li>整体对齐，把空间调整为 <code>min(pack(8), sizeof(double))== 8</code> 的整数倍，也就是40，也就正好得出了最后的结果。</li>
</ol>
<p>在上面的示例中，可以看到使用了 <code>offsetof</code> 这样一个函数，其实它是一个宏，定义在头文件 <code>stddef.h</code> 中，它的功能是探测指定的成员变量在类或结构体中的偏移是多少，例如上面的 <code>i1</code> 偏移是 32。</p>
<h2 id="4-3-结构体内有数组"><a href="#4-3-结构体内有数组" class="headerlink" title="4.3 结构体内有数组"></a>4.3 结构体内有数组</h2><p>数组就很简单了，它就是一个一个单独摆放的，只需要看成是多个单独的变量就好了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st1</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">21</span>];</span><br><span class="line">        <span class="keyword">double</span> price;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(st1) is &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(st1) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: sizeof(st1) is 32</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st2</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">double</span> price;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(st2) is &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(st2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: sizeof(st2) is 32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子之所以是 32 ，是因为需要是 <code>min(pack(8), sizeof(double)) == 8</code> 的倍数。</p>
<p>如果改成了 <code>pack(4)</code> 那么结果就成了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sizeof(st1) is 32</span><br><span class="line">sizeof(st2) is 28</span><br></pre></td></tr></table></figure>
<hr>
<p>🤗🤗🤗，开心，这一部分学起来就相比较于类那一部分开心多了~😋</p>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>C++实现K均值算法</title>
    <url>/2020/10/11/CPP%E5%AE%9E%E7%8E%B0K%E5%9D%87%E5%80%BC%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="啊偶，密码不大对" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">哦吼？需要密码才能看~🤔</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="6da6e45f63d8fc6ff32fd8853725cb4da4eb635106886448af8d42a03e65c0db">7b3bd1fde9832739734f00397ca2e503236798caf73c3112144e6de20c38d526939d7bdae570ef1c1f5a9af3dfcfb682d5251057f0fe0c6d5c7a9e0fa0c09de1a16cc0896fe5183e27a4520b6c902f89608efc0abbb37f8d0d8a4436b9ae1d76f512dd45d9b3f1c7812f4b5065888c94100306d7b44c82ed26aed33c33c1dc1f94131bf92357bfb9172e4fd3a260c35d0c35150de3b87f3c2a4ff1f87a407457381e0a68d1d1dcbfb2416e1f73e52b8647db68af63f25ca8cb57929a084afa530fdf2322b92f2de9f48f47e1aaaaee288e2835fbb04c73dff96ed9bec9bb586c8af06ac68a5437474a4be527750f3cb0dff64cd233b264b2fd8300903f9846f882f3e5a1fd6ed8dd29343189b55972189bba5861a7834045ae813d5cafe2fd63380b5fec1f4361ee7cd9b0af9b8d4ebfed669142712d24bca5f06baa1b5b52dcbece5e04c24495f3aa3825b1f39684fe1b8a58011bb845ff0b26032cbb289a9324b649816a3c1d2123e30047ae629f5e2ae4d0134531827bcd44887e7e3c7dcc3e56d6eb2ede9d98339f0331d1e149fdce4eb26b25d4a87eaf6627cc630aea5079faa8ff05f5a285f5e8b24e06909319ff9df5fb3cadbc4cb6d3261641cf48fb062cd01195979552b24200c7361a845bdcd845aaee7d22b2927961c9cda8d5bba441cc9201a0bed1578597a0d2b01cd003c13975a316f5691e54170590678ee61a99b4205b6648c1ee0fdf4e60c5ff2443477140bbe333ecc6ddfe83743d7461967b0b350faab453ec3233f1da2d8e4ecc370aef53d6afc76c2db6afa69e1a4b1f7c64acec2bf38613f6d3d4aa521773d2272c98454ab12683602a1d869b522f939c9dc7846d88da0ae98a32e0d5b6d6fc8efcd2c5a4cae8fe7e9a66dd3272a5003b33705abcfeece0ef1638c112388dfe1bdf411e3001924b7e6858fbdcaf476bbab72849ebd8cb90aeb10a0b072a6e48aae8985bd9c62596e68c82b5eb9506ced68dee3ccb97f8fbc1a90f7c84b4ba967430af5d274f43c92594e06ed128ab9fd670b739dc8d373c498d3a7da6db1ca64c44cc43ef4257d749a2385a93846a9827bd551c1fddffead081eae62fa6c1fa74c338f373f06722dfc202f199e1a3dbe3db0925142df87da60cfb635da47f7077ce85aeaf4ee7590330d52459d71f58ec6329054b04a37536011147f6f2ded8591d4c4d39713c34cf07cc6b492a6bb08b138ae7df85396fd0f3b3ed9753eb73615b865137832b4e852a645a386dd9d0536ae08a1922c845609269e53667346bfed527d76b0c504f7b50d881a8c086df41879fda387c6e0cf12252a33399f5f45d363c7df57f11099d180b5eeb8e2e835602322db9ab9fd03a5a77c98b4963e98fe6b7c0980b9842501fa7e2c0fb08a2b4792aff3d5eaca248ef450b05140413bfa12eb2c1c54a2ff4b01ca65a6db0b03c343ec6fed01d281107dd9ec9c0ded884797fa562b722af5c3bd2b615bb79e7898ba3308d3c8189cee047ddcdb95f4ae48b8c856f54c4684f1c8dc2396d77d469423e7e11e27834fd5fdd28ffc6224637456ba2372934b328593b395dbb913e8734dc5327b785961ce994a1eb40c239dcb8d184a401153e0e1012e26ffc9d5b0d6a48c2bbf109929b7741ed1a845fca10ff3bd4cb17fc66430880d8c992bcfc727837b5b5f27ab8bb70a23ab3ef9625dfb9fd9c742d70e67a4abb6cd1e7757cc4fe8eb02cf7f25f8239477f0470f00fcf2dd59f2b86573624e98be68c318fb967a7b8fcf64101971b2cd7b7bb6f74b123dfad79dcd2d22a683c11182948362ba7944da34fbc636f740c6f3876eba10c42fb1f6be4459a2a95c9f7aa17be2ad19a2c24da0984a8d26755192ab01d0a349ee3f7215a87f9af9e78d92bde1a90ae66ee9f736c390bd99723735e2a8e11f2de87b333826861a6e91baafa20e31af1c040c22ab1bd6941e0ae7184d87edf536f593e108f63b6caf3ab4e0ebccccb12b252ff0eb4226cf7eef7ccd4e622769f0319299d6088be7a8ae3fa1be228735c47c81137dedaf810b0a173b0621e6a70057e9cbbd493e306c8d10eb127da9b0a42f3c6b3c9893884e7c8091928e541ae7604f2cb8dc7071da49769bf444586fd1b7c584421548ae971fa5d38ccd74e2b703bac252077fe639b1a04a7a514397bdf2649579fd91ced28f1a110f11b90d3986ddd8df069505a5ed78b73822ecdccea179fba4d39c4717b98ee65d2457e7d032abbf638ae90d5c61fb6c915def6c9e3d5a2732a9f38e1676455419c9857040e0cf89cefbae869c305aadef5d012d2064c16b113746433a920664d01a209115a190e686e0a7d486b5f868bd9daa700a92db85e67f01725c6345802ec2623c9d8609fd411f30bad358d36e26b2f03569fa65f35c5a8ff98ecac3b6519a6de238caf6e117e2e8f786637f2a94c4bcbd5be3933e2de080268157acfb9db16025a9c1ea045546ac4a004866fe125a71472c7e3bdcf6c7833b10ace50a820e05c4edaa5c098e9e49b2025631b34e27ace6760509bdfea0876c0f161ff0a20a7cc3edae30fb30ab51b609df91eb86c6f302276a47bc507d6c0f0d690a7e3203c80ab28ee9d409d27c700e459ad373304d15d09eea2334accb35c1349ac9a4affdd39c3c2c3449338d1b0d8828c869263efd612fbdd9517db1fda5dd30176c886e730ee6a12cc0a3a2bb8ec98b2fef8352880f0565da3ab8fb0f255cb0cf65bb0f1cd88474541db51ae8358fdb11cf46eed3de7a6d3425298ecca0f2c234eedda9ac4ecb0d5ff6d150f7bbd38100ec6f2b25cdf812ae21c4e5ce30e89e6e9d2783da446fd8fbcfceed09fa813907c363e1ec4d6602a8555e25ddfe0a01bf8c15e63f5a2229429c4a715f54cd59538b72121cb9af3bf5d025bb01d04858baa246251005bfff950940cf5c3ed03ccf15bd9bd3df815b5b4e3cc5a53e178ac9e5db2e5b165a1001c10983dec6ae98c2848c6010ed4ef56d8c93406b4c01cdd32b6f655df40b0503d9ce08ebc32fa5996593e2417a1eebee592b3f4964428d3d36dd9d5315997013e101fb15a4b56b63ea43b8e9c260cab2b1f0372e35f093431458624690a06fd03f7e459eb5bad0a2e2fb7e9f8cffcebeff23aa08b539ebd1d440846f7c00d6c749471f66db4e079960410bc4c5202f0f3f036f6a9972a87feba35fdebd09061d22067c447fa7fd7445536d2cf117fae093ccf742335bb291b1cb15a1f7f05368ab801d73285d353aa4c5f3e0329ea9361660bf112dbcef0e2b0f5d2bb473dfd465195cb21fba44645735be78c0d74d46dd549a919629e311cdf80a9322dc5612431d1519aa71d7370c615c9e9916c1227c40f8edab237ded1c15dcd906db3c938e2ef7b3a014961696f227fb3767a6f32db27625be3ec4dea5267283142fd41ca7a291f95372c882dd5d36e8202328a34a37cfb453f0858dab9d92949695085949259ebb9c7fbdf3bb29f98fce02e52f2558caab253eeb61fe705a742e23a36d08f7e247447c4dfb5c1164c0f71d97cced6b7b57f4757a027cf2b2c93bebefd2b1c9ea8f679f04b2e15834df9ddcb1e9d865896b256562455b5d1f54ad975ddca7802307f253c5e89456856e36d92c016da99782454ad23b765490c6bf9d8c02f2121f17e4815523f80f1b1b268cb7e20e0115b46ae8b690aad16b74a6509d8da8f4a9b5f501fba639856f44fcf48bc5513c308ebf33743ed32bdb997b8608b0fe77adcd5d8c4d919be8460828c4bfe542c4a6c7a6fa39ac3df600856297f9a549cda654119365b03a62361459e0337ee98c4b104e40e6b59ca34da1fa08b4b4eff74d5dd3c4c87b043b518e9a48fff282499539d58a154eb2b545a65acd6e133b96d8373537f62e09707890bcd72c5ee66c5128e2c1e81eca3286060f1bc92b2e67c3537b83fc365ef0691dc43daa27d3c56246192a209b32825c8563406ace8b9d43d0d7f0c1ea44d38dccd8796eedbb37aa22b8fcfee1d9457a1fd5f35b4c179587453d30a9464cbd16b39f8735e7fc46107b92ca48adb21e2db84f37f1bcfe45ee6844496a18573879b0df4fab9cbdefbf3c1abe2fac6db2688be9b46a2faf29e9a39021393bc9e78375054c06ff8ad3c8627588ef7ede4a93ee8f7d0a700a5c73c1db8530b3b3fb1c6e29f9c3461c25f53464a29bac7e05a70a4466f1459ee6672847ff01bcf8861803d53a59928a2996c4db0158affee3914334ef1eb54b7d88d92aaf9b81f8e453daa38603613cc0dbf67b1fbd2a5fa269e056ab6f43462ed7bd00a3c33dfe10ef1ae913c5b5362592e43080276a4c10ad0dc6d1d243851d9f5f954c53ef244739fd47c38f225444650487d0774559c64424ca26e2c4a59c298e816b3a2f34d6519d38968b8342d0453e8e096230d24f533ddb36381b83f386fffdc736a679b78ccb62f66f69ea28792fdd4bdf3cb9b592fc441a6831bdd9028de18d8a19794318e12de6c0bec3e3bab333ca34f5028a77fc5328bdeb5b8a805b638ff880c7272cce722218369d0c36f640626a7596ac30585e844a92a32f1c83a494e447758273ae31355efc28ec7b6999ed613dcde6c09bbebb4afef9e433dfa33db2c3ac48f95d941d8418e0ba069b699fc874716164131d5b8e92e6d9dce1cfd90bd12378bc3391449fa064320d42893098928438185ad9ab75a25d2e03a7fd662b00ab4563b2d601f8e793cf2ed0365fb7996b11adacf7d20a78489b68cfde1bcee1c99af1888818882e20b89b094fd9a638fd60fb46d4cb10a1a38678e4f4f8aaf8eef7cd1af3a92dbab2f5ebef46f7c29168f84b72d3a5b1023d130e928d5e5a2466b393b4232a2db8f9807e952fa594c8ccce2a2e1bf52fbd9236eed8a0d03144d5dba795a40a3f5bb83208dc167a8e94378aa1986945b4d8dd2e9bb789fedf0aad03e57aa569c880e6e7b24e435d3527adfc02ff3b2167565b7d93994a5460a34b3453e51f40e0b9dc9673e1b1d15143d8dc823f76c560f2dd2aef6d32d66cc5da9c1c80f28869c5bac602ccf546bf6981a4b55622f3dd19d5e06717517dda4f1b629b2fe7799e9ed7c6bd899d4ef521c658a802efd890633ecf33137b00d477d4de26a53412578fb459966f04bddc90b981f7e02aebe95823f91421386625f9f3d05b0457b8e6b6e3f310632c8ffee2db8fe0acbc6b22883e42e2682aaa4d170b3705cbf8099457f42e5040544e13196bac6080203e43d4df641dfbe10282bde1a05b175faeb29e973708f4d03a37c2565df55d92b8e8cc7bb8351d40995e6030ad6511c068008d53c41b455895ac7c85e0af560f0efbf21a6b1df8b0d4a6964095ba0772fe95e5d2352fb2c395620b1859caee2e897dcad0928ed1471436dab561c6d5de60b0a6d04f99aadc4da2cb89e6c503f88ead86cf3c7090466f443c299e6fb65fe7619f76af884598d2f5b5a0f2779a8418c2f84c383668e1932efceb32b5e4913bc5bf46ccf01cfa410e499b4435c0059a59768a343463a70fdf38b50e4bab8406597591fe0e11e375741bf739aee63e35b6fc24dbd27cadebf72392d15a562065cf9af50cbae618270fc65ee806df93ed54121b830235dab049dbec34d48c793977e92b84185730c84d8690de45c8285936d4ee74d932d346b5d7c09ea170b913d39251e790a0b13a73462f4bc107442a314b9fd7f363850e6293d720497156949c400f698aa37afcf2a0b2a87da289c48b66fd4d53acdf46361feaee4127a3bf2a981690f892f6cddf8e8a96b6a28f59437dda8f860f3fe3a5c0831ff836bed4b9fe98c6373944df00933dc6d3c8718f097e925e439246ec1fe16e5c01ea6d8e0d924f99322b2ada19695847fd9f3fa0280338abaf1fee18d74a897b0d4693e50023e4206111a84a704a919ef0e0f34b1a249a5d246fb842d5e939f6e9929268fd92b023fc9d2638011da5bab685844518f5260ba5b5885cbb46c62fd5e115709225f9c4143e0e15ce0ab804e7a3dea7459883e1137d3d56c88984af4b50b29daff5ddf026733591449706a462d222c9320af93fddb2730375f368677c18e402a9dda0e585ae5dd66e7bd30b62570bf297a7053c9acc066372dde8033ca6752f5190b7f9ec68cb58e6ebcdbc9c3f06d12cb2c0e6c10507e8f448bafdce3822dfc6119fc520a7391059bd8dcc818602d5705bda1d4b55f535b542293276effa5e50b0ad630f3ef92d36bc5d562f6d06c501b800c028f084e3a9ff4269a040eb627324a05be30fd4ade0146ba9c1ee5a28716fb9c7cd04ad26603c665f1f18f42840a561fe55841c3c0453f620cd3ca938a36068e00aec1b13481d4db4f934c367930ae12be5fd346115aad0c43adcb75d6d37f2ef48fb931a82604efda9fd48647a9c16b2aad51b1b93065757077fdaafee7464c00cdbc5a46155a2fd9554b695fd0f6bb8a4efa95c122a84a376967531f33523a0c0eebdc148c84c405272208fd9fcebae6cd48233d40c70fe8b71155505193663cf6b0943d0cf2eb126ea08d614ad77eca005a0fe569f5a73b11159125a8a44a9d92de41ececdf45824cda6cfa36f12a8628c18888ba1a1d40ef1dbab12165eb5d32e582d97fcf1cac22906a073175a08774803eec469ed99fde15cf045b5789e7892423fd082e7d872d51bfbe041c7843359f2c93a317a4e5d435c3f751a694f16374ba4efc5c0de08428f89382b428d776f551001690e68bd35d5dd0d5a35eb5fa7669cd17bb422e77d2fe22d85c7fafc414d728553628ae509805bf1be383f50d7e9d730251efaa845d01ea1ea240d102ab03eb1a0a74bc7ee42a04878e7970ef20f2f69baf244a5318b319d2ba1e1aa8b70848e38372ddf525ef125a5f4cb6046c887a4a062cce39ef561e105fd627445a2fcd3d5ae86f3c49fff35e938ac60feb9180a412b73d1924eab2068ace9384a886a96b87772a2a86b39a29c19aecd6e85730f659b28092e8c8873ac7960f41dbbe5adec0627dbf951d5d9ef872723c971596567ef0e6434118994f9b81585827570332c35b9f2f9a44ca1af10e6994634b3fccc30682f207ef23419d699690663467c95da44c9ea0f5726d52b67b01d8b1a3de2f7300f1dbc948b42a22e9143a7fd6cfa0331b1a01bab787441900a70bc0efa767783d1276147052372e8f27fcf404e4e8acbcb04c757e0e878263a22494a340e8c684bb9b82867d5d2b886339e758d73446889973cf035c99e42b028af93f48db159fef5b0857ac005bcf4286a560e4b89c871efe02a4659101585047057340da0b3bb759c285c127fd113cafdb0a688e5e524cad18aa43320661a99d1f9134c8c1e489e7aa3517028bfb9b3dfca8dff0208707d0107ed80ff9c55b62e4511170adac7f940bba0e723da8730e94c1b2ac91762babfffe652e4c3120c224b44418fae2dc36ec571738502db6a43f649a9941efc6ad6edbb65fa204ad76c8ed1e4d01dbb39c6b9a9f104335ebb6dc95891f4fadf52f1d3fb3a77644324ee3603ca55e10c752594a9fe5c2ed1169d9d45bad393816b1b01efd065f01e575ee75c22617a7d099270403a5c0199dc333bc9f02596a8eb7ab8c25e5920ab46ed83a05842642e09f01ec0e69d76d7eed26b0ac1387b6d8d3decd8c34d8c6b4c2f65dc32e25c4db5585427c91b6e252b36af83f688aa26c0c0f28a7ca7d55977b5c209147ba6f37e3399463ad927e3ef7f2c54690fb6977c3f3a16857fadadd81cacbf05fad3c5ac2623ef889c40d56f8340ac994f3845dc053aa842b06dcb6afab61f8a5578a66544ee95e3177362a74c95d487d0ac63bcf0a602af680b0bd23cf2a3c77c13ea989561c5ba04010660b3aa6c72753b77bdc2ecf2d1e9eac384eb078db4f62a718e8c418d9a9d8152a16282588344901bf995c84bf870d5f421caeec4ca260352c66e6ddb43c1cd464318e5a513cd4732a4c716153966eb0b6aa90476c30343e41d0a9ddf44c0c0ea3210b48da197e38fe9e885cf22118d4907067a153f6da6e625a5e4ba61781e33c19c8a3da7c7a048a10c97946bb933eb7601206bbeb6ec3839a27efdeecd1aa6f98e5e2e04391753c91da7296fd471a7ef6403eb77dd5046a6c30eb6c1f65e27a183fd16b80117ceaa74bfaef8ab7c30b3dea2db466d4e41c3a02f6fa3aaef6409a85d6344ae81f2e937d366110897d8a9aff3147f2484b7c9f30cc554fc66fa52c279ba7f6de819bbbd0311e5c049b29394d4d0ff4bd25f8dfe51783581373010efa504c9242be00fd86a0e87ae9578a378aca2a29ef90d8c9dbcdddf519aa9d63bbc1a27a0521780ec14ecd73f5e402163756ddf8ff6ff91b65d561eff8a692637515603e3b8880006fe01f3d3e20927140fadaea1b3a7e57005dd0f73f9cd551dddc370b48c211dcbef59d69e702e7c0d95ee5ad5ead448b7d0a7ab358505ad4c2b562c79ee628a69833e690ccb7fb50f54c5e33b343b9b12e69961e5aff17a451e842819532cf5b0a59c06b6fb4797571d586275f6f38c0d36c166838d0f477d32eaa410f31a441c50008ea577934736357748e9942bd8002dc82dfeee7016e8d467c367a1734e040655004264d9b3b30ea319f9666df3adb87f02e666ca848c74d2e78c548a4ee0d6e74bdbd42361b31c5978122ad96e19da7cd6b2887a3ab0c3f99bf2c8661d7933417cde0449b125ec0d2a54983c58229f73332dbdf29896de8a59f994a2caab7ec598770a36578b126840eeaae84d1d8934b2485d97e7b6e9c81f3d107b4899b9276deeb19d8f8cbeb2705b6198ace729d0afcbd46ea9b0f1e2528a07d6f217a4e19ed2c27117a47f04289e6b57022ce1341c13c0fc64b4dbee97b866714334dfe989143010da5a291872c9bc8c7319f14bd36729abe6a7f5690fd211197c279c526822c89e7630c5bccfd23c76db3fe55319fb4a4b411a5991f926ab37a46c93eb53932db421ae061da0c9d487dbf3a8c8674adf0f5664c681095866be6283a2677472017df0f2230315528b657e2f817f1bbe143cf533c983f6e2cf45edb2e40d90af9b49a66d6c50293bc0847f5c5670e5a07243c4ae292098773570f97015cfd4829473e2e3a2d9766b043a2acfbcf000a23608f7380b4145ea1fd5437541cf3e72e9605d59b9962181ef5107619f97f3f5c0fce4ce33fbde27be7b0bffb1b3dd15cae138187352bdb9e245d7353a3d6de3fc6b2264507031cff9187b33dcf423fe5354f4eff23f34de4d39bc515c9060a1d1ac6ae20f98cd0f9d579f4ad1e489bbab49b8351103a88c8165d5e5894d7a9c33308fca398abb5a065ed4bf9c4e8dd19671b94aacd20b19f256a4cd85a5c7ec69d3e6cf2470a913d0fe91902eb4adc439d822efc5fe7ed8fdff96445b11373ec1ca0bd942b97394fadb0ad2e7306a02c19fea7b7eb9af927a6d8faf042b102c0fda8a74ec4f4e46c5e3cba18dc89afcba17bf0f586a3317222954a307439f6125d4b17b6eaff5251fb056206365c8c926939e2f14eee9d31348fc3ef0b28c27570f05bb19beb58f0d5e45e496a80bda19d387752dbaa5dca7e6a146db14332e61d2fc5832afbf6e4dd0fb84351533992c2ff4fe70a12463355ec899052ec842ca7d143d0748d350e808815bc88662f1dbdbb6f353b0c5e59cd97dbee4e29cf2ac72053f465db34253b16c34dbff374eb1bca31ee8021c9e8fcf396c6c403889ccc01cce60f5e55ce9d53891d6cf4f47157486f4555988d410c3be9cf25c8745adb7d76a98f1e646eda0412de619f5055e5d2f7943e8a43caf2294df6b9be27c03780511d11fe438582e734559e186ddd2da64d9df14a918a26bfe9239ad5e43cf9c525c73849e7cde6b3f061f5ea1bc901c7cfbfc2513f8221a49e7c8be1471aed2196d0d4fd9eb989f74e44831e071a317a735eb8219feb81e4526d10d12b6059189a932af706ce62fa37deb9b38818492b7dd93c78c1ab916ee244427648a3a81e1f8033b01862e49de2e29219ae7d08dbfdfbce79e8d8774c0ff7c3195dc285674f96a0f84d729c57308f112c770782b6e780845738ea59fba567d316bc885f4bbbc9e93b246bf6e6bad80b600114273850220e3fd49ad1c504a9faedc263b1d14d7f99254974e8345e4789dd48d2429290f50690aa5b185aefb5561c4e2490c9aee6820c5c308144c0e8373d351a6365c57df130d85307c204a18305e82afb2854f4459f3a80bc94375b0a091063076fe4d10db64ca2fe33304fb54a0a112b824e8449f38a4b96223305c121393f2930176710f4ae406a12ea122f376ce67ec31e9806a87a1a71845b53d1fbb5a5494cdc67e0f178b19a6a855d982f45710587d77a3c6cb03567e2bdf507120911264366532bccd9b297ce1308bac49578c9881465c50961a1c0ef0ac70b4150228f556da0fd0f6ea13be8734a17d03693a3737a19a7dd942f966c0c0a2f8689906ab6191c3d410f6311feb84ffa843a103764bcfe9234318d39add049f48c2467eb5e304fec14cd3f6147445021e3d4dfff86f3c250d2cb4bde6c611338c1078b0515513dc6e923d4cd749cf1313077dcda086467f3fb3f9928d8b08291f5bdd3f6366275cef82ba1e01aad32b9d68c394a16096db9266e99134c19fb4796c0633ef38e1dcfcad6f3c12bf6686d46d63cc3f8f97bb0863a8037741ffe352059f336e882e85979ef3408b2eb0cd3c4a0197c43a396c679a21e918d27a0acefe4145c5ba7b0305b8fb13d32ef66392be9dcb511c0a5e4b2adc42ddda18381c20af2d466d8ed53b88a25dee446454547a2ab97707d00901c86ccea01bd16b7854efcd8a3a2b86ff3bce36ed57e536e7e3a344f8c6d8cc6a821e1535d2e3f27b6514dcd7c14568627cc49de289434c04fde00846b2126da92dad62cecdfb84cee247c63470a2ae6e89a5b77ac2428436f730799fcc20143d6fd0b7dea3fd10e3671dd6b6009e9d8282223f1056993cd6fac899a53dbb2aa812897b0d07d78d3d19eebf8151f3b3d1ca879e468c76394c7917e9e7e4a7215937a8c242ed0cf07d7497ac4b072e92e75d9e873932a530a911f358abac99d589f81888f0a1cb0ef362d1d7a2c4a1ff0039ecca357d914f5b3e1b97b02de52b630b35b01c234f4fbda4c5f609e7fdc1d073e2f77ee3a0e961f1d7fe6ba9f393b0618192e97bc4a2d2f51fbb24fa07572b34424b80b5f93ae3c6e2e326f5acadebb71081be23ced27bb149c55b3ce1f7147fc029346dc86d3cbdcf2a056613198944f9a9379008608adc6dc4cb73fcd679f355f76c412653e9fa73d08f11733bd16846ad796e7b80382f4f3a0ce51d9c9e86f146bcc545a602c170ec9281ddadddd60b33b37a29964efbb40bf4c86634db5972e93ef697c5d1c9d0d2c35e11058b757a99f984f27af16c89fbd2df77344b581d20097add2bdc478e2f92e98efb217ee174d0595c61171d3eeeaf0b36dc3219ea8c86d0bec50841ab98ca5b7e0656fb1c71717cafeb101dadbd684e94a48b562bc227866b1e0c1bd28efd3534aca3dd7561752d74e2e30f3b74dcc0ae688303589e8f948d5bec04a38481a195894593317aa42735425e3ce37926b686a8708ca48757a9d46e575d8aef1357da8f91a219eef4583b7705d6ab6c1638ba0351890c2909c27d17729be02f23387373994a13c5c7cd99ec738144027dcd7445622885c7aa4fa820bb88c0da498336256af9058391c34751eb4db9e50014929db2dd9c2920a1532262ff691d131844a059f5dfa4fc33f98495fb5f96245d5018ec15709c48c9d06529d853280efe93fe51e7561530a1cb37d7232a858e46bd7a5f3b6e3a513a7007bef690452f553aec83a6098806cc644ae9778d61922f0aec9b95e3f1253e8caf0ec9c0f465a5ad66b4fa6d5b55684b2f4ce3d1b0a76ef74a7989c94442b8ce4f2c8de775a0caa3953bcfe72478faaa604530c62f824acfe9072aa06d20af3a53461839bc7d8dee638b8d9e2f47711a025ec87a91264a44e3d07fe4bd29ea70760088a5491ee9545ea029d700deea1149ddda807adf0cd700b993d32feda37d8f1c88973d289aeb1211d5c96d9a1b1a873b2ded11b9ba6fc990c2c9d8983fb94e0c1308ee83b0f76b51e6f250d9b3d9f34697e05075e7a1e8325e790a8577fa77ce947e963a1adb446ff294c978c2ac6f395d02c38c5d1ea6a57f36082b3055a3a446d5e17ab2bbf6177290e67e045c7f46bfc9c694d96245d88e06be2bd050426e98858bb699ba216ca50d5b24d613cc22695aee7b6ab454bde89b4444a5b15b537c7a29fb492244c71a14d78a80ec12d3fb9cba7515840c36f93e979fb2c0dc3ae874ea8fc8d4d646225edb12cd79e69f3232104be971dba1098fe2e51db67d3c63ef676710187b61274b780806475d2ad6be542c7ac2953e29a970e68674c91174e08dffc62e46de0c7406d31affd54dc517d0fad3fa7720aac4b157e64e15a596f3c7c2b0bd0ffdad29f49721cfafde4a073c9e101dd1f8293c3e229bce64bf15e7948519c3a03792fab3dee135e0025a4f963ac52a48c0e339acea337a4e4dc1e5d0e579ced18339bf78decfcf90c268f6d3c0c84cf08c3b8d5e295a41dfca76d6dabfd44541d517d1249fcbc6bfd6be5de17288bdb36c8d43aba9e83d81c424e5f831d5116cc1cee1a5dad096d0ac0ae72af7c5123ba3003d8b1ef89535431caaa4bf7ae264091f57cd1fa521201c932780c3bff7416260c2b4e70b434e135cbe93841e3ed30f07d5cbaf767c558095772e2ac065faddc1b3d70f7eea1d753378e6d5fd631f31be2512640bfa852a740329b42d4fb5db78a0adecc49c24177e70384463e957b24a59865e27457673db0c3b6d258d38cf44dc081fd45a305134dafe5106a725f0b84167603f7ea8de1363c833e837da54aae282d4b6f0cdbdfaad91b1e67e165e100fea78c38e9ff240e6f3c8fc5159a684c303d1de53bf2cdd72d92957ec032f147d3dce1c3633b7a55a03ef633248b69c936b57debec2925e826979f48ad02b54e2a149d7df8aa22ed79beeb43a9f26e2140c0a062e72519bf9958a8d0ebab76dc34d000bd31526eca0bf602138ab7f4ea63beb1e70bcaf29f2c6efbd59695d6566e3230ff033340e9aee7d60cb8ae91c1927962ce1111768a8d9f07ac41945aee195ea7716860fecd1714e21be845f3742c585c654cbdb7ba7d24a9f319b05eda5dd0e434213493ce521dbff661be522889df4400be8c30662f6bd2e13dacb520f362923b250581ba06f1f9dbe15d96acfeed1bea56228d6d86d0650e2489b4076977f5167ea87236f5fe1dcb580b5460a1c42c630327083538652cf1fe666a32c1a6b909c28bf8e5f8ed02a519ac41e9aa1354359d15cfd7c8f796d5cb68471f031b7d3dbf606d1515d9924e530793a6ccb4e4a6d64cf3864cb23611e64bf3360ec51c4095b7b162321c9a203ef689102ec6fa3c383186df1553dfd8427282db8127673ab5c9fe08d50c8f3dc0fcd0bbd06985c8f0b2feacb8f35b6e223b9362c0e8093434ce142d74f15d6d7cc9df04f4fea98aed175f5a50943fb769994d420534bf0c0b956203b2059e200c03e6d9e4d3a15cc413f7fc1f2c18b40835b3da5d0f3b04822104a8ad2d3eb78a7cd2b09f74a8935366e78fac71e863d1797267d60504a25a3abd58c5dc193b01de49f3c702efccbf7054e897327976e8ea2532be3b26eb1eb948e58779578a9256926c531b587f8789147bc3788f1b6f3b42e1f10b55308270d2bcbab3a33cdc02e8093107c73860ab2502236725f65f5b30e623cba96fba45db5da7b1193a1a0ad587f42b3a9edd8fb12ea2f53ef4455b1f1aeeeef67195a37a7555f09eb8211d4d7a7e9fcf3882c9e1c85d9fda58696565300ff99730c57edcb74155f7875110129ab181603a2d7ec725160d85e66a0819a63b550fffba96f42e8400c3ce13241d43267894d89a5a49a7e4a620811d54d037a53153c80780a22e977d7b572e6af4524fc320c36134bfd8c074d5a74ea9190759ec5a2d9908d3b240725f7738bfa48ba5677a6a85a886e200212cf593e75da3115f5a8e0e65575ea83fd646ff3048aed7857df5562fe223692232b9bcdbdfe5e032198e0440e6115fa74fc00d5fd15ca9df35e8b5030770d6dbfe33c117e33b779882c6d3ccdbee54b79e92e72cfcb79f9594cf19e32fe720dce0dcdbabdaa928bf3417a96b2ed38567b7ce8fc2f9712974b3dd7a21ceda874ef4be417efcad40235be83dd3ae69060300abfc1fe64da48b5be53e82b181cf0bea63b2d53aef62a994091c62deb0f78f66e3223df3745d6ce4a29c42ba04762cc57ba49e4cf82656f25962391101f275e322ff5e7513c3a8b81e48224cfa67f202fc2cae4a5812e05ebf27130ea8c11cb2463d297c0f112cea83bedb0991af4d767bcc1ef46a63fd7f93ca12adfeff8aa1d5fff9dc7c81ade58a8dd3cbe826feb596c458893a3188b87f7b558dd6221d5f636c35043ca161b9720768863ab127e2def46467e6191b10b2f9f6156566048939a74f55accf511c771a03a8e4bb634b23b1eb904781cbe55735cea3e39583dfce7f387092d8aa37abf79072bbbc3b740f6cc6fc467d4d8540df5fdda7e28b92e76ffa196c75c9a42b7000e8b8d30ed63d26d422b2bc0ccad84ddddc55cb3e136538c9949005670c0aceccbd53d1c759aaae52309239bdf97047b328bbea39e45479c0225dcbeb26d9d724efe6c91a24780410f90de04ac19d0926b9be583037ee53bf6ccac6494e88bcd5aa48b6c61ad7fc8ff4c0c92280dd063dfe4b63f39bf6256ce64328f21b16793e12a880c72ea2802867903f37535eb258467e90f9fca7f8b8883b789ae31ee13e44ce1e55e336620feb196017214d5454b38a2e0c78820a4b8ee668bcc394c0f7f7d271539cb2a8fad9f436b5e8b335ef791611fbc2595b144047481660b44ce1fdcca38d71b83db48b8f4f8501bcf94eafbe3e84f35d23911cff88226ffc1e356e2efd8ce904b7d9014d0cbb5252f9e8faa6c36969aa6bfa225484ec30198f3409b1946825cb02325759387705254bf1c93a703f4c2bd908f3fc9323884eaa756e7d7749db76e01859802e6701c03d3078bb466374f20007cdd3c702cc5b60066e24cf045c0243481cbaacf6dc84c5be2ef239a4072f7b57e95e5de69b2250fbad204a1b696762b5495dc48d4f0f8f4b9726212a75051476045a120e6b8fc2ede38228a17d049c9dadd4ecf356eb50ea9e26b7d18d404c26254aa24abe4b3fca0a41c4b2247d0e134158e86d16d3fdb16219bd72e969b43d8739b3ecbc0427f2989242d196f1d54172106b8f7fe1fbc15261b98dfddefbd5ee805d20b739f01a7f32a6759723fd27f88f6a5e3d04181d5a18a4eab9356734ba72356333a8256b6d2ff7c13eb87621a3cbd7c7744f142b83c6d35b0e6c87f0238572ad0d13c226d238256d64c11d9ae050b41011a159aa585295160f19ecf0a7782ed36cf45b2f65c29f6e00ced7f0f21dd28458c5019f5126e5054c185bba3c52a912e9c9cd61616c210a924a5ac5bff368d6a90d37d254f3d5fda2a3b1411844ec16b90810d3a5eead477c48bcee0448f6894ba1fda702a68a96222da919d08013214507e571d359a0b2d29e353ee78bd5774a4dacc7870053db5cca61d341e1c4211426b2a245f929d428f1a27135346691d72ad85e77e3adf58f526e6cee7e53f39529bc0c9efdc4afecc68b4dc951366cb1d3701e1a9c81719b4af080f73f3c426ab2728d30393d476293c9ccd143e11fde0f8be632095818e4e2a83750f254a52bb6f88ca3c0f692b7576e309bc09c8ae0ee2c2804bb9cc15740f8d8a4a6e69bc61e218891b59c850b701f190cdb4091dfda21f10c916f354b098e4c3155611fae88d2fa8ff117e394ee93157cf363d8b65beabcd44239207f76352fc4c9767918af515fbb5f1801213529f91adbc28eb967ae93e5c79e55de2f390c89439a7e529ab4b6229e6adbdc2a2f0c1b3acae8f3f3c65ba509dc8ba18508cd65e8db73eb32de5866d0955307c9f551849d893ec81ad1b73e953becdcbfbf722adeb09721b921cfdb147afdbcea5a581cad0157d74049b6a632c2556ad7e7a5dd47dc7fdbc36a7f6b80a1309b833fc43e45bb4325960638500eb9e6aae0cfca71e30cf082d83e913ed7f26d969eec9e471fd64fd510b144cc032fe7e71493d4a391d19d0a7e5f80af539a04ca4d603b79abae8ebe1c578869895790c259bad485b023ae712ac64cb7dab4c659e1704df97ad87e190e1e08a8d12ecad350f951204df1334fe3da7609e4e44ed9006556a9e911d8940799c6883072502cc36bc694651de0c59475b00785746e68dc8ba3bfdd1430b71cbcdde81f669ab72cdd986088627ea17d4b4c0f25f24b1eeaab26585c4c572d793966708ae355f0b994835ab316b71ad28f386b17a0434848767e5333d38f07debde046ba002cb44a68cbcf00de2f5611ce05a43b562e30e1a31790b40163af4c32de0e85b89c24714f134ce99e4eb237b319cd649723b75f26f5e670592d7d40647c51f1b07ebbb75cf695dc180849803b0f6756d74a1da34d40bde72beb6695c8f8a46c4b46f6108a65ae6c2e62952e9db22151d0e59cb3151d81c56d5d798a9e3377d9a07e05346cc28a9f6f39622281e5bfdd08a3ac8b487b00a6977e7d45fd99f9cda6e9c4b195c0e11c3b9c175cfe586bb3825390c30beb7a9d15a62c1385c90e0cf5d8e7b2cb36cc3d465f109ced06e5608f7281284862051d5d87a2e3518e5cbc57eb018db6a7ecfb9c02038da110f12a70c7be660626b686d8dfbdf468490f4ce24398b1c2e460ad1a97d7ff955af0984c8734aec5539deb524ad46013d008b2afeec12c60e7e4753ef7141d41b5259f2f046e24646583db5dc43b999b4f729284f30d1fd98c27cf3f9f11b7080122d0ace1404740793ffca3e6784faba6b17743098906859958ad3f14d2e14835e2a8cf8c86bdb30254f39bebd4143a5ef12b0177b40f6d578b8b826385b9a3e8f871e072a6803340a9c0764ea44f81c074c0ff1bb72c0f02700c353ea371d586496d7c309ab121266e52fadf2347907e731096c25931c4b18ad91ec2ec6acece5df55abc6e98f1ff86a7a3ed22d873831e7280bf7d9f72ed49a729504e2154666d9ad6e5fb33cf34deb895de7458884ab56d39072f75df2fbd94e503e96638569a01ad6f376435ba4ee5b25b05fc9f503ae68b259fb01dc5bd0f9be2e923f4bc30e057291028185bb8896407f3bb96a8a5dce0694934ea8d912aaef7f456662836cdde97a0c8f5905fda7e9dff088ba5626101fbc09b2759abb75dcd860390beef5f9848d51d01b942509ab7b11eb6764ace43b51ee9badecb663648cbab3ad0c4574ac4a98d2255c2c9416ccd76b908936066d6eba5d6656f50bbbed090ed1fd70e79e4a85f493d472ab965bb1eb085a1fd59f79ed7925802f3858bdc0c4000b57a5bf92d5cff9376ee92cc4f08dacb397e751ca6a049c524e266f4b975dd9f0caed8ec63f6266194fd8dc80d1685523efd4636a8d3afda1cf75851292ac141ab1302bd48bb47041c31d3e5ce76a38a65ecbd8f8bbad4c2995fb48395c28c3f7de002cb2cd98091ae6e047613064c9f6187fae2c1a91cf10638ba895bb942102ecfbf5a77925ab26d88d373bde63a0a57175e60f53ad1017799db10caa7ee72bbe862d91be4ac1b5ae9dc5b832ae24d7daad63735d82a47f17f6a34b3d401add63212a77dec5fbfded3a559541ef04532a0fbcae71da81c3e3db41de1cbde9818a9df0807f210d1bda84cd6f02c31d94f973dc1a7b4683b3d9e4561b4e6baa47207d8965c6de34cb1c351bfc5082668c0b20f1fd336888b15f278187f2e9056549e0b9a6c9ad895f17cbfb92a45357ac2e55e32c56434c4eaf2e6d838ff0dcb0c8339ca55f503a927234637d447af8d865aed391aaa340a29abc87398f9de5cafb2fe79205d4f0504c0115c5e557b094db44711560818a92e3ac3c74e502945a717b75cfdae286eb83512e28dd0104ed527aa2d2f4cf1ee23ede9a2ef623c15b5b1c034eea6618d4cb8a97f592d5cdc588a5171f0671e5234cd3b53d0e27d8862818ea5711f2c030d4dbb1f05b35f5daf28089fba8795c54cfdd72c13874ea211584a1a87e7e5c5a57de29b87061448ab7e3de36a7858f1632818ce45b0d5b942ae5cd1a8d2c37fa4dea78c79ad65dfb3bfa828d30802bfb6dbee96add811e054f3f1c33978e1cfcfc20ad0e43f14ec07240745ddcd7a782e636b6e1f4750b05db1c290e0259661f899f93ed25d355a806da28602938c6fa8e778b80025a7de1bd997d072e118df0ce2d2eee5ff1e75e4fca884759dffa45ad53f5bb5adde9b12579634e3d2693cffc23e7df2c5665aefce713155ae7942a233c0284a803d86d1278130dd9800f4bbe3b196e95096e36b3fa067114e81699efc4063d862a69038ad71ba61fc792fcca18b908a65681a23359a8a53585f6dab4118527485ea7fdcca6ec4828208bba7beb205ea38a04d15f2267ea829180cae8ee085ce78b798e909f383aa090bb82494348f54fca028f72ebd02cdf3b908ea5d72c6c3583c9267535f04daaee95f7e95cce6405969efcbdcbec96ca40bb4ba63dfa2bceca0046066e9b89cab527ffe3b1f07389de5974a3210770217bf8e9e817d9a6ea02f0eee29d8933b5fff4cd7710f7bfa5b980bf2554bbf20a44f4e73b18db540095676d2859962670d09393385d6b48aae79fd55aa42ba38386c4130beec85c11aeec14a56512e4b7f947f7688c01392326a006b3b23d3d82b463814079d723ca26e2c40da3b207ce7f00854d6d73c300666790eadd2f6c11252ce76aba415979c6ebea40b3c24d35a5ded4db79bc550a2c74621a2931e662196e01cf16e4d8a2a6be09882a8dd4e42862f6bb135a5d2a9f23f4f48e298335be485feb6dd28e882666746d693b57d2184eade4c204aa10ee334b73f6fa1c55efd93c0652896dc5cbbb23e6ac8ef7550e46b6cd48c26f0d384acddcf2a728e2bf88de346369720f17cc3ffe06b490b4bb682e49a107b2a747e1bf761777677cc3911fc61f4689448131602464508779921b609ceee11ea81e8f4b7c5057e4cb1c8131bd7a47f88b18809f9fab90e58d9e67581934216ac4834022c5d9ab6bb9981fa279985ba8be5982d14abb18879b2b95fd7947b5b87f07043d2b20d3d95cb1d3c8bd4f6080d90967e148ded9a5e03e3890cd320cf8b1c37bf4ca321896934256b21a1d02b83e5d3a44e6e6d20bf3fc8c3269cca15f6010e583596391cef016960a3e06a68c1c5feac026fa9ebfa4cf291662d39b28a8f6a1dadd84777c76a4d282fa1196b11f591da9e84d6d0232f53aa747137721093db12e95a0f02d15dc02802710fb541d8b159ab3ffe254ef441e5f4550be508ad072f59b26c8554beaff0ccd43bc7d8ff63cc1553c76bf2e3fbb564c5efcead4ef9e7f8ad8682e673f0e495b7fd2c62b543e0c22d613214a4f8dd24367946f4c46b2f404738f54be507cf8ed16e7c5e8f2933c19fc5069b724bb53fbe187b620b1684e81acee1dea411866856308dbbac92e9b655c4c3755fbc40705c2d166f39f0efad5f908837cd87caa27bf6f8d5b2b4df7dbdd611a76f2a7e62bcdf349f5c01e18ce73db8e90cf30bbc8ee3ab1baefa537d327be0f383242206a3d28b87a7262c03754e05a7d182a3ccdaa5b8352fa95873ee6db959ae878d14dd94f58e0cbe6447470e5363c4e2145c2067ef525b9ce0f70d9298f20d2f28d1ffe55cb6858deb911178bb9b42bee0dcfa4120db890c4824418cc43043a03a715a307d57d91b097a5bad8ae4930b871d6a50fd0029a3fe0cdcb85e80307cc0f6684c991f5a3221ff7c3e85a3cba69838c5450d5259cb5add3cd797d7c420fdd0c8d036a7b10944d60b0f1394a6e526018ef5f067e793fa578390bb89f8a488a7e0ac314cd669c3ca6baf6ba44d89c7f7e2be0b72c85a14f1fdebe3017baefeea830f5ba823e7a20257d327091e6f04f6f7e5fe30b1a4352d34a54a811b003955929b22a90f821195abad6fd126c74a7222387e69c6979ce5e3ef7827ea8ce889d26ded73ee8213e11bfd7291a93c1eb9b8657070b717de4c6829935d5fafdf1f5dac3227f811fb54d9c0ebfbdd011975e3a2384ff15ee7d6b310e8fde0ef89f86a79a998e9a3ce3061d565a3187f89b7dee5dcba5f355edc4a3dd950027b49e1822225d649e7da6eeac7398d0d20f81c79aed8ceae7b1413b680d01c0e0c821fa56032a705efaf807734d5fc1d6e74d175be5755ee22ef4245c9025a9e7c0f55835d04b4a227772126c7e6bcaff000ac7d52abb74243f06387a2f2f75bca26fc2d1e7fbd13387559c785049e6b8afbacfded14ae7420d07239fb62f7a72b88de51b140260bb9ae05412f086263f07645ec8ed3735aba399e3e903cb3258ec6c8febc4c85d839feb5cc1ed578b641a665ff26de587c0f0593fc199ad1034563889164913a9d324ba2160c8652a76fef6941a5e3f30e1fc7db29289d50eef7e3a668f7c81af22692d2709449a9bf7c9ae530aa750488cf218486f7c5de1d126cba8eccec155656d890c5e4ddb2c1ed2b54096c25a7fa21ef4b0164390fbc3ea61ccf56d432cced99595685026e03ab2d6371c3e722d231d59e803e820c46c242208c364e4dd8d33335219bd5b85b23ec5baaa7476a2275ff110c307877978132afeca8319b9dee30c5b95442fa8febccb729ef36e0a1f9dcf5d72886b6c210c676b2712bf04935905dae7795f7209f92e19e851a2646f5e50bde4356d6164c27d5f67bac384485fb7f00ced8b86739c0ba049e7b7d281cc7597071e47f6386b61d675e8e200c8089e66f07fd3d9e71a7b7a3abf882dd6bfd480f0782928d59f48de08a10882cc51f84692865ca4b6c5d73e7595e80db407c8602536125c280c84ff41c6ba4c7fbc8d4746607ff011555091be664541de049c8832afe1af10770dceda253ce8fddb4d18f9876a273fae4e0763873e50bce7108851446fc9b2bf6da7076d17e5ef3e2a88276a0571c3dc0f00ba943698059d372efa0a91d0e617eb3980483a97be952eb1d264228f86d6639c46b552b699f79cb5890fddca1c0cb89e1b98463d20c80b9acfe77c59c26667833a3196fd65645a7d3211b221b0fbbca1f20dbc15a26248250b7f89a23f4c88856743f059d4eaae23fd2a444c951a79a2a8f3efda1b055f54f70c664d165d4f156264f4275d6690aaf641883376f33c2e2073d2b39d41ab143eb4582a78daae6b67107cc9a37b4c74d1270882444e978ad9fb0bda70887a8147177216e7986445173fe9e9d14a51924663f6d2e896663dc85f5ccf491f511ddbc6449931786aea8064a27cfbf28a831329fc165152a13725b89106daf9d686901cdc39b1eb68f5e54916db0bb128b5a25dfd94a07f8ff00d21fcc17b0623d19278965238cf629704c446235d8b1755f88f1322d54357321238eeddb38d13df72d3edc9aa3fa0240e11f53047f38ad82210480121beb7aa567b010e978294c5169d5a7c06972f753065167e5a1c2f894e2c96f86a5343c5dc871c013409ede7f61889e9ad831b6abc32b35bbe2f5a6907c596889c50bea3c963a0d363b17427e463c4d692bb83b2f5affc2371582a0af90c511729a7aece22a14e5ef9c6891bcb327924b5b9672dfeea4a3442cc93e42da4bca8dafa0415d62ea25c65156b4eec0703626018205dd64b14e215560c7c0c4618fda1265df7a69e3edce4fec0516789818e9858892e93b620b10264200c2c06ed31db728b808e34a28c10541738c1324117e937b85ec39bb535cb3bc0ee35342ab8760796007d96a935941f157b1274a8fbff8d1eb7cb56d1a7f2dcb2fcfa150970ac2f4f21de230e89c410920c2040aa53266c533c16756ba012b8df4086afe859851c1370cccb213a760cb70fd4fa68a65defa98a1e7e7e4017c8ce62fe95fb1f907ef977b1cf5a7475072f52ffc81f0619f75b95ae1557121118d93cdaed5757464646788cdc5296df9c05ab213ca880acbf2e561d216ddbf78265fcf9c76fefe103848a814068d6308dcd7a68bd6602c2503ab0be67ca230ae8d2a1191af18f6c0575a376a9939c2e04b49afce95a795e91fc43c90f7753889ba22262aedd69d1e2618123c2f1e9410ebd0ed5cde2cd69cb2b827a52932a80c23bc50d3e411c08e4fb0f84679c8e6ae77eca55b7b7c8de445d06a3658b0fa07f48f8e690708962ccdd9952edee7ea3a737dd16cb4b1bcc5a0e2643064b582a24a838174b2323b774709bf1411a803afbc17fb2e1cb1d479a85ea0a1bfea0d19f8c1d8fc3d8e5dcd20e979f0e54a5b4e63bc2e4fc018f40ccd9c2aba81d794e090617a70314bd71921b9b3445faa25d8b0067eeb9593e70c3445a84305e50d82d577588a917c54ff183d328fd6b6d45cd1535a98dd01964c50e5a926263cb035aa438f56ad3a6693ae049cf004eff063cce40260f51d59091562ef6058e6b2730cd5eeb8430cd11ecaacb929bec561de11fc4fa6dedb7b29d9144947f6b73fbde0437104d6477b1285712b436657598c2d1f7afac097940a2906dc18c76edc6f8dddc31a94e56b2a515ed12e3387deb001a2f598adfe77fd66e9428e2e570b1ac1d693cfcac588d3ff0e7e7acce0f43a412b89c86d3d9204d503329114572a341b7146d590284113a7ee58004b36d8103d82aeffecd1c519b14c449ad370347853098bc0b0d6d3f49db16890bc925b3beafec2e4c49a74c2ce6cff6a35a7f1bb313094a07bd1378956cadb691de2a2b36481fce9fbe2af70a9a091cd1407b6090a5fa53f0c45bacafd281bf3f600367f4090ee0debec48ae443e38f377651ea252699c3f0f519c8cfdf08ad5fefdd6877df0d36002ada7600995c48e7fe05bafb7ded5200f0a180701b881de69267f92af07635fe433572f1c464bc258a60010ed3fbf8c35ef6f5ff8ff46606ab748baee47fab6034ac717c16640095cddae4ad9a179367b7302a24ecca33a8cb67d891a28356b76e63380f5cb50b096fbf0a4e72b2ff67c0fc76bb35ec006521105a3f2efc41585e9dd2fe8fc2a31e76246c873d736779964a8c953a9a523176f93f59279bf26fecac67eadda0f3caf5dc168f88745fa76e33951edf94ce73ec497c4c06165521213f13ca10d131dd0b228c27ab3b63402e639c968a5baa053d141d164eef4471809f9525bb37708d51e6899525aa36287c11a5d103e6af9c01911743f78189292759eddf759a750484ba1ea412d3311c940a343e31bf222859b353568d995af1dceb62005c232ecb47e107a0a19dbfb0b342611256e15907cea81c6a594e546a0d41e080870441d75490d4ff3103de429562e3b2c0d241941502e6b0b50eff11a10b1f07cf3137ab6c76fd73704a53b265537915e28384dd24910c42be44f582ff7cc55bcdbe9e8e4f33bf1aa830b6f95ecc1e2256c1c5959c22b12ccf6565850d10ce4977c397df81b1b3bb643e11062e6b3768a1cdc377c12105314372ef1d5277ca57e7d0240b23a09cb66cdfdbab65e125c2445d95d0b39816c2b5a792443fe7fe65fc9b95f928034066a198be6c12b5473b5574c965b841dcf0a646ad57a82a02f384a47f9a90c6a689a6a2fff04555373370a648c46f19f67f4c9e1f90eebfa3c8834472abc7a608240e50fd1c0cd7b84ca182afc96d194bb65e77dea580609f0361f02a88a12b5f4a0e5a4498104ca069be2f1484e68c39f3ba0ca773e3c08a33813b8052035aefce7aaef6edbfb8edcb14b04d0efc4916a8681dc345daafc7c277f864d3aed80a11bdc693fc34e980c8b9d74d250b2077fbfd371da6808eb2a1637c334353d437c15c04ff3d7d60dbc27069b42aeeb925d7718b5b71a8669697c3a0fbd10f3e09e6b46598a5348c7e2bcb635eae707a561adcec51deea84ff56e7dcb9c197c5f98b072d0873dc1840a64af0516e7c91d9fc1a61a19bacf449201f63ac3891fc87fea022c5b725e16a5e49eb4b79117674c1fd676c324a7bd23ebe1007e139eaa7addf5984c5751003153ba4fdcb26ca4cc913ab6acece932a5504a0fb9a82ecb0ee7b6bdeb6426bf8ff2a3641e5442e716385edbeb127ce15159b23d0127ee1d30e8d3f294cf53e060e0204715795fdd770a3fdc03a6e844d804dc27868b910a7ede69cae7fd3e882f2bc5bd39b43999f97a0e7973c01730b9c6b2d4e5b3362164137a03231b36880397094be9213f4eb9e1c0b41e5101bd8f0b01cacedfc7afcbe6d6978aaeb95f79e0d3984a5d57e9bc7e37cd2cdb5c0df047e2c515760eed3ea233e5b58ec70e24a0b06526fd0152b37b3d068461e5708b5e6216462edfe7cfbfc799ad5d768367fe195544dc748ba8fbf022c2243952161c67b81fa62707c77329bd9b9f5323a38a887ef07699ed3e92bb8ff8ef411d2c4c7a44a85db03c63bf771983fc2193899f3dc1cbff260e289436fde9bf432ff28aa6ebdb029537b5511e21a16f9b759ca2c3a22b85ad11501773db356549a2ae85a2ad347af38a4f3145ac8f31954733a70aac3031de3ab1fc3abb4111a8ddb5685e7695be90ea16f3ec8a39bc21304f6f650b27b95b25b5c2f32b7cd6dabaac3d0eb59a0fe1c44e3f4aadce21d7286e2bb07a99a91bcedb0d1da279b593c81389fe478d525eb223b5a00083b3de8a609fa6f3a1c2356591aa2db23242df35def70bdb0421ee31ec49d19dd47fdbcb17236b48438a5916192b851e99c8f880a8f5c53eddc9da634dbd7c87ccfa0180ad3610ac93a8ab9697df8c751aa164d6fb8c7664c28dc6399bcfa0db7bb2831b92db58799fc7352ff1f7927eb377147d711ab313007d22d9c94fbc35fd126d6ca3bf95d1b05439ccc811a71b43b9c035de7417559a8684c1810429b418a5303ceb5b6444788c8724eba40046716ad9fb0380dfc0df7aa20c3a889121d0f94abbbe10ebb2c86b7f56fc4b967ee25a1d9cc123b6ca0b4f95af19c990973942daadcbdc2fe2056b7935f1a192d03d5185b172af958140cfaeffb18e5fbb58fc8e231f4356e2fdba85e9bf11d0c0f964e2ee90bac6dc25aa182e3982d6824d61f249aaecfbcf04b9c5152fd1849cc6a9a84c074cb3e27ea5268941a23b14540322e946b149e1627f5926ae1e302c3a827c14d4840bc00f20666b323746a5e82ea8e80a6d1de26faaf0e7d01086c94cc2e71aee5c320ec3d4b4e88f13a06943e4521bcccb2b97e23221be32d2a2f0944d208b8f849423ecb51dddb589cf3227f2e3c216c3a315aa1465a4e5cc6f003fb2a9d9b1d040fda6a0822c2b8c6313708a25b44ff814debef61b8fb4f1d848f6cbe393c5a04811e1b36a1ffb771016ec713f7611d4f97be8dabe1a2e10730856674481620ee637a2577a4172d5b181093544ba0d05a4124eeb811fcc26c8a19380e13081f2b305fc7cc0f278b40c6dc6a6339f59669fe10cfc2d85be86d446cc45dbe83cf0b0c52efedd54c920dc7e1fac93bc89af399809ab659f893d02be10ca5ecba35f2eb8c18c5dce8236a4dac1d7b19c8b8fd0869a44d9656e2bbd752777f38a5b0a0097cf0f77bdd73104e73f2e80cbcf7a6a5a92e5e71de0fce6a6c8f16361e4fc8872b600f96eb127717f2afd1584948805d29a1d4c923ce27153f97bf1a736db0aaa57758f57a1ba085248754c4efd8ee9443e3f93cee271d0f5715e0b456613b565a92b722f691fe8cfa74ce595ecd815260f532fdc017f0e42256d52150bb38cc4143adafbdb055a9a8179166fc32a769b7b4034ce4c692e734fd3ee99e9ae6ed4b097a6f630c1641423762ba5e1c1d50d9dc5063cbf2678d2c5ce8934146830e3c9ab3f94ef32306ced958a9f462f1b9b0f0518f16234ba541a597d4e326c8f0f1cb8b52bdda83a0ad726c639f9d4fbc517714fe006ca61485daf322af5e5db4223f8f4e373f24490442208635608ee9be7697732eb48a9d9a740a65fd2ca89ad3db5adf35b4ddd6016b9ca80c7c536e34db4aeb0d115f4318d486be3a5967500ced283bcb07f6cc0bef24b8d15c4d8f58c88f0607473a576274a95402a5d9168126e5438425e57c63714bd4402a1bc9f0f87dcf8b34be7ffa26c173a49d18c859213aea6351a7a69e0a600bc50a3cad408e1471a433c7915def1704d270001dea42724e3db27c338f7c736d07fd651bf892a67d59be76e9cf303e448f378a86f2eff156052b357f50cfd9a58e749427439ada250c536f708d0829f96abbc744895b3bf9ec7ba16a46368535ce7ca00a000a9a2dba893944b62079bc962e5ebaa11ae5c6f3b34c34819b1283f899b0e47728d83103b6c27d5347024bcd1a7e92e54ccd411ed0d241f9ee0735f548557132e6984ab1d130f5e6de9ef8e8ced1e8e142d15c54ea2d71fa87a5070a00c37b9728a6b6ecb41bd6dc3e32b542b8bddfa7f4b2fb68b080124576785af201e2e52abf1c12379b10c51f6b2cbcf09d76062f4179724dec09f1a6ec29fd2fd46b9a7f1fc041b3129ec86007f94176451c851afeadfd33dc97d9fdbdf9cc1eaed65c8f6de4eb8ceac17f971135ad2f70b58d2c7b56e80c2cf34e5727dcdab386278fc4511149a8d71b5170de5430c2a6428372005e2b7a00c6e17669763476c7195f8f0ea9ec8a22bb307e0b208efa9f112689b4e6abc0f991b84057c2750b4cf35918657d8807138eb335edd9fa09edcf94e35ecc9e6d9714c864b2d049b7873b44fb7e50cb0bd59c66b7530c5b1c5a2ece3fa6aece5926c6cdc7d0215f31d629f6fe941cfda957dfc207abce0c02b4a712340b5566d35ea58f89aa0b9a973ef78d466aa88d7fc0c2c0a4724d25246f868d55ca90d4601e460b7614f66f004c4a5b6b4b783fd2371fa10f0b06dfe80b52e514fc39af5dcca8397ea883a929a333caf5406270f056c635b806828671f5bb64b0f75f73f81813df3090259ceae5a5b8f192dc701abd9272394d96de6f067eaec841c552f35c62202d184e59bd2f82db7538cf92fd54e3391263b7c3398d3cb80d79424d3047a9554f16d55d754b09196519378ab104b9d8708102f4fbfbcd9dc6e772ee02a2c89f11c844b6f20f6ffbfb009a77e5f1546ee2d98014852b911b9210a28dc77d8b353844d7356945cc45aeb340ec248694c4e2629810386e55fa8ad5aa2ae9c401555f824ecf879cd842d140e9007adc71d0d726f3292dc14ca734ac198c56b5b1fdaaa5fd968d5df93f3dc1def7a7987df13c6d0c3c81ce83c454a2edd2479312e63fb163ac4cb4e5ea4a920d2a1b708cea7e00cec3893b3ef9967a06d98c9fb7541d7b37bae02d6cf4999151df3c8cd7392f82714b4a95ef627769c6b5caceb931c40ce93cf028806c554e1e0ad029d6c941afe4a8a76372ab162edb0b5ec76ee1afdb7aa54c42ad9b7a95cfc3295a95675824a66936b1c0994e167f410ad7e2a2f49b04790c54b161ec739ebed29b5c18823206cb089c303a7e70577e0d81070a02190806820c6b680955ff217a6ed78a383113ec1e55f5ca8a2260859496faa401b4f55a94af828f988fa6d7d72b321ccd876a9af37334df42b83b4cd2a518d46997515bd5075d189caf2dfa36b36f10b7e131dd3ced6bd560a3c3bdf67b36e0879fc87f011dc27b3346d49cca015a8c369f9a23a362794a6ab37756f41c3fe876991bb1fea15ab354a54d31cb0006b14f814a0693b0db5c87cc760a2569ad6c6f68a84204b3134dff8509b0b900d27a838d340c6f28304c58d647c0878a5d5ac6aa4cde0d2bf6cd5e8e9e228616a8bc6092dfc45e92fafdac820c221acb555601543a04ef769eb97a11a75174922834a569c93307b8e451a7f08c8b830eac582dd6f5ef46817179abd616368e813a9bc8a0cc42c605769dfd020b9a82bffb80b814be9daf2e45fceeb8d26015c610d2bb2d53c223980d3d3361184ae4b168f5e30c164205969e662dc540c66ced09e0863549278df452d423e012b2e70814cb4156f9ad679d7b8cbbbf8e471d32f423280b4922bf9fcad3c3b832bedc79f3f506df82629a0c64e63ea6cd742c4c737c81ecd2b286ea45f6cb5c2c5e2c7449af60d55d6ea5ed72cfe69c7f552ece122874dfda77c10032346a322bce35ba82dcd999402b84d2598b32f5ae2a81fee6d486327c38f7db5befbb55182521d9596953efc0ce291d4c66c41b363f5c5371c6d79219065bc0edf2cff24ac636b434fa5c90c7eec0fd94fd0142145b1bc6ae841f9dfdb8d93af39a6fe5c1ad9ad17ec98d87881b72cc80e11b773cf68e9dc34430a4a80fa7815b084e489208e921be5174f2268b494a34a456d47e9f06db03df422de5ec1ee9a93248979a049d444eb9cb974ff13a65367ae333a0a8b2756668bb9d78d6c709df226730e0b025b2767cc3a590b78a0ad36bba4ccf1c7d5948ab822164c589b980dec14a4eb1c81d0f60f58d86034b2f995c0945113c8aecda343b880feab8c9e3668edea2665ee0d397bb1f474395ee804861b35ff4b81ae529b1bc8ba4cbb9e0dcff8e47ec78a7c29db8c565712d85d005cdb3f4c3faea2cefe593dda6ca6c2b318d41217c7b6bebdc5ba80f947dfcd0871ba18c367573ae1122e282e2606168f10fcd72ea653757dce8ca27d54d7fac1498b084e939ca1c95a43b8d7e1cb6fae62eabb24f26b2716f579ad2715666f91ec4335705d3b8f7b752f2a2bf4aaceed9abb44c0e07b693a80a40b2c446b52597cebdebd4d706978fef6365464251506ad0e33a4d3fb5d106674e2ef2765cb4425057fc9078a2567f4947ac7dc3b91c0e79fab34a960f000d55c06f47308766a1dffa8abd6f1bac962a53ebbab78f6ae3e66a0ee2f1898648c327d9d7df1652c87b33492edccf4b6cadd59dad1afc5eb0af03bac448937ae7bc2003d95c408a5a7df1c2b470212da237688006a1c82961ffd3e38380087c4b1ac0c136627d5c6f479488253ceb3045a17bfb30878965c4beb4b612e4aa517d532d1e07c6086f1e4c1c967da2ae587597297ea06d112466061052cbb69ec014fe00e889aca2cb30181a56c6ae685bb9d15cdde0b9f2027bd9894c42e667a477510c17c77fe256b4abf121c46d71d23408c47f86050e6cfc1666ef4307bee30031e1dca60731b5b131056f7fa63b092f1fa2794b8c20ab4f7273faaf100aadda51a703883c4405b04b1e964322f3a368987beb89b122f8de2211032c3c085422a5a1bac493a86562b71493ed28e8b9fc92f3ecb89e25f5baba111b865232962da2a9472760fcb31121b563510e895ada12292ec6b6f43cd0c56d380f13c9eb36147e6730c245c87ebba8cc2439ade29db9881d92cc437fe2ee6d5f546520106f55493ff95a23c54d92231983879acfe5ea0f597d6345dde2192c5ade9958ef1490418188c1b9e4413e4e0cfd8cd66fd212ee8604bc00ea8f466e4ece093a47970d698b50e05567a29f67425a3ee78c5988d06725ec733f687e12f6670e79a1ef0e4d0e911aa42279dbe60f86612cfac3f42319eb37dd046bd4fad35de1b3a4d3892a4d56645c03c8aae879251b1a0183ee8417b82f95c61962cd21a9178edd118a6c4ca45567783d232be5808034ac77f8272f970299996abde1a41424e6e2a414ca8498b632fb00b77cc1ab36e1732c37d649c51264c26076bcde060a443fac31de1d2b5b848293a7cbd0a4a3f76fb87cc1a31fdcebe2ac42330d798fd5824d86241c1b79720f1a836c04f1254335b13c8905199b531134eccbd78bf23dd36ebc53c364f77d3972650b648fdacba0c66f3964a2f6140206945800485ef554229fc0bf306cd1a53106e976a6e8f9fedfb910e8aed75cd553c946e7ce0bd091200f7bf5648b889c134e54a52cf303670c06260c8a867cb425dfae37fa31ee0d40ea5ec83a11c0e7bf77b012fc30340a6172d0f0b49d50d0f9e8e44a73ac57aced5cbfc475b77e0c21b4fc632474b9250907236ea4dfb29efc95fa20911b6f9602885c94b1b66bc8f3cad890b2bba58264913df401c91247d95b105bb0a913c8689a33c94719b33ae405baa15e4c32c914136c7e7615ec3ae1c2abbaff3fc25d562ab366326b61d5985043f639945b8e88179e64312702f86c4fe7816bcd424ce635b9d870603e8183b19cbdd10fc544cfd21733e0b47fcb746f2fc9fdd5ef19373a6e649fb181dbd298b912e0ffe00aaa4304af0859e65fd8dac7b70e5a53384dec33cb919444b9b733460a815c4ec111374ffc707a28e8bdbfeaf8283e3eb09209722e06c6d08e4e52a5728e1551b41b19ebf8ba3ce414e7f1b06596f1de0c72e593d8977e079c03fa984a845c054e45b7c713d2dabd9ced6243c93527b04b7f375120a33553cadf731e2745135b62749fe4c0b49ff99150f454f08e63b68d1b3f3a6723359fbc968e22e41311d249d3b16147a5ddc8ab661c0e749d00e2eb978fb70d2cbfc8ac77ec81983a9010f0013662a1739ff0619ebc075eb24a54c21cdbe53fc8e59bf2589d83264fdbb6c73b7cd1057ebf64bdbad9197b73bee4cee57b7895e4afbeef2712a97e300fff8faef090e2c54cc7622759ddcdb1d4ee8c880e3638235592c51f37a90ba14bad2976cd838ec4f9ef1c83d9f701265fcfaa433d73414fca4cfb052c793ad16a0a847c76b8e7635c8bbb6a5a97f9bddac9c4e0c48bce46d927d9954230c54a2e4eb174fe94bdc4c303c6454863ef223fa571fee00ee52c7ab1f0318644fee75632c7f21b9c318d44408c745d9978483a95aa34ebaa0f330303cc6f794726342e29781c198de4474dcdbc8c77c0eadd98a00f6674b58c2b83c968b8b0e5f3355a91469b742e8344a7a0f5c9b3f0a9ac21ae962e47d75264ae152cb2a51bce711c254f6b6e37384abdd305aed0e88663de4b1535faa9c494d195be6b19a6a87fe394ecc1ae3f60a328201e897e478ee4e1db0ebd9d8b4c3d5f13d20fdf5fac49004dc5ab0e01f87f1bc32cd3349b65a4d57bf9fe1a2f785021e5cffc0e1845c37e02069ab1618093c55eb2c9f6203963fe17f90702e963cdee93c06dd79f5d8c05b929e01c8211a4bd3b1727eaa3057d82769e46cfe51590c29d0872ca90377d2dc59cde082897e7cc5457c4d80247091552b6d974f75bb4f241e18029c8037968d5d6d8333fd104c7d2bcd9cb495f5c706ad6a3969d7d1984aa082f2d5a39a6a04673c147e11a781bf231bd4ae35e4d1450bc6d8b0629e6bc4fdab0fbe2ec73a7776aebbe463b0676fd51b48694c2da97d80130fa7f7236568f588b6b31988b7825d40ab9a395060064d479d6c9e783eb0f3540f4793577652b8a0631e93085a52c1d5d8d1697431ff7e2aef1352c317528a15622666db21fc4fcbf56d977aa0551144f121e11a590302d1a95ab1d7ff20749b1442e8d1b44a042f92dfffc5ed5ec057b324345fb04f75d04db8175610c28215dac636a557e111fc6f7bd9401ea19bdd51e2019b0ac0866d863a633dc898c8a6de54073d4e87b174146081d755b5cb978b10a724840ae5065ba446377d3c391920e06ae0c77e5012a1c2a0748704a62e56f2f5a75c51335358de06b002032fa5858428af898775140da6274da85ec4a65327f4a1162cc0afedc6b23e60642767891124c2e9cc8ad21bacdf4be6f454546ef64804909345db580bfad16c8504b0953ed375f11829aeb196a44e343c0b96747b57ae0fa587bfe23d43668cd7e3f4361fa38dde3fe6c83f4eeee64609ff93abb04afd4bf30d7503f5b24e6e7b79d87d7ae3c3a5b96a2594bff17247f71e91ffad4a4470f6b13adaf18a16dfc5d727e1ad78562b26af92651e7e2a6049b315f29ea0b3a63d3cc9790bf6feb2477de65c45d22a5af0e0f55d06aa65a1cec249a4945ec886a48824e0752d8d7d3182ce7e10dda4896e180454cfc10ac6ad92a2a3dce90a56608f5c6e980f68499b405a1fd09d3dc4df3d301c335c4355a3bab8f4cb98744694904986c2dc9b4278f0ab56d414ba62146b3bac331e59af8428dee2a89abee61935b083260c3cd36d4f092fa296923c7d1e41b961623c4229303eaaa3c6176a554da19d9422a297355b5fca08a79f2e377de0d50e456559f31830397b477f5399ed235fb942ccbdadbec55f275ebe29a7b8eff174773863816003870a52d26ec8b94fe5633f7554eb5218e9e80ca5735dd27663c1b747cf1cefb8675cb526066efd41d23b699ffe96731982c8215594f3f66626521695daa05f74f4d27ac71ad6c372c2232ada7ca6c7f054eb131d7599672c43fc3311895bb94f7ac54fbebb4eb3221e75d339627f2476fe8c8bbff26c80e22e2bf9bc06ebd0d0eaf3e70cfcd53239a7a854c67f5064d56eca803322eeff4447d9b8b62c02a25bde2a8f12e71ea5f9b4c76689fa998a15faf47fd7a103d241feb875d7f3596f5509d7ec28d7b335a6deebc527c437c1587dae6d6f4717c6094e4d0bc325f619842b63d77ae683d5e1c29427effb96a29fcaa96e176bb38ba4021fb6a10020752d0b2ca3c72ba30e9a5c7be09a307c01e6dcf3aec8ab3c3be9c79e097ff80aafacc7e88870b1d8083d24a1afacf7e901699d197a24c9ae21a4f2c55fca6e8c699ea9e297430c7e79fef868d995ca41d9b964d818f188ef36e6a7b39d8f7a0a80eec450aab512e9deac61644d7786306bcf4383da5a553da1eb5f7222d06dcee53f895da2fbbc497fa28171d57fcd4e132ba668716e05526e3214793216f93092f3de545d1cb99c381336dd5a3c9f674b3c01534853ada6b99640f2134701ba174bd546ff79d25a3b00432431e60e708dea57301f672e676aa078ab0f0f0bef894a2ae3eb6f051fcc0928e265dffeeddd9dbf684ba74cd0d8e1f69105c0b01ee20304ce53a5e43356eb7d82de559a55ca78e2b5d6f0909d14d25d4cc9fb9e74c21a918528c301fa38b03d88cd4befa13879368fd8962ffa069357759cfadaeff646c711eeb38f598507333124f9f903b07edfc2753a66eb1032de50694fd09c0b166f91e752f18c055b85b66988880b4feb15eed54a5ef8b390dc033a0dc861bcc9a60e0e75ad51bc1a9d55ebbeae94f85a0bb37666c562530b1cccf2b5761095fd978c1923543fb08e2f6a33c54923314d4784f9facf91e98eb020e44f49be207297e45168cf9a38a0d6975b3a1cb65f9bc40cae9a7a0019c2f268c155da1ecb104de86abf7e4b5f76fce3181cfae535bfd7abe4c4015cea086ef27bd87a00f62b996c8dcd79f4fbc2304ecc2d9f236c0d1dc0d8c98ef5e4c185ee9c9a617c5cc07c6325136741d4d2610b08ad64d86bb77630f701a59da017751a5bb1431b906d57fae2dc204a02b6550d9dd14f02b125a2f293354c90bf89937ef13f822d4c1e89898b967eb883c4bc119bdcbb241c6e763f5bebe457a3d78a186dd8bde82b442e6abb03b293aeb3e48131923a8b261eca03424dd55e58f4bb6510f36843de88e73498ed6f27ee4c69a7ea31c3f5260dad925fcc0dd462d712ed95dadc9deed0221345979c0b7e47f7444409e9d0d8205c6009d2efbcc4ead5121cb5afc806d2e23e4c1f0d9aadbf3053aa3db7953c38e5d04a7946f0904ca1b68c34a2190e41375567e4765f15304bdf817d88f4d79c692c839c1ad714d77650a86c51a3d6331d5a978dfe736acfa8a204c1495d547387350cd59e87c797c2cdfcfc693f3bb8eafbe8acce09cce1f54ea109197d3a547d735a785c4c7b7fe8c7f79153de4941a70ee3c53b0305e3020fb4ab3f935cdaccbd67afedc2228b5980952415b29fe4ddbcc1d7a33d71780e12892195d087f9b0db260b05e2e711c43c8c0d8829b0f55b7e8ed446c19ce60530966362def2d0e0e6b72a773b19798e77d876e44faed40d76ac6bdb34cd124743eb8cce90cfe8bde480241784dac8bcbbe05c1378fa23e210b1a23f2cacf6cd23e1c687ca88e55d665a8a4bb1262ae13b7956db7039c26cbf427adde4c67187f4c20da396098d8520a8e36677eae7c317efa5efeab5fb3d4c10cb4e45df204fd726b83c97d92699e80b5e7303249c23f877dfcd8734e939de1e8e7dc3a9ac656cb1c93d1264a6d861f3147670a8f86fc49b6aad4da22715d3fd567415fedc2404ac4c2a12f15a955f80e845096d59a102bcea4b3638da7ac9e1abe95486c65f489407d09bb588d9d7239a9ec5ce55c47f88ff9a64e29e0e09a1a7aca275dc869f311c667ff9620d145bdcdeed6707e6ad45d49bb997a4e30f4528108d676105ba7443b8eab6857bf1fedfa865c76aa48e55d72dcad4758ebb2fe2a9459179cb225dcc3bb653e78fedc0df8960ae13e25f244c1674553c54460eac99c41314907a1f5a360205d83e3ed042a0b5a929653b4f0b09cb1f428a34fee3aa4ed3c9b7394a67f8f0378393dbe1d8b51ccf8f45afd6ad886d63038bb030f4f44e125c46bf1b3182545da18479d83713c3a1b654f2841bafbb3f08a059e7a6f96abc18c12b104440fbe8848dc8e62fed27ecd88019e471063df411a170dd0e47aa1815e71c64b350b0bb10b1a489f5c992d45af1629ed9d55313036466bb25b8614549b541700d509126b5bf0c8203ff038635ae025b7a464e91bf615f74bf548f2015e088dc04f65c81666f3f9942cac2165dd7ef93cbb855ee75613e56e810b8f0ed230e044329f49adbcf1fd13e10755b0faf57b4eb4d9d8808df0d7dfab887e773b47bc12d07648f8fab9b74f5789b55ceb55d52a146887ca8d6aecf71c11f749f908dd3a257b265c8a8be4204bf35244f9f06e74b947db5e3ae186df9891ef6ad3bdd9fb7324712b6bdaf983733efe110789be723aab64ff30ed0b629f82c6892e49fbe9580b9dde9d46fa2427a001a617aaa88eec1b55da968ab19ce8c2f4fb9796b8c2e5909a3d2c1034cc60cccb03e2217d542e8152d8163b9a1db2712e1e4ec4ce95b0cfa093adfe8b9caae4190cc954f587f97128e6680485aa5e3068f8003f66d0fd71bbd6ed0fb338a8b20f02d1189b0e11b93b9542fdc9d3d1b1c3be26fd41f6cb7b0d4e9221d6e926a16b91a9df2afc1d15bd7f92d4f71851d5676c8873fdef90108337146a92ec8f4eaf8c18c28500c23293c71d21d4592b1ec8b31cbe7e9a52b9afed3d1674b67fbfe79c3442aa9e4cfdbca68dfc1407905ab24f03370350440bf1ff75257c29f1a93667740a8dd7de9cd8b15981e2de3f043abf00b481f462a15c2b819ffc2550839d79b998d0a5039b4aac7c5b77f9fa12af9be80cdd5954f1feb334b29671ba3cb5f6ba32102bf78e31442bd64d60e834f857f8b27a8947a25feecd3e1f5b5fecc318e0c9e2cf125f2952ee51160d65c9ebdd2467e8e487a256afe23f55d52d53e795eebb05023152dc9d40b56f9ceb98658bebdf6f1822c73fb1d162c096817d9dbd5bce5c371dbe65c36fb178f0f326dd42c1271850650fc6417b54783effec40a853242e3dafbc5ec4575df00f7d00a4448c2d89c811a15585a15926f2a5d048e98acf6559569fba08cd1ebdcce4f123691d2d0e843ab38ed02782815b40bce6cd6348fbb865c07f3d86b497bd8fa8baefebb429a677ee9a5992cefa262799debf03a63aea719ab278c762f3946419bdcb5e987b3d1ff67c2fe0b07adf316a32e0b412bf1500011ed802e80cf023b82c23b66628fe6a34a50ff1ab9bc92dd2be729cd50172cc6d1a5b5216f67195bbf96035a9907f2d6ba5d2661c1aebcae9a38f6f9158f65cf72ed2cf06faaae12d5aa4f494d38f1a9707aa3d20e765211d18308675d0a1d145056e7a332e7afc46ac12d2efc7c863123a0aecc4b769e9514f47c101905fcb761d04c74d5408a03e747139feb5a96d46376cd84f7174a9c3eafd079e99d0746ec085405028aa3cf19e93063b9067e0698be75dc52560e24545549e7347efe3c769888a374b9a855a3ccdd3054d0f01276a4d2be6ea5682971e90f810c97e24520e14bdc0a26c96ef8a61dc4d483267424a808457dd5dc78bffb3c1bf67d50515f053d6bb878c1bc32ed13e757cd15db4f3c978e29c44eefac1fde95b81b48d50559b91d2453df7ee490f8c8ddb0d6aaa1af252ea4a57daf004cb744267323e5835d534639f2085fefb3a8fd2fa79fd92216211820181aad0e500114bdeeaafdb586555176adc3928e664ec58232b21c17be45e1b53ba7bff5c394a1cb6d4d6dec9f049e070f27334768e38baa0ca74e6e7e4237821c53e0358aa384e1e68ad067096dea0240245f5743db8faa728c3d5a1a2ed3413a29264669c1174e35ab5a892650cfb2f75e35296d174e3a8a1371587a5c17709e91a9af147ae63b3afe29adfa504c21e686b82a823c2bfc129e8dc939aecc893650593016a9e9328f42b186f62a8cf1c3656ddb01cbc806bef6f259e5bebd5d2841d93241d0d5c885df10897c3783f019f555f80657d49ba75fc58fe26b54a5b08947e90ba9b0b93504f45dd0375a41f69baa92c5de3b2d89fd457bc9506f3a5f615bc691a736035a2b55927b0bb5110d37dc3f4c7ca964b40cda34b056014eac519a3aa887c5556b6d4e75cdc385c18a1e8fdbc6100a6590b2d368049a66757cd5d4ea22ebcccac15d953dfb8a271699cd33dd191e0bc70e1915ddd4cd06bf95e5adb2d698cf6ad81d204a1893776b8330909a962f3c09bda797230e52993c89b7006c561fef62c79d49a352790dfe91a6174dda122d7935bfa0cfa41317856321e3e23363136d031c60dd175f8c4ee94ec56bc768eec3d820be0ad623e7ed3972b548a1d0d877e60ab477561390e2d165ef0d41d88ea6261e3fb971f8004898cc498fd30e2f61d864e82fa6a74902bcb4b72a87e3acc361a9ac045a13a3ce414824ceba4113ed1f737ba7df28e0c7e422305dfd2a8e720c7601c52a0f35e04973e1cf895ce245f5c9aa08d0c3c80fcf15ed2fb2727dbb4209cf461252f20e8528b10bd941068925acd8e6db546a061457401b2fc65728da93ba71e004580c49771972db46dfbf73b8a24e16920b79d9efab1d8375c322c8e86cf48ad09f2d5fe2419120a3178a64d20141646f2829e8e9b0c6a239b9cfe7eba573ac2ce3f7a6cbe422a6d3114bab54aa6740521cdfa2dc222a3c8c519b6af098ae4aec1b4f0f9843fc6eedec853d1a6bc83b20486f4023c1508843ffd2863e251691939138839b751f8c72a28a749297a08de6ddeee91da1250afbac4b889bb00b77bb4c16e942dd5b076213acc824deb18c178cac3b70fd90fb1326059486405cdc30fb87d220fd7db64c95bd0d348a44cecf2ab75dfc6f7535d713b605058bc1266d381a9d3295d14ee9e6d2f2c991d010fdb5ac0b7e20b12b856a83616e17bb56bf0ffea37fb8ff96b59ec4431e855ac535477b27e200899e6e6791a9d90739e748826b621298db6576ba2f0de22ea6ccb643c7aac138bc4878bc0aa4ea4982fa91e4139a0120b3a877e47fa95c28481d4556e6bb53440914167a42c489e8a11924702a528c115da778884a7c7415607d48e62af3bd52a18b1c373e74589ce08e6d5f43c935229894a50a21f80d72be31b5a2bfa82d21553944532920de7d24b1c39ae52ce7cbfd623fb2400e6631e4561fbd64cb35dcad2d577f6a23a4de72b6d480e6f30399e828aeca3bd9809d37e35c1a1c67a3529206e8adb2273ade494c37f13a2aaeee7f417f0826aec1c01830c82fd8c341913f2cf61cefd39c347afd5149aee13340bd8e4bc23c30d8e6492cab100418e374c3b97a1c0e46aecf7d64b928274ad2d4089f38c7ed89c34342e6cdb9f095f21dd0203a223bb5d129112f416ed16af16e0b0457fbb0ca93dabf24aaf3293f743ca77ff06d8ba4e267f686d4ac0199fc9e014cf5b037267683e88fec815c271923059d5bb5ccad8ffe322e93d9aeaf0be19be503d7ad67052bdb4f4f006ce04f8c90b75619c82690960fba727d48d6abc1ca030e1a50d14d4fd5f6eaeee2bfcfb57614ceb9fc802f119a8322e271c09488a1cccc073ed31e0a872a91e1524ab6a77a170853afacf60cc67bd8915fd171b1040b3ffe02967c398a079455eddb837803bc38ea9df0c8ab202f71e6604c600e5da0c0445ad50cc17ab20b7d24b0b912cfb8055daefe4fb00be46bfd385428335f85a4977b24cd11681d0e838273c7e55418d92f490bb713001c58b94dfbbbce61dd2acf2b49ef192182cac0e39df3af83f19c7da34cd04b21aba36348c2f6abb1e89acf92cab1354b7cc55ae958cac087b25985d476a92075d34d307f9e283bb2aec501427943ad748298e338147c383a7e4bf58afd80ca522c2eb4bd5af87d787692f3500c20e02719deddd19dd83816b012421c72af9087903fc223ea56672a1d521a92b7ca85f4b8ce3c456c3556c6468887dfcdc4e3245313655d5e861f6b9ba64571be34bbbfb1a60a69f55d42e55b21dabbbcdc61ba1e0bbdb6cc37f8c3d614b242dd8995e117f986d003fc8585e07b7b3d3b4bbe132685ec56a0909414da90dce2e8d9ac7b58d8f65bf753aed30b70483ccae795e6dce0464e56c0f60758bd0b5cc37f66d20a4cd440b570a699f9c4bc83a0a0b9743b485436194faab725b467afcf9b88fc7dd59e89faa6dc7ba5f186315fc68d5b0b95b312f3b5f8c5b2cbb39050e7ee08debc6a9fb6d8e1832e3fe062ea94e524f090d1dc122c11ed337dab3c6c5908e37dd5b5fbb9e3d2f66f98147ef4f5d0cc2f7f6520f951762b23031f33aaf99f57eb962af842631ea92253320bb48f0537b5c58423e7c85465e8b9503290665108ffe123a11fc3701987bd24ad12e794865cf9dc59789b8c22de1e58e92a350ed3c40990f09ebc81dd9886c1553d786c09e5b6de29d4d3266130b87f1ef15083ca26defe96284ea5589ab2b95d6ff7c808a2db526595397e05140936428bb6832cc170bc020ff8255a8be47c1f5d3efd455c87d6ed1842f18e39be1eb2df23766903e89313f78b2633728073908dabf7a1865a3db4139fefc40d42ff2d127d2a60b6454719d260951943ea5aa21de940b359ab6f2b8e922761448d8dc4b4ac25cab03aa35c977df8156da88eb91c7c1f9cde912edcceeb90f0ff7b46d436867c18ecfb907c4a0e433235a30e8227b3dcd82f67945eeb966b821e2d7ed06357ea6e0f634c0b10b2a99386d39199f413432c139f94c2d7e41bf935a01306ea92ea122e224db0ef83fd5a7d02c4ff0f5070ccefff27b1490ae5f7f5185e0c81ec7c24396dc7d8527dcb16fcb7dda477fb80c9f7bf23a4b74d4c64856e99a4a2bb40065badcd5256dcdd26a2ed1a20c0d50228ecd89ca0f6649c3213692a6c0be4fa49eb1ea73376ee152027c17fba4bc230aeff7ec799c76c919fe43b455c6089ae214393477d0d408a215a3d36ee0e437048743e6c1807272d92904989e65142e0c4424534442e3530fbe927f20e2ded56e71beb70df8a88ee2000faeb80e2eb4606a4f6c06770ff0e1c62ea6c68bd860d4347c487acc2bddd04730395421ba06160352b2b7229a7b65e3f6c97853f4026e10741e68070a78018520f67bba4aad88d9c3a51949ea550ba6735877adef20ff00c48ad4d0326efd773df3f8c4d6f357d2be3cbee99228142d9066b169dd596da7720c15f29315f82a3ac724a273e906ef2c0d7baf4aff1327465804d738742eeb70107d28d13186a346eeafeeb78c73bbbd4923c5a0f8c2cb06d9e629d1edca897b8fa6461e8c74e1095c893d8dd19542717bcebafc5902c26edc4af56ca5a32b26d28f5cbb10f6fc2fee05b7babac8a70aafc849f5f3c6f03ac5499f9bf8691da13832558a1ddd53c0b847014e4a138779837667db578d2e316126fd053cb75c7f8bbd81d93d6868a2d9d86b7ebb240c857db046b5e79dd0a2f95bd8fabe405afe72825ba770b96b74bc954e7c874dec497a71791537537a6aecf84152522f07f174608c36f520b4ae6a705af7973620d81423ad683b91349fb5d0d468d1587ac09c3379c0358ea56f52bdbf9c0e473dd189e4a6e4603c49e1bb6f4e5ee14253b0c900955c5b404de2f86db623e65096ab982df6bae49702912b4720174f3017c5280b4917daeed034dbfcdc028e323a4da4231bbb759f0ddcfc1b2dcbb6868caa204a14b1be670283c95487c95266812a382a2babd45b106094e0e8713fe5b37ae020c4e71970cd84ea473ea823cba2d19465418e4f261faec2d738d1b2bf380eaa95fcf3dbcb88404e43070905de767aa608e68a785ed0e1f7d26d0aef21c3466ea30ec6e8277d92788375836af70d123bf40f052737b8c4e36dc8a6b93fd933c0af5e4017795f5ebf3359c31cd6bb9fdf467164e2c4370c553cbe2779f8c89e35eccc80ff8214556c3e92a8a722e5179c6605cd0aaaad4df699ed97460e97a85dc0bbdcb3e28bcb1fff20db3c633caf838f1adf69efb952753d5f7dd99dcde18f9587152cd2a6eeb4b60f1d0214f2f1f38d7dd3d1b3a03ce9996942add0aac74833a994ee81a3e11406e575d5df69e09eabaa3b8b859de303ddf41125af3085a7bdda2ad81d9e3f7e4cfaf25aab685cdf1ae726743880102d09a652117e333d7868e11bd40f1d9c27da2c4a4edd777699bf607f674fb13e8c1cfeaf37aa7f181b86549d296ef8a5f9db28be0756f309e7f11e11cbecfc87dbc163a5d7db7ec1c0f2ce2f7605ebff11c46b9608fc8e151410333227b3604fa9d0e53d7e046f28f585d6cde5cf49477993b12172b5e411604ae65fae1aebeb40a2a9eb1009136a261280be8971166e48485e85c1d43b50fd31c5eac1799d5cf1094d771e1d451f58450aea06063215a84a9b36061a1f551cd93b8029132f53d9c769a84b3fc0c9ea9b220c91571d16c890f3c94638a72e1bcdf27a01fc22b824a80bbbb93ccd861481c74829e2435a497c209b533013313ba4357f8c6b9dc2f689215d91e1d958f8bc373a046e039c6a46af50b735e33ebbd4746521609974d0480cf15d406be3fbdae15cf8d888d93cae4caa70441425fd3b3bc4183b30bc130e5b215476fdf9c7510824e007dc87f6e95f8c8aadedd73f1fc9260d450ce1224edf13d587eb814ba620cd57463fd88eeeccb0d5b8c7a8dc949f964d5842c1a6297e7ce581e776a95cbc24258206925ba0e250773662cfd084bbc38822c813e2091429104ebedd8a5932f664e1dca6c33a8722b7cc5e8195a5675bcdf8d7a776e5f943b9ebc3276062b4ff68d0212922e1d078f1b78bfb600287c42a63b7e0c016ebb6b8a22834a68ef7b15d68e61bf70680b01883ae180323abed9a1d5b89e199f10c863394d34ddd6caef7e2359683a585ba0c0f5d9f965e7d9c2278b1b5fb3a8486a680b1d25cf0622a9474ce4cdbae605a75a1c6f125f236306b1722ad6ed9deb8c96a02665100229bebb117035cc470bc3e3d87e51948f4640789cf13c129577590795bbd66a9aa8a1c6a37815cf863f5fab93b715bef7f4f82db0114e4de2d1995619cb084eadf6e67445bbf02ec0335ddde23ed2a89f034746789aafcf530bae4f5ea819854f89fdeeb1102b72eeb745739c4ae8b076094713ced763d6a7540eaeab75c52e38631f06fbee36ba9bb607d5338a19cd35e25507b12b6e4fb9c2b8d436bb9b55dfaf0e3fa6e49d12494eee77d4d713322d7c380dff40a8e23c1d264592c81e1db29e1716c824e180bf63629b25df7dcabae36170441e7a8c2b0d7318943d706bfbd9dba65fcc62458cf93366a0e378e407c808d0843af21bb262e75badc63b4ea7b065bacaf09f2bb9da4eec31947123279d9cf4452d543ae61dbce969c3f695ebb0c3d8418155f571ef87e6808740d8b4fec674aac23a51958e19b7f734d208a8e3986fa048c2abdfcd1da7430b2e577ea41ee8046f19bc2bd3a699db353b8a4b4c78df56f6ef9aea784dda7a7e1c89afc9bd297ebb8fabd1416b1705a6f45609962f3bb5e13f74fb5741215db8b4752d746f95f855384d3520a814bf33afdcab783c10c57f76033ac015c0703148f164cf7120bb9f63f0dd93cdb66c67f00c331cf77d49f665038296307d100c02d65c4c3c7afa0eb2d0118c6484e124ae319a8fcc776c09b469380db0fbb6fe895aa31825d6d98277c137f2b29606e2e77e7d70477a9f2f102cf3e1c4e0055c072d73b3e3e6d69108096084df8e17b888002c00d92b234711a3884242f2a4bde059e40183a7df8b9f60203f62d5065f768c670a8930e949c602a5c445508a061ab15e085df84c1ad1fa1036cfee644c8e741f4fb19c70da121867835574ea3135c4cb68e143a2932f8efe0c859472cb9d482d517222d0587916b81d6cd2d4fcc1e2c890de0820cd6dff9c1973c1c74202c17b942b949090d2116b42c3fff95fadb805018237a844cd1550fd01447eee012fb3e91db5307ea971ee20c2a57feddc2c6849a73d059116267233df495c38721f4f611330375f6f6d2383eb7e4e00ceaf344c6ce279ae9fd097eabb16f594f96d520cf50628066710777ec4034e3729d18ee9ae2c2a1d6c85eef700086e9924b139af3a06679cfc66d286eae1fc6748a96dfb897f50dfc447c09c375bf8f7488f55ae3988f47071c4e23e8d6f2579d087b47bfb5c583a5e3782b8e4044bed7ece57e8b061fb68f0a429d4d78bd73aa3a081d88dfbc0d6eef100c9fd14bec497e9103f5479b525e83d9d6952cfc6a3687fb87c74ce8b9355245f3faad5491ca4ee2978228abe2788926352a74cb0c12602eba4f418fa7b8d62f0a723046b2f961ca329068c1105192bd2c5d60b398f3ede5d67bd2d6f773cbc94b1188b7cdce3b91df8612270665d131bc0e405c4c781ffa7446afaf16cb5f96473fe0388fa92451ec3ae5a7719b8dc06070c18b5c3ab7c9a0dc64fdbdb22e1ebb323331d04619ecbea25cf7a0b00e39ee59af1d71ddc260abac4029166ec28f42939be78a055addeafa1e93068310d5389a137ea19b916e17d350e48909c30e4fbbaf3ac1e8b606250fa0de683938cf3f99a00b7c6feb50ae9ac042b3db9d81cedd854488d1acfe8402b2af16a8de5af4bebf6994a31e46a6857cbc5ddfe9c23f1164004d09cfd98fb53595c534b0c50196e155caee0ffbadcc8531bcd2216d903e2657bf93581a9c216c9f1c8c4d9438a2ca24c1a276d317e14033ed802b46d970408f48cb5e650829c121a7f9dc1af5cfabad71877ae934f47ca58df12133bedd89b5737d8921960f54f08d4e3722ad2e3c6c096f36981df26ca0e1251f0eef6a112ec60a68c5fe9a76b7f7665cbf7b947d63c2f0524d294e823e379ab934f5ad1c2c43fd62a5d80bf31598b0dac36d25a9cb37e026f49fd8fb21eba702e0fa542a64fded2f4b6ba7872eaf8b066ef1dc7314fac264d338cdbcd32a453f868085c39a65e03af2ece576a9da9466579a83b3f5523f2212148c7d2a0b355651134aca4222ceddc3b6d4b8eebe44114777758d154150c536a17565613dc99b256e8133b9e867abed6f4465cf78d51cb0321967d97a55233dda5797a981d1d880d8e61531ffd588a94a326fe27330392c005560b69c740c13d63c371543898127b95cc99c59af041627adb032daf0341f6bcb67070d291ef5e4a1a88ad440f9d0fbc1084a0689b3defbfb05ead6bed12d3a6dd9bef6b052c86fc015de4cf200df9f209bc9d42fb6f4bade62a344e09b7f00028fe4f249dbcf1279ec31892b39f5252fc5d5ec8aaf7e6cf76463def7f4aefac90b07bade72d7525c643761b5e17c930b06bfbba92e59f9b93b8e0add6b5135db366bb4e82a4815dcebd5dad99cb84e138f1c3977ac2da2afeb228ff31c2d5d63e403fad96fb6f8e4b390886ec817942f7905439d402aa0a02c768a3d4371b8a8e0aa39d3fd62e1eda28f6246d10ec4eaa0d8f676b5981c3f028bc95e2472b4bddaa10ccc375cbae6d29e6b018d94d8c1b75fa498e46c530a98515a12928f0075c6bced1a5c962beb44724bb811ea0f29f1e36855f7881c7f3ee69c64d8cd84ecddeb1e63d9405b9190a11c761f1089aa60459611629fb501bb6cc3c032134236a6f87aecbb0d8ff99989303134259a642ccbcb9536897a3b56d9b8a0acb1b7baae66aa60b0d9574821c97a7347b3f989bfdd449d447268e9b165bcdb269698db97de74ad06e9b894832a148556a2cc5fc6d5452017973580c737568bbfd12617b26020bcd793f9605bf33525f7e25dc68d7f976aa7a91281c8118dad14aae6ea83d52d6baac8faac0fea98942144a329806db16419f6f1958fc5c05c37887433b8d5a6460e0985435e13c0075e1b579cd4780a7b0c4bd4685b8584b4641cc79a01049df06543420f978ec3896fc01d2d3622a2e330cc93152e0f05263f53a86540fedb4b08898dbad88294f1c1fb2050d89082f065beabea4e6a767bfb8c55dd29249543c21868934918c53dd5b73ece7a5b3f5109968557f091a7ca2ae164659ad229d52adb5e99589097328fffdfc72183a8c54b0edea9abaf15e80babba0be95bc4070d64c137a1c32749114b027ebb55b9e7559fd9628aad30bc3c8bb80ee79b37380f71e9b1553f0027567dc20322254e7be325aaaf2f49b9dc93d0b79e67d65164cd36191375eb70d420d5aeaa4cec7b3d671d77b530b214b01cf36fbd7f1d4f0ed6411f2f73c4c7449af39c41de38d18a847141ce28ea78cff1bc45debfe757fb97464fd85ab38a5c6423a638a22131520ed321a39a328ea3d8eae51f50bbfd3f9e058e44c6bec23d6ef017c5a89cba303c9e81dc82c025ee19c23bea0ec1047760916b7dd38c90ab4848db163ae9b819e04e7895cab25a3a8855c1d88ee50d53be962fe67c93f7c67a7cd84ed06b36c2520a78df9955ec380ffcbd325bb9910fddc6da63881f2f8e40b2f87eb2c062e61d52f26b36e59ac660eae1a0c8e40f51968dbf7a7d4cd296ea805576181b9cee1877b67bb21c7fce5724eb44814b66d6b8fb11af790bae317ae00a1dbf6bad262c0e98246d25b1e2b3c076e20c0874b7bbd870edb5b7d0aa8deadeedbbb82cbcc275821394b44cda033f46d40b6776cc002d568eaef8d0166ca02a0d53e5b74a126865e189c33f5f82cb6a5af69dcf3cdb135887404049a384374143c46151246880e2777df2f751a2ac4e67e04d43d5db88a957eb5eae3fc9a50f27096ed461446d6cd30e55a59b8ba50151b33ffad2779e40ac344a1201a7703371ec9765bac22ad90d50a5c2724d41665384827979f644aa494730e5568da45ff6971de8e6a67ab0494f0a157abd468c3d15d7cf1fa703fb53a95e012135a77f72648e70ad11397a7b4be1d8e2f35eedf006492ad1fa87bc5b6b3802e18d5c2abd13387f26c7e05b8acbe946992b148889056168ff59de7c2e4f066d45ef21b884c9eb1ca148d5bf51601552b89e54507ae19ab5486fca1dce2feb4cbd1a0798d5c2e4c588e33156a1fb3c86ed716df3ac8ffae2cd0f3cc868df18ab8d9aac3c3d01d081710cea74471a32af87bf955fa875c9d12215c5859d75c70dea81251dfa0e42e740ad0c0c28332ed9f3561757287cf891f4fd7d8883aee4a0aa2a3f8d658056ba732d19c15be6c354fa651df0fe0c0e26f87c0647d60a08b3d02da2162f0d25be6ed4e9a45d4e5b548d719706a616faf9209b8911791a0ac6f698765d4db5b1d280131c979067811940f970db9962e2435930fda6c8cb9b8b2d445a9f9a63098fec6f15cc8ad49437492ed13ba48c720b897981ef1dfdf68e89abef88e56e8232df04dbda84a54b9585f270371db17b71187cff702b04c8a4861a00888c637e7f82941318dc502b90188e7c4eaa9f3550ee1dc5269529b8e902ae8fe471b5f178949b9e049fb175f99095f1bed734f481612f552929e2067e9e2bed1e0b22280f025629471553edaf25d90998198913c5e397732aaefe99c7ad50c405b67db2e1b64923a289373d4ba3d5a5e494ee20f02917c4555b72df3e3e187404095d7cb85eaafa970801487de9dc359520a5419a3bae35a2298c2c20c98d1f627dde9f2f906c790f4d8ecec0ff2d2d5fc2adb06459e79b17e8dfab02919f3c632fc4d40d364a3be5797b14084b300d4825d2e1dd5ab7fbf13fb06e6e6c80571f657ab5dd2ada53f07adaca3bb14418aa882013db3cb02cfbfd453b00a0344c250aac63aa24cd5b4b60692ddd57dc4977c924a48e3a157a92e5cef016b05ba2c2b889586c4ecac13317eee2893deaf2280d542ccefb39c6e6f7a62917d3cf9ff1acb69496e537a8235638b38f6a875ce081165440ff7ef817d908d038cfe1e7699a20349dd2fd8999e9e69f81789a2a2ebfd0b1699fd86d7bfc6159975874dfcab52191a856e90c272ddbe797933634ce0e083be38485b364809e085b7da9efe2f2d44ca3b31a679177ccb214e1825fa0ddc9b0a7298b3fdc5db66b7bc7aec5c1735a07814e830be1916fd8c4ce8285a2e945407a5464e5d8c20937447ab0f16ceff19fcf6ff39a643bbb67e5fdc8babc3a7a7e451b683d7bfad740c10c91d9cba4d271c8a21e9a95190f0b2d47ebe235a6c3121556bd4e5987c672fd2f4c19111eb0592d48ba33dfeed36ca4747086039a8fdfbf50700c6b874cd3a476ef853ca051fcd0cd516497c804284a20f681e8f676c8c79db592618dd97e0e9853ea089ca6fbe3f948d975a38c74d99e2d355a37b664300012d06288fcfa3164bc405b90871c037e5fb452879424efea3e240003c635f35a8445aab1469f4eeb5bb54dc7704b2fd7ca1b5c189644e8e210d55e823bbdd0dc1617d0d562c036f77d8ed9d6e4d014b4a77294d76ec5f9fc3e6f9257816d7e865a399dd1edd866859a8e36e01347c9f843d6cae1d929c954058904c27e195a629834ab2ac3df0a029b115e5e831d1e72dce1365212c7acfb6d3cbd757451d9370536f30f4446f345ba2dd5262fb5dae3560dfb3251877b98260960df4d72923cc6490250b2e001a2499eac7edf396417dac99e1ee85fc4c319d8c4a3d4a7a8a4e27631602a0a3da8e798ddc531fd999d2d852992355ed680478764483e86888e8c72496d8d8aa6263e9735d8f0529e29ecf29dd213741442e059dc691770863aace36dccc0419edd0f64cc80528da154053b0197c224a0375d12d7982aa2eb8f6240f12e4d185805b7d4c869052ac9673978383636583f3a15a838983925b7fea88088ba7bea23c375482c5e0cc91e9fec6835aaddd2cd98fa11d8ee9bc80ed340a6d4009fc30033c504c780296b7f88290262f51eec1457c912c33ad290a23dda9c5bbde587b1aa4ac293a48955652d349bbb036826f8d5ebf5da86f31a56b072d1a3f77721e1454c99166375fd260921ec6f0cc985f32beebf5157820ca4df578151ab4b000ad5ddd8df0bf511166afd1235f964a7a6432d2152dad58aaf91ac82504cededd89417a677087d7e8e9221c304d8d41a9ee1505cb4a92017f276eff0fdac4216930b909f4cc0e15ee69826ef2a156bb465594f491695d92b8474cc1bfc7ddaa60e76c8437422b78954b960fdcd053134d65d83786cd80587d8b083c02f76506d37ce0131d82c4dff3b97d07d1a7d5d3015d0eb07efa91a2b1d1ece3a7415f4e6ac20c99aab8be0d6484efe8ed7d6b78c9e7515e917de006a9765581fa12275d0411e418918cd69fd9957dafc91611abeccae0815ed70c97d0f0658a6b184172b2c49a3b352d20aca79a218faf5be0f3c2e5189913ebf1b3772aaea50e5dcaf7074ff56155c950bedff2e716f024eccbf108641da5d813729f6d2c0825756797225c93027e2f2c27cc6e534f07970a2e02e7379aa0df1aa83d9bbe3f18faa01dd566f692588c99c0d888c43a449dbb6847ecbf5f65e9177805664576cfe7d4bbca4f981d5b43339e3d0be2e5c79a1a1d61132e4621e190f31265fef382c5d11e8df40d3f023f7fb0d176b66cb17c0d4b16609fa295888e13be5dd931c3f4e333336198dc4c4ebafbdf9636cedd6dc9a7d84ebc6d86ed7247be206888119897a1d387c1f122ef6ee39f6db6c3adff6ff45cfde03213ed1494a068a14c6b02ee223cd4d1edda47db428e2e0ad7861decb492dc2b29d56403cbdecb9dc44eac34412ee67387b8ef08d5b8d76ba8e7b49a2df41083866886dca288a271d903f15ea2bafa20bfbe40becc99145c35bfb896beda99d233f1c20fb871c76a780f161ee659b2700b5869d5ba9dad8a3e23ad55a0b12e2eacf87489c8772dbb4d4e34ead6a67cdd541de894ebbca39305533c7de16b0427e9c74002f89d88289ca1fa5ced772322fbce25aef9fa218f767022a87f852469921535d64c95100b89d59ff1109b35a2db2bad79c9c919913b07aadbc101f1180cd8fea985ffdb151597a31a8124dec3ae14ad3f499c201efe318466510edd8eca4800c0b4a8c49cdcafd177601bf6964a901435cbb28c594728bd45fd0b3f54589e02183a2b720835e7816ba9c1f54db9d81644f5ae8f8708167a6bfd05659b9d0315dbd1384bd7939d029b5b428bb67bd9958f3fa275ffd7bd9599906b011b74fce7262b8cd98156fc90b969812486445bb8c80f8c28a6a2ef218e563220e64edc8a020d1dc4d92577d268f10808ec719aa8e4a399ff00a9de22c6ae7d5162c13a66558357542f3a58760e8d3a2b50cf38c9a11970bf3246cd56257004bbc8dc2c302479af34666b278df067b84dc1b05a3f19d7a5a692cd8745201ffc85cb0992ce30aafe8f25a0a128489a2ee98c1cfd12d1e3e0045fec2ef69c4885c0b25711bce6450b35aafe7ab94c7edbd7bcb5fd1ae2e95b95d80b02ac2bd361f036a7add62ba2617b87742d4eee1d6aa0c5502698352da3b28117968f53576c5b64615357748fac71ea0864ebf8dd2a9e6ed9ddd7f55b603f29204e2821190051f22b31cea461e081c82ef32251ef8ff1b7a7c6f6d222a9e209d57d6dc19ee6e0bc4196a48ef46b4bda7f75a9f76962cae5304f87a475b598d0e61fd1658add046dca642fbe56e1bbb8b3c300fe46d38d2e4de5e85e6dfdf54105240dcf73fc80132a3186d7f8346e07588313c588a2c997ed7574929c1a75d8634495f2ebde1e2de0c4ebfaa9c65655e930a69696debe57d9f10cab853821a8113f1be9f7459507e9cc621ba98b87207c408039fa60309a91aa2e42e5f5af383e1c293f6f659d802f8120539a84b8dc84e8201564e0295dabe1b90a170d23c532c7c970ea6a37285b274387cc3c5add37e72e13f71676d00bb2c2f409863c01a64eb449bbe121956dc0271226caefcd66d1870b7653d16dcee879f1363e867053085b1b910ad8881b088e9a7c2644afc9428125de9547b90eafee0e69624c6778dcafd38ae80112702769d0e828cfcbfae15b84fa63a704b5b27efbe478e997f4e2f5030279322a5c3b517d2189954db8098722c139154bfcb9ae1b58c9221847a5fb44686a1ee8d015a6290e6a77c5ad8ad1b51b0e28bc7f13e4a5e7259d16cbb7fa272e77e11dee488961063f97e711972f057b442f8ae1ca732202978b02d0549d13f2758732940024c94c136cfe6a67e112576380dd8c42987ca1ecf13b39a8089157235e35a29f489d201699f15f73095d3423541129c92d4ba50ed533a971265daff04b1ee4c1d2bf6ce60747d4011e89855f50960a5eb9087952ecff5497c8c0feec15a161affe76ca66b369a2e96e044b634ab82d326892aee98e5624de9465d38b3d3b8971eb35bb5157f96d56e579e48f7ede80c8344cdb2df524ba5239efa0b40c660a14968cf1acfe11c2f3a7b104bdb54c8f36c9e29ed0d4211bd2d167f3b7724b360a253d5c668650f1c5c2ac53ff06cd7fe1c83fb0ed406f317f47c2cfe6f66b9818ac6fde2d6a40521693a46ebebc9a9ef6e7ef05c0cfbe468b51ce8c1e5c6d02d5f8b2ae9d940f8b083047149f51809702dfb3f00c91791c15c116ae9edc0c2e11e1c97a0217ec71164bc4961bb46a27d216edc18172983f141554917e9d7b244e1c1e1ad651c123796c235c578555802f9050445ab353257baf1115b728ae4fb40f1e</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模式识别</tag>
        <tag>算法</tag>
        <tag>Private</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的upper_bound和lower_bound的区别</title>
    <url>/2020/09/20/CPP%E7%9A%84upper-bound%E5%92%8Clower-bound%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>在STL提供的 <code>algorithm</code> 头文件中，提供了两个函数：<code>upper_bound</code> 和 <code>lower_bound</code> ，这俩函数功能 ”类似“，但并不完全相同，具体不同如下文所述。</p>
<a id="more"></a>
<h1 id="1-upper-bound-函数"><a href="#1-upper-bound-函数" class="headerlink" title="1. upper_bound 函数"></a>1. upper_bound 函数</h1><p>在 <code>STL</code> 源码中，关于 <code>upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__val)</code> 函数的说明是这样的：</p>
<blockquote>
<p>  找到最后一个可以插入 <code>val</code> 而不改变原来有序数组的排序位置（Finds the last position in which <code>@p __val</code> could be inserted without changing the ordering）。</p>
</blockquote>
<p>来一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         *upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数 <code>*upper_bound(nums.begin(), nums.end(), 3)</code> 的返回值中，指向了 <code>4</code> 也就是大于 <code>3</code> 的数，从 <code>upper_bound(nums.begin(), nums.end(), 3) - nums.begin()</code> 中可以看出返回来了 <code>3</code> 也就是第一个 <code>4</code> 的下标，因此 <code>upper_bound()</code> 函数可以理解为：<strong>大于目标元素的第一个数/位置</strong>。</p>
<p>翻出来源码验证一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以下程序来自：bits/stl_algobase.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @brief 找到最后一个可以插入 __val 的位置，而且不改变原来的排序</span></span><br><span class="line"><span class="comment"> *  @ingroup binary_search_algorithms，二分查找算法</span></span><br><span class="line"><span class="comment"> *  @param  __first   An iterator. 一个迭代器</span></span><br><span class="line"><span class="comment"> *  @param  __last    Another iterator. 另一个迭代器</span></span><br><span class="line"><span class="comment"> *  @param  __val     The search term. 寻找的项</span></span><br><span class="line"><span class="comment"> *  @return  An iterator pointing to the first element greater than @p __val,</span></span><br><span class="line"><span class="comment"> *           or end() if no elements are greater than @p __val.</span></span><br><span class="line"><span class="comment"> *           拿到一个迭代器，指向第一个大于 __val 元素的地方，</span></span><br><span class="line"><span class="comment"> *           如果没找到大于 __val 的元素，那么就返回 end()</span></span><br><span class="line"><span class="comment"> *  @ingroup binary_search_algorithms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator, <span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _ForwardIterator</span><br><span class="line">upper_bound(_ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">            <span class="keyword">const</span> _Tp &amp;__val) &#123;</span><br><span class="line">    <span class="comment">// concept requirements</span></span><br><span class="line">    __glibcxx_function_requires(_ForwardIteratorConcept &lt; _ForwardIterator &gt;)</span><br><span class="line">    __glibcxx_function_requires(_LessThanOpConcept &lt;</span><br><span class="line">                                _Tp, <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::value_type &gt;)</span><br><span class="line">    __glibcxx_requires_partitioned_upper(__first, __last, __val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::__upper_bound(__first, __last, __val,</span><br><span class="line">                              __gnu_cxx::__ops::__val_less_iter());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到的 <code>__upper_bound()</code> 函数，是实际的用来查找的算法实现，具体实现如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以下程序来自：bits/stl_algobase.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">_ForwardIterator</span><br><span class="line">__upper_bound(_ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">              <span class="keyword">const</span> _Tp &amp;__val, _Compare __comp) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::difference_type</span><br><span class="line">            _DistanceType;</span><br><span class="line"></span><br><span class="line">    _DistanceType __len = <span class="built_in">std</span>::distance(__first, __last);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面使用二分查找算法来实现</span></span><br><span class="line"><span class="comment">     * __len 右指针</span></span><br><span class="line"><span class="comment">     * __first 左指针</span></span><br><span class="line"><span class="comment">     * __middle 中间值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        _DistanceType __half = __len &gt;&gt; <span class="number">1</span>; <span class="comment">// __len / 2 操作，位移操作更快</span></span><br><span class="line">        _ForwardIterator __middle = __first;</span><br><span class="line">        <span class="built_in">std</span>::advance(__middle, __half);</span><br><span class="line">        <span class="keyword">if</span> (__comp(__val, __middle))</span><br><span class="line">            __len = __half;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            __first = __middle;</span><br><span class="line">            ++__first;</span><br><span class="line">            __len = __len - __half - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，可以理解 <code>upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__val)</code> 函数为查找 <strong>大于 <code>__val</code> 的第一个元素及其位置，返回来一个指向这个位置的迭代器</strong>。其底层实现使用了 <strong>二分查找</strong>。</p>
<p>其实，在后面的阅读中，发现对于 <code>upper_bound</code> 还有另一个重载实现，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief Finds the last position in which @p __val could be inserted</span></span><br><span class="line"><span class="comment"> *         without changing the ordering.</span></span><br><span class="line"><span class="comment"> *  @ingroup binary_search_algorithms</span></span><br><span class="line"><span class="comment"> *  @param  __first   An iterator.</span></span><br><span class="line"><span class="comment"> *  @param  __last    Another iterator.</span></span><br><span class="line"><span class="comment"> *  @param  __val     The search term.</span></span><br><span class="line"><span class="comment"> *  @param  __comp    A functor to use for comparisons.</span></span><br><span class="line"><span class="comment"> *  @return  An iterator pointing to the first element greater than @p __val,</span></span><br><span class="line"><span class="comment"> *           or end() if no elements are greater than @p __val.</span></span><br><span class="line"><span class="comment"> *  @ingroup binary_search_algorithms</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  The comparison function should have the same effects on ordering as</span></span><br><span class="line"><span class="comment"> *  the function used for the initial sort.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line"><span class="keyword">inline</span> _ForwardIterator</span><br><span class="line">upper_bound(_ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">            <span class="keyword">const</span> _Tp &amp;__val, _Compare __comp) &#123;</span><br><span class="line">    <span class="comment">// concept requirements</span></span><br><span class="line">    __glibcxx_function_requires(_ForwardIteratorConcept &lt; _ForwardIterator &gt;)</span><br><span class="line">    __glibcxx_function_requires(_BinaryPredicateConcept &lt; _Compare,</span><br><span class="line">                                _Tp, <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::value_type &gt;)</span><br><span class="line">    __glibcxx_requires_partitioned_upper_pred(__first, __last,</span><br><span class="line">                                              __val, __comp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::__upper_bound(__first, __last, __val,</span><br><span class="line">                              __gnu_cxx::__ops::__val_comp_iter(__comp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个实现中，可以使用自定义的 <code>lambda</code> 表达式来替代默认的比较函数，例如下面的栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数 val 就是 3</span></span><br><span class="line"><span class="comment">         * 参数 b 来自 nums 中的数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> val &lt; b;</span><br><span class="line">    &#125;) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它实现的功能和默认的函数是一样的。</p>
<hr>
<h1 id="2-lower-bound-函数"><a href="#2-lower-bound-函数" class="headerlink" title="2. lower_bound 函数"></a>2. lower_bound 函数</h1><p>对于 <code>lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__val)</code> 函数，<code>STL</code> 源码中是这样说的：</p>
<blockquote>
<p>  找到第一个可以插入 <code>__val</code> 的位置，并且不改变原有排序（Finds the first position in which <code>@a val</code> could be inserted without changing the ordering.）。</p>
</blockquote>
<p>字面上意思和 <code>upper_bound</code> 函数很像，都是为 <code>val</code> 找到一个可插入的位置，并不改变原来序列的有序性。但它和 <code>upper_bound()</code> 函数的最大不同在于找到的是 <strong>第一个</strong> 可插入的位置，而 <code>upper_bound</code> 找到的是 <strong>最后一个</strong> 可插入的位置。对于它的例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于输出结果，不难猜测对于 <code>lower_bound()</code> 函数，找到的是 <strong>大于等于</strong> 目标元素的数值和下标。接下来从 <code>STL</code> 中 <code>lower_bound()</code> 的源码进行分析，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  @brief Finds the first position in which @a val could be inserted</span></span><br><span class="line"><span class="comment">   *         without changing the ordering.</span></span><br><span class="line"><span class="comment">   *  @param  __first   An iterator.</span></span><br><span class="line"><span class="comment">   *  @param  __last    Another iterator.</span></span><br><span class="line"><span class="comment">   *  @param  __val     The search term.</span></span><br><span class="line"><span class="comment">   *  @return         An iterator pointing to the first element not less</span></span><br><span class="line"><span class="comment">   *                  than（不小于！！！也就是大于等于） @a val, or end() if every element is less than</span></span><br><span class="line"><span class="comment">   *                  @a val.</span></span><br><span class="line"><span class="comment">   *  @ingroup binary_search_algorithms</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator, <span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _ForwardIterator</span><br><span class="line">lower_bound(_ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">            <span class="keyword">const</span> _Tp &amp;__val) &#123;</span><br><span class="line">    <span class="comment">// concept requirements</span></span><br><span class="line">    __glibcxx_function_requires(_ForwardIteratorConcept &lt; _ForwardIterator &gt;)</span><br><span class="line">    __glibcxx_function_requires(_LessThanOpConcept &lt;</span><br><span class="line">                                <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::value_type, _Tp &gt;)</span><br><span class="line">    __glibcxx_requires_partitioned_lower(__first, __last, __val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::__lower_bound(__first, __last, __val,</span><br><span class="line">                              __gnu_cxx::__ops::__iter_less_val());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它与其中用到的 <code>__lower_bound()</code> 函数作用和之前的 <code>__upper_bound</code> 函数功能类似，都是使用二分查找算法去找目标位置。具体实现如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">_ForwardIterator</span><br><span class="line">__lower_bound(_ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">              <span class="keyword">const</span> _Tp &amp;__val, _Compare __comp) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::difference_type</span><br><span class="line">            _DistanceType;</span><br><span class="line"></span><br><span class="line">    _DistanceType __len = <span class="built_in">std</span>::distance(__first, __last);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _DistanceType __half = __len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        _ForwardIterator __middle = __first;</span><br><span class="line">        <span class="built_in">std</span>::advance(__middle, __half);</span><br><span class="line">        <span class="keyword">if</span> (__comp(__middle, __val)) &#123; <span class="comment">// 也正是这里的不同导致了两个函数功能的不同~</span></span><br><span class="line">            __first = __middle;</span><br><span class="line">            ++__first;</span><br><span class="line">            __len = __len - __half - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            __len = __half;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以分析得出，<code>lower_bound</code> 函数确实是找到大于等于 <strong>目标元素</strong> 的数值和下标，与先前的猜测相符合。</p>
<p>当然！它也是可以自定义比较函数 <code>__comp</code> 的，例子如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; b;</span><br><span class="line">    &#125;) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过修改比较函数让 <code>lower_bound()</code> 函数功能和 <code>upper_bound()</code> 函数一样，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         *upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt;= b;</span><br><span class="line">    &#125;) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt;= b;</span><br><span class="line">    &#125;) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过应该不会这么整吧，没用呀 : (</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p><code>upper_bound()</code> 和 <code>lower_bound()</code> 函数实现的都是在有序序列中查找一个可插入的位置，插入后原序列有序性不变，但是：</p>
<ul>
<li><p><code>upper_bound()</code> 找到的是大于目标数的位置</p>
</li>
<li><p><code>lower_bound()</code> 找到的是大于等于目标数的位置</p>
</li>
</ul>
<p>嗯，整完了！~</p>
<h2 id="程序源码："><a href="#程序源码：" class="headerlink" title="程序源码："></a>程序源码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/20.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/20 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vector&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;algorithm&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         *upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *upper_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数 val 就是 3</span></span><br><span class="line"><span class="comment">         * 参数 b 来自 nums 中的数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> val &lt; b;</span><br><span class="line">    &#125;) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; b;</span><br><span class="line">    &#125;) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt;= b;</span><br><span class="line">    &#125;) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;val, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt;= b;</span><br><span class="line">    &#125;) - nums.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>源码分析</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的可变参数模板</title>
    <url>/2020/09/08/CPP%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>C++可变参数模板，是指能够使用任意数量参数的函数或类模板，能够很有效的提升灵活性。</p>
<a id="more"></a>
<h1 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h1><h2 id="1-1-可变类模板"><a href="#1-1-可变类模板" class="headerlink" title="1.1 可变类模板"></a>1.1 可变类模板</h2><p>对于可变类模板，基本示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arguments&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span>;</span></span><br></pre></td></tr></table></figure>
<p>由上式可知，其特殊性在于 <code>...</code> 的使用，可变参数模板，通过使用 <code>...</code> 来帮助定义，其中，<code>...</code> 左侧为参数包（<code>parameter pack</code> ），右侧将参数包展开成多个单独的参数。</p>
<p>对于两边的空白可以任意分布，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Arguments&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Arguments&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span>;</span></span><br></pre></td></tr></table></figure>
<p>上面的类 <code>classname</code> 可以接收任意数量的参数来进行实例化，例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">classname&lt;&gt; <span class="title">c1</span><span class="params">()</span></span>;</span><br><span class="line">classname&lt;float, int&gt; c2();</span><br><span class="line">classname&lt;float, std::string, std::vector&lt;int&gt;&gt; c3();</span><br></pre></td></tr></table></figure>
<p>当然，还可以指定必须填充固定数量的参数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> first, <span class="keyword">typename</span>... Arguments&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// classname2&lt;&gt; c4(); 这是错误的用法！参数必须大于等于 1</span></span><br><span class="line"><span class="function">classname2&lt;<span class="keyword">float</span>&gt; <span class="title">c4</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-可变参数的函数模板"><a href="#1-2-可变参数的函数模板" class="headerlink" title="1.2 可变参数的函数模板"></a>1.2 可变参数的函数模板</h2><p>可变参数的函数模板基本示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(Params... params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当然，还可以使用引用类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(Params *... params)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(Params &amp;... params)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(Params &amp;&amp;... params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>还可以使用不变类型 <code>const</code> 来修饰：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(<span class="keyword">const</span> Params &amp;... params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>除此之外，还可以使用和可变参数的类模板用法一样，指定固定数量的参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionname</span><span class="params">(<span class="keyword">const</span> First &amp;first, <span class="keyword">const</span> Params... params)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="2-测量可变参数数量"><a href="#2-测量可变参数数量" class="headerlink" title="2. 测量可变参数数量"></a>2. 测量可变参数数量</h1><p>使用 <code>sizeof</code> 来完成，当然，该方法和之前测量字节大小的 <code>sizeof</code> 不是同一个用法，这里的 <code>sizeof</code> 是用来测量提供了多少个参数，示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tfunc</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(params) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tfunc();        <span class="comment">// &gt;: 0</span></span><br><span class="line">    tfunc(<span class="number">1</span>);       <span class="comment">// &gt;: 1</span></span><br><span class="line">    tfunc(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// &gt;: 2</span></span><br><span class="line">    tfunc(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello~YouLi~&quot;</span>);    <span class="comment">// &gt;: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-示例程序"><a href="#3-示例程序" class="headerlink" title="3. 示例程序"></a>3. 示例程序</h1><p>下面程序演示了如何使用 <strong>可变参数模板</strong> 来对函数进行重写定义并使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/8.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/8 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Rest&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> First &amp;first, <span class="keyword">const</span> Rest &amp;...rest)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(rest...); <span class="comment">// 将会根据语法来递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>();    <span class="comment">// &gt;:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>); <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// &gt;: 10, 20</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">3.14</span>, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// &gt;: 10, 20, Alice, 3.14, Bob</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>对于可变参数模板而言，都是使用某种形式的递归，但是它与传统递归是不一样的。传统的递归使用的是一样的函数声明，但是可变参数模板使用的是不同参数数量的函数<strong>（每次都会递减）</strong>声明，从而每次都区分出当前次使用的函数签名。和一般的递归一样，都需要一个终止递归的 <strong>base-line</strong> 条件，但是这里的含义不同。</p>
<blockquote>
<p>参考自 Ellipsis and Variadic Templates： <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/ellipses-and-variadic-templates?view=vs-2019">https://docs.microsoft.com/zh-cn/cpp/cpp/ellipses-and-variadic-templates?view=vs-2019</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的多线程（Ⅰ）</title>
    <url>/2020/09/26/CPP%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B1/</url>
    <content><![CDATA[<blockquote>
<p>  今天是预报名的最后一天，你一定可以成功上岸，矿大等你~😘加油💪~，相信你而且很坚定！</p>
</blockquote>
<p>从 <code>C++11</code> 开始，C++标准委员会开始关注多线程的处理，并提供关于线程操作的标准库 <code>&lt;thread&gt;</code> 。而在此之前，C++程序员已经苦<strong>平台相关性</strong>的非标准多线程库久矣……</p>
<a id="more"></a>
<p>多线程本身就是一个很广范的内容，包括管理、调度、锁和同步、内存模型等内容，因此本文先从C++线程中的线程管理开始，逐步介绍线程的<strong>创建</strong>、<strong>启动</strong>、<code>join</code> 、<code>detach</code> 操作。</p>
<p>当然，在下面开始之前，需要得到一个支持 <code>C++11</code> 标准的编译器。</p>
<h1 id="1-C-多线程创建和启动"><a href="#1-C-多线程创建和启动" class="headerlink" title="1. C++多线程创建和启动"></a>1. C++多线程创建和启动</h1><p>首先引入 <code>&lt;thread&gt;</code> 头文件，该头文件包括了对C++多线程相关的类。引入头文件完成之后可以使用 <code>std::thread</code> 来创建一个线程。</p>
<h2 id="1-1-外部函数创建线程"><a href="#1-1-外部函数创建线程" class="headerlink" title="1.1 外部函数创建线程"></a>1.1 外部函数创建线程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;   // 引入头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_task</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// 声明要执行的任务函数（也可为callable类型）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; * &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(func_task, i)</span></span>; <span class="comment">// 创建线程 t（并为线程指定任务 func_task）</span></span><br><span class="line">        t.<span class="built_in">detach</span>();             <span class="comment">// 将线程 t 与当前线程分离</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 015 * 9 *  * 2 *  * 7 * 3 * 6 * 4 * 8 *</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一步骤中，创建了 <code>10</code> 个线程，并且它们需要执行的任务都是 <code>func_task</code> ，也就是说这十个线程需要在各自的线程执行期间去执行 <code>func_task</code> 这个函数。当这十个线程创建完成之后 <code>thread t(func_task, i);</code> 就已经开始执行了，不需要特殊声明。</p>
<p>而对于 <code>t.detach()</code> ，表示允许该线程 <code>t</code> 脱离当前线程去运行，而无需等待当前线程执行结束，后面会详细说明。</p>
<p>从输出结果：<code>015 * 9 *  * 2 *  * 7 * 3 * 6 * 4 * 8 *</code> 可以看出这十个线程在执行顺序上并没有固定逻辑，例如第二次重新执行得到的结果为：<code>01 * 4 * 3 * 5 * 9 * 7 * 2 * 8 * 6 *  *</code>，那是因为这十个线程在优先级上并没有做区分，完全是独立运行得到的。</p>
<h2 id="1-2-lambda-创建线程"><a href="#1-2-lambda-创建线程" class="headerlink" title="1.2 lambda 创建线程"></a>1.2 lambda 创建线程</h2><p>当然在创建时候，也可以传入一个 <code>lambda</code> 表达式（匿名函数），例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;   // 引入头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> func_lambda = [](<span class="keyword">int</span> i) &#123; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; - &quot;</span>; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(func_lambda, i)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 024 - 5 -  - 1 - 6 - 7 - 3 - 9 - 8 -  -</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">([](<span class="keyword">int</span> i) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; - &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;, i)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-Callable-类型创建线程"><a href="#1-3-Callable-类型创建线程" class="headerlink" title="1.3 Callable 类型创建线程"></a>1.3 Callable 类型创建线程</h2><p>声明一个类，然后重载它的 <code>()</code> 运算符，实现 <code>callable</code> 类型的线程创建。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;   // 引入头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; () &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">Task</span> task;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(task, i)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 024 () 3 () 1 ()  () 6 () 8 () 9 () 5 ()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在这里需要把 <code>()</code> 运算符重载为 <code>public</code> 访问域，否则会识别不到。不过在此处需要注意的是，如果创建过程为：<code>thread t(Task(), i)</code></p>
<h1 id="2-C-线程的-join-操作"><a href="#2-C-线程的-join-操作" class="headerlink" title="2. C++线程的 join 操作"></a>2. C++线程的 join 操作</h1><p><code>join</code> 是一种等待线程结束的运算，例如 <code>main</code> 线程启动了 <code>t</code> 线程，然后 <code>t</code> 线程在启动完成过后执行了 <code>t.join()</code> ，那么 <code>main</code> 线程需要等待 <code>t</code> 线程执行结束之后，才能继续执行 <code>main</code> 函数下面的程序。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id &lt;&lt; <span class="string">&quot;: &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="comment">// &gt;: 2: 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    <span class="comment">//    1:0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般使用这种方法，是因为原始线程在其生命周期中没有了其他的事可做，或者说独立出来一个线程去执行函数收效甚微。使用 <code>join</code> 是简单粗暴的等待线程，当需要对线程进行更灵活的控制时，比如看某个线程是否存活，或者设置<strong>等待超时</strong>，可以使用<strong>条件变量</strong>或者<strong>期待（futures，也称期货模型）</strong>去实现。</p>
<p>噢！对，只能对一个线程执行一次 <code>join</code> 操作一次，所以在执行 <code>join</code> 操作之前，对其使用 <code>joinable</code> 检查操作更加合适。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t1 id: &quot;</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// &gt;: t1 id: 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t1.joinable() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="keyword">if</span> (t1.joinable()) &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; t1.joinable() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-C-线程的-detach-操作"><a href="#3-C-线程的-detach-操作" class="headerlink" title="3. C++线程的 detach 操作"></a>3. C++线程的 detach 操作</h1><p>在<code>C++11</code>中对线程规定了 <code>detach</code> 操作，顾名思义就是将线程与当前线程<strong>分离</strong>，实际上该操作可以将创建好的线程丢到后台去运行，这也就意味着创建它的线程将不能再与之直接交互，例如 <code>join</code> 操作、引用该对象等。所以一般来说，该操作都是用来创建<strong>守护线程</strong>的。具体操作如下例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;joinable? &quot;</span> &lt;&lt; t.joinable() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// &gt;: joinable? 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t.get_id() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: thread::id of a non-executing thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了分离线程，前提肯定是该线程要能分离，所以我们也可以使用 <code>joinable</code> 来对它进行检查，如果反回的是 <code>true</code> 说明可以对它进行 <code>detach</code> 操作。</p>
<blockquote>
<p>  守护线程（daemon threads）：在UNIX中守护线程是指没有任何用户接口，并在后台运行的线程。特点运行时间长，前台感受不到这个线程的存在 😑。（fire and forget 类型的任务就是使用到这种操作了）</p>
</blockquote>
<h3 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h3><ol>
<li><p><code>hello_thread.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/26.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/26 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;   // 引入头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_task</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// 声明要执行的任务函数（也可为callable类型）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; * &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; () &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(func_task, i)</span></span>; <span class="comment">// 创建线程 t（并为线程指定任务 func_task）</span></span><br><span class="line">        t.<span class="built_in">detach</span>();             <span class="comment">// 将线程 t 与当前线程分离</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 015 * 9 *  * 2 *  * 7 * 3 * 6 * 4 * 8 *</span></span><br><span class="line">    this_thread::sleep_for(chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(func_task, i)</span></span>; <span class="comment">// 创建线程 t（并为线程指定任务 func_task）</span></span><br><span class="line">        t.join();               <span class="comment">// 将线程 t 并入到当前线程中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 0 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 *</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func_lambda = [](<span class="keyword">int</span> i) &#123; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; - &quot;</span>; &#125;;</span><br><span class="line">    <span class="comment">// 024 - 5 -  - 1 - 6 - 7 - 3 - 9 - 8 -  -</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(func_lambda, i)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 -</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(func_lambda, i)</span></span>;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">([](<span class="keyword">int</span> i) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; - &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;, i)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">Task</span> task;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(task, i)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 024 () 3 () 1 ()  () 6 () 8 () 9 () 5 ()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>thread_join.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/27.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/27 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id &lt;&lt; <span class="string">&quot;: &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="comment">// &gt;: 2: 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    <span class="comment">//    1:0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    <span class="comment">// &gt;: 2: 0 1 2 3 4 5 6 7 8 1 :0 1 2 3 4 5 6 7 8 9 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>thread_joinable.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/27.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/27 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t1 id: &quot;</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// &gt;: t1 id: 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t1.joinable() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="keyword">if</span> (t1.joinable()) &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; t1.joinable() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>thread_detach.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/27.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/27 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;joinable? &quot;</span> &lt;&lt; t.joinable() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// &gt;: joinable? 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t.get_id() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: thread::id of a non-executing thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的多线程（Ⅱ）</title>
    <url>/2020/09/28/CPP%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B2/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/vdx6USLcafB9yriwNpNwBQ">上次</a>了解了C++如何创建、运行以及如何对线程进行 <code>join</code> 和 <code>detach</code> 操作。这次就来了解线程的<strong>参数传递</strong>以及<strong>权限转移</strong>操作。</p>
<a id="more"></a>
<h1 id="1-参数传递"><a href="#1-参数传递" class="headerlink" title="1. 参数传递"></a>1. 参数传递</h1><p>开门见山地说，在 <code>&lt;thread&gt;</code> 中，对线程中执行的函数进行参数传递是很简单但需要注意细节的。简单之处在于没有多余的语法，细节在于传递引用参数。一个简单例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello~ &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(hello, <span class="string">&quot;Cherry&quot;</span>)</span></span>; <span class="comment">// &gt;: Hello~ Cherry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里创建了一个线程 <code>t1</code> ，<code>t1</code> 执行的函数是 <code>hello</code>，它需要接收一个 <code>string</code> 类型的参数进来，然后打声招呼 <code>&gt;: Hello~XXX</code> 。很明显的，当需要传递参数时，直接在 <code>thread</code> 的构造函数中传递就可以了，在底层源码中是这样实现的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 首先声明可变长度模板，有一个必须提供的参数是 _Callable ，其余为可选参数</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    <span class="keyword">explicit</span></span><br><span class="line">    thread(_Callable &amp;&amp;__f, _Args &amp;&amp;... __args) &#123;</span><br><span class="line">        <span class="comment">// 查看是否激活 gthr 代理</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GTHR_ACTIVE_PROXY</span></span><br><span class="line">        <span class="comment">// Create a reference to pthread_create, not just the gthr weak symbol.</span></span><br><span class="line">    <span class="keyword">auto</span> __depend = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>(*)()&gt;(&amp;pthread_create);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">auto</span> __depend = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 创建执行函数，并且将参数进行传递</span></span><br><span class="line">        _M_start_thread(_S_make_state(  <span class="comment">// 创建状态</span></span><br><span class="line">                __make_invoker(         <span class="comment">// 创建执行函数，并执行</span></span><br><span class="line">                        <span class="built_in">std</span>::forward&lt;_Callable&gt;(__f),   <span class="comment">// callable 类型转换</span></span><br><span class="line">                        <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...) <span class="comment">// 参数类型转换</span></span><br><span class="line">                        ),</span><br><span class="line">                        __depend);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 用来执行的包装器 (forwarded tuple elements...)</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tuple&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Invoker</span> &#123;</span></span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Tp&gt;</span><br><span class="line">    <span class="keyword">using</span> __decayed_tuple = tuple&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;_Tp&gt;::type...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回一个可调用的包装器，里面有：</span></span><br><span class="line">    <span class="comment">// tuple&#123;DECAY_COPY(__callable), DECAY_COPY(__args)...&#125;.</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    <span class="keyword">static</span> _Invoker&lt;__decayed_tuple&lt;_Callable, _Args...&gt;&gt;</span><br><span class="line">    __make_invoker(_Callable &amp;&amp;__callable, _Args &amp;&amp;... __args) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;__decayed_tuple&lt;_Callable, _Args...&gt;&#123;</span><br><span class="line">                <span class="built_in">std</span>::forward&lt;_Callable&gt;(__callable), <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>thread</code> 构造函数接收一个 <code>callable</code> 类型的参数作为执行函数，这个是必选参数。后面可以可选附加若干个 <code>Args</code> 类型的参数来填充 <code>callable</code> 函数。不过需要注意的是，<strong>向线程中执行函数传递引用类型的参数</strong>可不是容易的事，例如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">buffer</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">([](<span class="built_in">string</span> buf) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        buf.append(<span class="string">&quot;world!&quot;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// &gt;: 3 - helloworld!</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;, <span class="built_in">buffer</span>)</span></span>;</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; <span class="built_in">buffer</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// &gt;: 1 - hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见变量 <code>buffer</code> 在线程 <code>t2</code> 中并没有得到修改。那么试试引用传递：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 会出现编译错误！</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  thread t3([](string &amp;buf) &#123;</span></span><br><span class="line"><span class="comment">     *      buf.append(&quot;world!&quot;);</span></span><br><span class="line"><span class="comment">     *      cout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; string buf: &quot; &lt;&lt; &quot; - &quot; &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">     *  &#125;, buffer);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写在一般的函数调用中，当然是没有问题的，不过在多线程中却是不可行的，那么该怎样传递引用类型，然后在线程中完成访问呢？这里需要使用 <code>ref()</code> 函数将参数转换成引用类型的形式，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t_ref</span><span class="params">([](<span class="built_in">string</span> &amp;buf) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        buf.append(<span class="string">&quot; world!&quot;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// &gt;: 4 - hello world!</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;, ref(<span class="built_in">buffer</span>))</span></span>;</span><br><span class="line">    t_ref.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; <span class="built_in">buffer</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// &gt;: 1 - hello world!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，就可以在线程内部，对外部变量进行修改。当然，除此之外，还可以使用这样一种方式来完成相同的目的：<strong>传递一个类的成员函数作为线程函数，并提供一个对象指针作为第一个参数</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">(<span class="built_in">string</span> &amp;name)</span> </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;hello~ &quot;</span> + name;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Task</span> task;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="string">&quot;Cherry&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(&amp;<span class="built_in">Task</span>::do_something, &amp;task, <span class="built_in">std</span>::ref(name))</span></span>;</span><br><span class="line">    t4.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// &gt;: Cherry -&gt; hello~ Cherry -&gt; hello~ Cherry</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，传入线程构造函数的有 <code>Task</code> 的成员函数 <code>do_something</code> 函数指针，以及一个 <code>Task</code> 类的实例 <code>task</code>，在剩余的参数中，把相应的参数列表传了进来，从而实现在 <code>Task</code> 的成员函数中对外部变量进行修改。</p>
<h1 id="2-权限转移"><a href="#2-权限转移" class="headerlink" title="2. 权限转移"></a>2. 权限转移</h1><p>创建一个线程之后，如果想转移所有权，那么需要等待线程结束才能进行。那么可以通过线程权限转移，使用 <code>move</code> 函数来移动一个 <code>thread</code> 所有权到另一个 <code>thread</code> 对象中去，来实现控制。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; ownership! + &quot;</span> &lt;&lt; ++count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        this_thread::sleep_for(chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(do_something)</span></span>;</span><br><span class="line">    this_thread::sleep_for(chrono::seconds(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    thread t2 = <span class="built_in">move</span>(t1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t1.joinable() ? &quot;</span> &lt;&lt; t1.joinable() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: t1.joinable() ? 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t2.joinable() ? &quot;</span> &lt;&lt; t2.joinable() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: t2.joinable() ? 1</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2 ownership! + 1</span></span><br><span class="line"><span class="comment">     * 2 ownership! + 2</span></span><br><span class="line"><span class="comment">     * t1.joinable() ? 0</span></span><br><span class="line"><span class="comment">     * t2.joinable() ? 1</span></span><br><span class="line"><span class="comment">     * 2 ownership! + 3</span></span><br><span class="line"><span class="comment">     * 2 ownership! + 4</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>);<span class="comment">// 在这里空转，不让 main 线程结束掉，否则会丢失输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>t1</code> 首先获取了执行函数 <code>do_something</code> ，然后执行两秒钟后，重新将 <code>do_something</code> 转移给了 <code>t2</code> ，此时 <code>t1</code> 便不再有绑定执行函数了。从 <code>joinable</code> 也可看出来 <code>t1</code> 已经变成不可 <code>join</code> 的对象。不仅如此，在权限转移过程中，并没有让原来执行的过程中断或重启，从输出 <code>1, 2, 3 ,4 ...</code> 连续性中可以看出。</p>
<p>被转移走权限的 <code>t1</code> 就好像一个空壳，它虽然仍然是一个线程对象（还可以被 <code>move</code> ），但是它的执行函数已经木有了（就算 <code>move</code> ，接收的对象也接收不到任何东西），所以对它再进行线程上的操作是没有意义的。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; ownership! + &quot;</span> &lt;&lt; ++count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        this_thread::sleep_for(chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    thread t4 = <span class="built_in">move</span>(t1); <span class="comment">// 虽然转移了过来，但是线程 t4 并没有可执行的函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t4.joinable() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不仅如此，对一个拥有执行函数的 <code>thread</code> 对象进行 <code>move</code> 赋值时，也会报错，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; ownership! + &quot;</span> &lt;&lt; ++count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        this_thread::sleep_for(chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(do_something)</span></span>;</span><br><span class="line">    this_thread::sleep_for(chrono::seconds(<span class="number">2</span>));</span><br><span class="line">    thread t2 = <span class="built_in">move</span>(t1);</span><br><span class="line">    thread t3 = thread(do_something);</span><br><span class="line">    t3 = <span class="built_in">move</span>(t2); <span class="comment">// 会报错，因为 t3 已经和一个函数关联，这时候再给他一个会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这个是不可以被覆盖的，简而言之就是：<strong>可以通过</strong> <code>std::move()</code> <strong>转移一个线程所有权给一个未关联线程的</strong> <code>thread</code> <strong>对象，但是不能通过赋一个新值的方式丢弃一个线程</strong>。</p>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C和C++使用对方编译的动态链接库</title>
    <url>/2020/10/04/C%E5%92%8CCPP%E4%BD%BF%E7%94%A8%E5%AF%B9%E6%96%B9%E7%BC%96%E8%AF%91%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</url>
    <content><![CDATA[<p>C使用C++编译出来的动态链接库，C++使用C编译出来的动态链接库，C使用C编译出来的动态链接库，C++使用C++编译出来的动态链接库……</p>
<a id="more"></a>
<p>最近和师兄们搭伴做加密系统，自己负责加密算法部分，师兄们负责更加底层的硬件接口部分。但是因为个人原因我不大喜欢 <code>C</code> 语言，当然是相比较于 <code>C++</code> 而言，所以自己就用了 <code>C++</code> 去实现加密算法。这么一来，就涉及到和师兄写的程序之间接口问题，于是乎就研究了下怎样导出动态链接库以供他人使用。</p>
<p>对于 <code>C</code> 和 <code>C++</code> 之间的关系，可不是 <code>Java</code> 和 <code>JavaScript</code> 之间的关系，所以操作起来相对而言还是比较容易的，但是也有一些坑需要注意，要不然也不至于在<strong>2020</strong>年的国庆节折腾这折腾了两天😟，难度系数表如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>库\可执行程序</th>
<th>C++</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>C++</td>
<td>简单</td>
<td>不简单</td>
</tr>
<tr>
<td>C</td>
<td>相对简单</td>
<td>简单</td>
</tr>
</tbody>
</table>
</div>
<p>因为 <code>C/C++</code> 对系统环境比较敏感，这里列出写这篇文章时的系统情况：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE</td>
<td>CLion 2020.2.3</td>
</tr>
<tr>
<td>System</td>
<td>Windows 64</td>
</tr>
<tr>
<td>Environment</td>
<td>MinGW w64 6.0</td>
</tr>
<tr>
<td>Tool Chains</td>
<td>CMake 3.17.3</td>
</tr>
</tbody>
</table>
</div>
<p>噢，对了，还有重要的 <code>C</code> 和 <code>C++</code> 版本：</p>
<ul>
<li><code>C</code> ：C99</li>
<li><code>C++</code> ：C++17</li>
</ul>
<h1 id="1-C导出动态链接库给C-用"><a href="#1-C导出动态链接库给C-用" class="headerlink" title="1. C导出动态链接库给C++用"></a>1. C导出动态链接库给C++用</h1><blockquote>
<p>   什么？上来为什么要说这个？那肯定是因为简单啊！那为什么不说另外两个更简单的？那肯定是因为没做啊😉</p>
</blockquote>
<p>先来考虑这样一个需求：小张小明是朋友，小张喜欢 <code>C++</code> ，小明不得不用 <code>C</code> ，而小明需要给小张提供一些库，小张使用小明提供的库进行上层开发，那么也就是：</p>
<ul>
<li>小明使用 <code>C</code> 语言写了个驱动，导出 <code>DLL</code> 动态链接库</li>
<li>小张拿到小明导出的 <code>DLL</code> 动态链接库，引入到项目中，使用在 <code>DLL</code> 中编译好的函数（或数据结构）</li>
</ul>
<p>那么他俩可以这样做：</p>
<h2 id="1-1-小明的工作目录"><a href="#1-1-小明的工作目录" class="headerlink" title="1.1 小明的工作目录"></a>1.1 小明的工作目录</h2><p>小明的工作目录长这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:.</span><br><span class="line">│  CMakeLists.txt</span><br><span class="line">│  library.c</span><br><span class="line">│  library.h</span><br><span class="line">└─cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>其中的 <code>cmake-build-debug</code> 是用来存放 <code>CMake</code> 执行过程中产生的文件，可以暂时忽略不计，主要关注这几个文件的内容：</p>
<ol>
<li><code>CMakeLists.txt</code> 规定了怎样去编译这个库，怎样导出。这里主要说明了项目名称，使用的语言，<code>C</code> 语言的标准用哪一版，以及库的依赖文件和导出方式（<code>SHARED</code> )</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(C_Lib C)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"><span class="keyword">add_library</span>(C_Lib SHARED library.c library.h)</span><br></pre></td></tr></table></figure>
<ol>
<li><code>library.h</code> 函数的声明，简简单单，普普通通</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> C_LIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C_LIB_LIBRARY_H</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//C_LIB_LIBRARY_H</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>library.c</code> 函数的实现，更加朴素</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;library.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这些之后，点击编译项目或 <code>Ctrl+F9</code> 快捷键编译或者输入命令编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake.exe --build .\cmake-build-debug --target C_Lib -- -j 6</span><br></pre></td></tr></table></figure>
<p>完成后可以看到如下输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[100%] Built target C_Lib</span><br></pre></td></tr></table></figure>
<p>那么可以在 <code>cmake-build-debug</code> 目录下找到 <code>libC_Lib.dll</code> 文件，这个文件就是用来给小张用的。</p>
<p>好了，小明可以去吃苹果了🍎。 </p>
<h2 id="1-2-小张的工作目录"><a href="#1-2-小张的工作目录" class="headerlink" title="1.2 小张的工作目录"></a>1.2 小张的工作目录</h2><p>小张的工作目录长这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\SOURCE\C++\TEMP\CXX_EXE</span><br><span class="line">│  CMakeLists.txt</span><br><span class="line">│  libC_Lib.dll</span><br><span class="line">│  main.cpp</span><br><span class="line">└─cmake-build-debug	</span><br></pre></td></tr></table></figure>
<p>这里主要多了一个 <code>libC_Lib.dll</code> 文件，这个文件就是来自小明的，那么该如何使用里面定义的 <code>hello()</code> 方法？</p>
<ul>
<li>首先，需要导入到当前项目中，这里使用 <code>CMakeLists.txt</code> 来完成：</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(CXX_Exe)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(.) <span class="comment"># 从当前目录中寻找链接文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(CXX_Exe main.cpp library.h)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(CXX_Exe libC_Lib.dll) <span class="comment"># 将 libC_Lib.dll 链接到 CXX_Exe 目标文件中</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用头文件 <code>library.h</code> 中引入函数声明</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> C_LIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C_LIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//C_LIB_LIBRARY_H</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>C++</code> 源文件 <code>main.cpp</code> 中使用 <code>hello()</code> 函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;library.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hello(); <span class="comment">// &gt;: Hello, World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不过！重点之一来了！</strong>为什么在头文件 <code>library.h</code> 中写一个 <code>extern &quot;C&quot;</code> 呢？是因为 <code>C</code> 的编译链接过程，<strong>中间代码不会修改函数名称</strong>，而 <code>C++</code> 在这个过程中<strong>将会修改</strong>！因此，为了让 <code>C++</code> 识别出来 <code>C</code> 函数，需要使用 <code>extern &quot;C&quot;</code> 来指明，这个函数是 <code>C</code> 过来的。</p>
<p>否则会异常退出：<code>undefined reference to &#39;hello()&#39; collect2.exe: error: ld returned 1 exit status</code>。</p>
<p><strong>重点之二，</strong> 在 <code>CLion</code> 中，仅仅在 <code>CMakeLists.txt</code> 中声明怎样链接，怎样找动态链接库是不够的，还需要在 <code>Run Configurations</code> 设置中去添加环境变量 <code>PATH=&#123;DLL文件所在的目录&#125;</code> 才可以，要不然就直接放到 <code>CLion</code> 已知的环境目录下。</p>
<p>否则会异常退出： <code>Process finished with exit code -1073741515 (0xC0000135)</code> 。</p>
<p>至此，小张小明合作愉快，任务完成🙂。</p>
<h1 id="2-C-导出动态链接库给C用"><a href="#2-C-导出动态链接库给C用" class="headerlink" title="2. C++导出动态链接库给C用"></a>2. C++导出动态链接库给C用</h1><p>还是小张和小明，还是 <code>C</code> 和 <code>C++</code> ，只不过这次换成了小张提供动态链接库给小明使用。</p>
<h2 id="2-1-小张的工作目录"><a href="#2-1-小张的工作目录" class="headerlink" title="2.1 小张的工作目录"></a>2.1 小张的工作目录</h2><p>小张需要提供动态链接库，他的工作目录长这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:.</span><br><span class="line">│  CMakeLists.txt</span><br><span class="line">│  library.cpp</span><br><span class="line">│  library.h</span><br><span class="line">└─cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>还是跟之前一样， <code>cmake-build-debug</code> 里面找动态链接文件，而 <code>CMakeLists.txt</code> 里面规定了怎样去编译这个程序。</p>
<p>挨着牌的来康康每个文件写了啥：</p>
<ul>
<li><code>CMakeLists.txt</code> </li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(CXX_Lib)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>) <span class="comment"># 设置 C++ 标准为 17</span></span><br><span class="line"><span class="keyword">add_library</span>(CXX_Lib SHARED library.cpp library.h) <span class="comment"># 规定了依赖哪些文件去产生动态链接文件，以及动态链接文件类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>library.h</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CXX_LIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CXX_LIB_LIBRARY_H</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="comment">// 声明下面这个函数，是要按照 C 语言的标准去导出的，不要改名啦~</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//CXX_LIB_LIBRARY_H</span></span></span><br></pre></td></tr></table></figure>
<p>这里的不同在于，直接在动态链接库的头文件中声明了 <code>extern &quot;C&quot;</code> 而不是在用到动态链接文件的地方。</p>
<ul>
<li><code>library.cpp</code> </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;library.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经历和小明一样的编译过程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake.exe --build .\cmake-build-debug --target CXX_Lib -- -j 6</span><br></pre></td></tr></table></figure>
<p>然后在 <code>cmake-build-debug</code> 目录下找到 <code>libCXX_Lib.dll</code> 文件，然后丢给小明，然后小张去喝牛奶🥛了。</p>
<h2 id="2-2-小明的工作目录"><a href="#2-2-小明的工作目录" class="headerlink" title="2.2 小明的工作目录"></a>2.2 小明的工作目录</h2><p>小明拿到小张的动态链接文件后，直接放到工作目录下，然后他的工作目录就长这样了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:.</span><br><span class="line">|   CMakeLists.txt</span><br><span class="line">|   libCXX_Lib.dll</span><br><span class="line">|   library.h</span><br><span class="line">|   main.c</span><br><span class="line">\---cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>其中的 <code>libCXX_Lib.dll</code> 就是小张那取过来的。</p>
<ul>
<li>一样的流程，首先使用 <code>CMakeLists.txt</code> 导入到项目中</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(C_Exe C)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(.) <span class="comment"># 从哪里找链接文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(C_Exe main.c library.h)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(C_Exe libCXX_Lib.dll) <span class="comment"># 使用这个动态链接库</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后声明头文件 <code>library.h</code> </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CXX_LIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CXX_LIB_LIBRARY_H</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//CXX_LIB_LIBRARY_H</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>最后使用 <code>main.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;library.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hello(); <span class="comment">// &gt;: Hello, World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然小明这里没有了 <code>extern &quot;C&quot;</code> 的注意事项，但是仍然需要在 <code>CLion</code> 的 <code>Run Configurations</code> 里面配置 <code>PATH=&#123;DLL文件所在的目录&#125;</code> 才能使用，否则还是报 <code>Process finished with exit code -1073741515 (0xC0000135)</code>。</p>
<p>好了，小明终于可以去休息了，我也去休息一下🍗🍖🥩~~~</p>
<hr>
<p>写完后突然想起来，我和师兄为啥不统一一下语言呢？🤔省时省力还省得这两天折腾来折腾去。</p>
<p>不过想想，有了这个经验，以后可以专门给 <code>Java</code> 、<code>Python</code> 等程序写动态链接库，也未尝不是件好事。</p>
<p>真是让人恍然大明白！😮</p>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>CMake</tag>
        <tag>DLL</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++（阅读笔记）</title>
    <url>/2020/10/14/Effective-CPP-55/</url>
    <content><![CDATA[<blockquote>
<p>   改善程序与设计的55个具体做法。</p>
</blockquote>
<a id="more"></a>
<h1 id="1-让自己习惯C"><a href="#1-让自己习惯C" class="headerlink" title="1. 让自己习惯C++"></a>1. 让自己习惯C++</h1><blockquote>
<p>  C++高效编程守则视状况而变化，取决于使用C++的哪一部分。</p>
</blockquote>
<p>C++四大块：</p>
<ul>
<li>C</li>
<li>Object-Oriented C++：面向对象</li>
<li>Template C++：泛型编程，模板元编程</li>
<li>STL：容器，迭代器，算法，函数对象</li>
</ul>
<h1 id="2-尽量以const，enum，inline替换-define"><a href="#2-尽量以const，enum，inline替换-define" class="headerlink" title="2. 尽量以const，enum，inline替换 #define"></a>2. 尽量以const，enum，inline替换 #define</h1><blockquote>
<ul>
<li>对于单纯常量，最好使用 <code>const</code> 或者 <code>enums</code> 来替换 <code>#define</code> </li>
<li>对于形似函数的宏（macros），最好使用 <code>inline</code> 函数来替换 <code>#define</code> </li>
</ul>
</blockquote>
<p>有一种方法，可以获得宏带来的效率，以及一般函数带来的可预料行为以及类型安全性（Type Safety），例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = callWithMax&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-尽可能使用-const"><a href="#3-尽可能使用-const" class="headerlink" title="3. 尽可能使用 const"></a>3. 尽可能使用 const</h1><blockquote>
<ul>
<li>声明为 <code>const</code> 可以让编译器帮助检查错误。</li>
<li><code>const</code> 可以施加于任何作用域内的对象、函数参数、函数返回类型、成员函数。</li>
<li>编译器强制实施<em>bitwise constness</em>，但编写程序时，应该使用“概念上的常量性”<em>conceptual constness</em>。</li>
<li>当 <code>const</code> 和 <code>non-const</code> 成员函数有实质等价的实现时，要用 <code>non-const</code> 版本去调用 <code>const</code> 版本，这样可减少代码重复。</li>
</ul>
</blockquote>
<p><code>const</code> 如果出现在 <code>*</code> 左边，那么表示被指物是常量；如果在 <code>*</code> 右边，那么表示指针是常量；如果出现在两边，那么表示指针和被指物都是常量。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> *p1 = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> *<span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line"></span><br><span class="line">    *p1 = <span class="number">2</span>;    <span class="comment">// 不行！因为 p1 指向的内容是常量</span></span><br><span class="line">    *p2 = <span class="number">2</span>;    <span class="comment">// 可以，p2 自身是常量，p2 只能指向a，但是 a 中的内容可以变</span></span><br><span class="line">    p1 = &amp;b;    <span class="comment">// 可以，p1 指向另一个内容，并声称这个内容不可变</span></span><br><span class="line">    p2 = &amp;b;    <span class="comment">// 不可以，p2 自身是常量，不能指向其他东西了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>试着习惯这样的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *i)</span></span>; <span class="comment">// 指向一个不能修改内容的 i</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> *i)</span></span>; <span class="comment">// 一猫猫一样</span></span><br></pre></td></tr></table></figure>
<p>这俩写法效果是一样的，都是指向一个内容不可变的数据（指针本身可以再修改指向的对象）。</p>
<p>对于第三点，一个很好的例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">text</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[pos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> pos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> &amp;&gt; (         <span class="comment">// 使用 const_cast 去掉 const 声明</span></span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> Text &amp;&gt;   <span class="comment">// 使用 static_cast 把 *this 转换成 const 对象</span></span><br><span class="line">                (*<span class="keyword">this</span>)[pos]);              <span class="comment">// 使用 (*this)[] 方法返回（这个时候是 const 结果，经过 const_cast 去掉 const 声明</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="4-确定对象被使用前已被初始化"><a href="#4-确定对象被使用前已被初始化" class="headerlink" title="4. 确定对象被使用前已被初始化"></a>4. 确定对象被使用前已被初始化</h1><blockquote>
<ul>
<li>为内置对象进行手工初始化，因为C++并不能保证完全初始化好它们。</li>
<li>构造函数最好使用成员初值列（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。</li>
<li>初始列列出的成员变量，其排列顺序要和它们在类声明中的一致。</li>
<li>为免除“跨编译单元初始化次序”问题，使用 local static 对象来代替 non-local static 对象。</li>
</ul>
</blockquote>
<p>如果成员变量是 <code>const</code> 的或者 <code>references</code> 的，那么它们一定需要有初值，不能被赋值。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> &amp;re_val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X(<span class="keyword">int</span> val_, <span class="keyword">int</span> &amp;re_val_) : val(val_), re_val(re_val_) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基类总是比派生类要先初始化好，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> &amp;re_val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X(<span class="keyword">int</span> val_, <span class="keyword">int</span> &amp;re_val_) : val(val_), re_val(re_val_) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;X initialization...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> X &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Y(<span class="keyword">int</span> val, <span class="keyword">int</span> &amp;re_val) : X(val, re_val) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Y initialization...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> re_v = <span class="number">1</span>;</span><br><span class="line">    <span class="function">Y <span class="title">y</span><span class="params">(<span class="number">1</span>, re_v)</span></span>;</span><br><span class="line">    <span class="comment">// &gt;: X initialization...</span></span><br><span class="line">    <span class="comment">//    Y initialization...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于定义于不同编译单元内的 <code>non-local static</code> 对象的初始化顺序并未明确定义，因此会出现这样情况：</p>
<ul>
<li>定义在 <code>File1.hh</code> 中一个静态全局变量 <code>tfs</code></li>
<li>在 <code>File2.cc</code> 中使用 <code>tfs</code> </li>
</ul>
<p>那么如果 <code>File1.hh</code> 中的 <code>tfs</code> 还没初始化好呢，<code>File2.cc</code> 中就想使用了，那么就会出现大问题！例如下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File1.hh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">FileSystem</span> tfs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File2.cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;File1.hh&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> disks;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory() &#123; disks = tfs.numDisks(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">getDisks</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> disks; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Directory directory;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; directory.getDisks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候编译器就会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMakeFiles\local_static.dir&#x2F;objects.a(File2.cc.obj):File2.cc:(.rdata$.refptr.tfs[.refptr.tfs]+0x0): undefined reference to &#96;tfs&#39;</span><br></pre></td></tr></table></figure>
<p>很明显，在 <code>local_static</code> 目录中没有找到该引用，因此报错了，那么该怎样做呢？</p>
<p><strong>使用方法（类似于工厂方法）来获取这个值，而不是依赖编译器初始化</strong></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File1.hh</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="built_in">FileSystem</span> &amp;<span class="title">getFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">FileSystem</span> tfs;</span><br><span class="line">    <span class="keyword">return</span> tfs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File2.cc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> disks;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory() &#123; disks = getFS().numDisks(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">getDisks</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> disks; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Directory directory;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; directory.getDisks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，就不用担心了☺。</p>
<p>不过，这样还是有另外一个问题，例如多线程环境下还是有不确定情况，处理这种麻烦情况的做法之一是：在单线程启动阶段，手动调用一遍所有的 <code>reference-returning</code> 方法。这样可以消除与初始化有关的“竞速形式（race conditions）”</p>
<h1 id="5-了解C-默默编写并调用哪些函数？"><a href="#5-了解C-默默编写并调用哪些函数？" class="headerlink" title="5. 了解C++默默编写并调用哪些函数？"></a>5. 了解C++默默编写并调用哪些函数？</h1><blockquote>
<p>  编译器可以暗自为 <code>class</code> 创建 <code>default</code> 构造函数、<code>copy</code> 构造函数，<code>copy assignment</code> 操作符，以及析构函数。</p>
</blockquote>
<p>首先，开门见山地说，C++默认编写了<strong>默认构造函数、默认析构函数、拷贝构造函数，以及拷贝赋值函数</strong>，而且它们默认都是 <code>inline</code> 的。当然，这些函数的默认创建在一定时期是失效的，例如：</p>
<ul>
<li>默认构造函数：当提供了一个构造函数后，编译器不再为类提供默认构造函数，而且默认。</li>
<li>默认析构函数：当提供了一个析构函数后，编译器就不再提供默认析构函数，默认析构函数是 <code>non-virtual</code> 的。</li>
<li>拷贝构造函数：只要没提供，而且满足<strong>可拷贝构造</strong>的条件，那么就提供，否则不提供。</li>
<li>拷贝赋值函数：只要没提供，而且满足<strong>可拷贝复制</strong>的条件，那么就提供，否则不提供。</li>
</ul>
<p>上面说了两个条件，那么具体是什么条件呢？</p>
<h2 id="5-1-可拷贝构造-amp-可拷贝赋值？"><a href="#5-1-可拷贝构造-amp-可拷贝赋值？" class="headerlink" title="5.1 可拷贝构造&amp;可拷贝赋值？"></a>5.1 可拷贝构造&amp;可拷贝赋值？</h2><p>先来看一下满足这俩条件的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedObject</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T objectValue;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NamedObject(<span class="built_in">string</span> n, T val) : name(n), objectValue(val) &#123;&#125;</span><br><span class="line">    NamedObject(<span class="keyword">const</span> NamedObject&lt;T&gt; &amp;rhs) &#123;</span><br><span class="line">        objectValue = rhs.objectValue;</span><br><span class="line">        name = rhs.name + <span class="string">&quot; copy &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> NamedObject&lt;T&gt; &amp;rhs) &#123;</span><br><span class="line">        os &lt;&lt; rhs.objectValue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; rhs.name;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    NamedObject &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NamedObject&lt;T&gt; &amp;rhs) &#123;</span><br><span class="line">        objectValue = rhs.objectValue;</span><br><span class="line">        name = rhs.name + <span class="string">&quot; = &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> newDog = <span class="string">&quot;newDog&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> oldDog = <span class="string">&quot;oldDog&quot;</span>;</span><br><span class="line">    <span class="function">NamedObject&lt;<span class="keyword">int</span>&gt; <span class="title">od</span><span class="params">(oldDog, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">NamedObject&lt;<span class="keyword">int</span>&gt; <span class="title">nd</span><span class="params">(newDog, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nd &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; od &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 2 newDog : 1 oldDog</span></span><br><span class="line">    nd = od;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nd; <span class="comment">// &gt;: 1 oldDog =</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么此时，即便自己不提供拷贝构造以及拷贝赋值构造操作符，编译器也会对成员变量进行递归的拷贝赋值过来。但是在遇到成员变量是 <code>const</code> 或者 <code>reference</code> 类型时，编译器就两手一摊，无能为力了（具体可参考<em>Effective C++, 3th, P37</em>）。</p>
<p>例如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedObject</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> T objectValue;</span><br><span class="line">    <span class="built_in">string</span>&amp; name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 其他函数都一样</span></span><br><span class="line">    NamedObject(<span class="keyword">const</span> NamedObject&lt;T&gt; &amp;rhs) &#123;</span><br><span class="line">        objectValue = rhs.objectValue;</span><br><span class="line">        name = rhs.name + <span class="string">&quot; copy &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    NamedObject &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NamedObject&lt;T&gt; &amp;rhs) &#123;</span><br><span class="line">        objectValue = rhs.objectValue; <span class="comment">// 不能对一个 const 对象赋值！</span></span><br><span class="line">        name = rhs.name + <span class="string">&quot; = &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> newDog = <span class="string">&quot;newDog&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> oldDog = <span class="string">&quot;oldDog&quot;</span>;</span><br><span class="line">    <span class="function">NamedObject&lt;<span class="keyword">int</span>&gt; <span class="title">od</span><span class="params">(oldDog, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">NamedObject&lt;<span class="keyword">int</span>&gt; <span class="title">nd</span><span class="params">(newDog, <span class="number">2</span>)</span></span>;</span><br><span class="line">    nd = od;    <span class="comment">// &gt;: error: use of deleted function &#x27;NamedObject&lt;int&gt;&amp; NamedObject&lt;int&gt;::operator=(const NamedObject&lt;int&gt;&amp;)&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这只是编译器不再提供了而已，用户自己还是可以设计如何去复制拷贝以及构造拷贝的，这完全取决于自己怎么处理成员变量。</p>
<p>除此之外，如果基类把拷贝构造函数设置成了 <code>private</code> 那么在派生类中也是没办法操作的。</p>
<h1 id="6-若不想使用编译器自动生成的函数，那该明确拒绝"><a href="#6-若不想使用编译器自动生成的函数，那该明确拒绝" class="headerlink" title="6. 若不想使用编译器自动生成的函数，那该明确拒绝"></a>6. 若不想使用编译器自动生成的函数，那该明确拒绝</h1><blockquote>
<p>  为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为 <code>private</code> 并且不予实现。或者使用继承 <code>Uncopyable</code> 这样的基类。</p>
</blockquote>
<p>如果不想让一个类支持拷贝构造或者赋值构造，那么我们可以将函数声明但不实现，例如这样子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然，对于每一个想实现这个功能的类都能去单独这样声明，不过，还可以使用继承方法去实现，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Uncopyable() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">    Uncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> :</span> <span class="keyword">public</span> Uncopyable &#123;</span><br><span class="line">    <span class="comment">// 默认不允许拷贝构造和赋值运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SubClass s1, s2;</span><br><span class="line">    s1 = s2;    <span class="comment">// error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-为多态基类声明virtual析构函数"><a href="#7-为多态基类声明virtual析构函数" class="headerlink" title="7. 为多态基类声明virtual析构函数"></a>7. 为多态基类声明virtual析构函数</h1><blockquote>
<ul>
<li>带多态性质的基类应该声明一个 <code>virtual</code> 析构函数。</li>
<li>如果类带有任何 <code>virtual</code> 函数，那么它就应该拥有一个 <code>virtual</code> 析构函数。</li>
<li>如果类的设计目的不是用来做基类的，那么就不应该声明 <code>virtual</code> 析构函数。</li>
</ul>
</blockquote>
<p>当使用基类指针指向派生类对象时，没有问题，但是要是想把这个基类指针给删掉，这时候问题就来了，例如下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseClass(<span class="keyword">int</span> <span class="built_in">size</span>) &#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">size</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) name[i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 基类的析构函数</span></span><br><span class="line">    ~BaseClass() &#123; <span class="keyword">delete</span> [] name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeriveClass</span> :</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DeriveClass(<span class="keyword">int</span> <span class="built_in">size</span>) : BaseClass(<span class="built_in">size</span>) &#123;</span><br><span class="line">        count = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">size</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) count[i] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 派生类的析构函数</span></span><br><span class="line">    ~DeriveClass() &#123; <span class="keyword">delete</span> [] count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 多态用法，基类指针指向派生类对象，没毛病</span></span><br><span class="line">    BaseClass *obj = <span class="keyword">new</span> DeriveClass(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 删除基类指针，出现了问题！</span></span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序乍一看看不出个毛病来，现在对 <code>BaseClass *obj = new DeriveClass(16);</code> 设置断点，进行单步调试，可以观察到构造函数过程是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> DeriveClass(<span class="number">16</span>)</span><br><span class="line">    |</span><br><span class="line">BaseClass(<span class="number">16</span>)</span><br><span class="line">    |</span><br><span class="line">DeriveClass(<span class="number">16</span>)</span><br><span class="line">    |</span><br><span class="line">    <span class="built_in">end</span></span><br></pre></td></tr></table></figure>
<p>这个顺序完全正确，先构造基类再构造派生类嘛，执行完后，内存状态是这样的：</p>
<p><img data-src="https://s1.ax1x.com/2020/11/09/BToAnH.png" alt="内存状态表示"></p>
<p>可以得知操作系统给这两个对象中的成员分配内存到了 <code>name : 0x1061980</code> 和 <code>count : 0x10619c0</code> 。</p>
<p>那么执行 <code>delete obj;</code> 时，顺序是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj</span><br><span class="line">    |</span><br><span class="line">~BaseClass()</span><br><span class="line">    |</span><br><span class="line">    <span class="built_in">end</span></span><br></pre></td></tr></table></figure>
<p>从上面可以看出来，竟然只执行了基类的析构函数，而没有执行派生类的析构函数，那么这时的内存表示是怎么样的？见下图：</p>
<p><img data-src="https://s1.ax1x.com/2020/11/09/BToeAI.png" alt=""></p>
<p>由此可见，在不经意间，就造成了内存泄漏问题，那么该如何解决这个问题呢？</p>
<p>很简单，<strong>只需要把基类的析构函数声明为</strong> <code>virtual</code> <strong>就可以了</strong>，这样强制去执行子类的析构函数。</p>
<p>不过，这样还是有两种结果，例如下面是一种结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line">    <span class="comment">// 其他都一样</span></span><br><span class="line">    <span class="keyword">virtual</span> ~BaseClass() &#123; <span class="keyword">delete</span> [] name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeriveClass</span> :</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line">    <span class="comment">// 其他都一样</span></span><br><span class="line">    ~DeriveClass() <span class="keyword">override</span> &#123; <span class="keyword">delete</span> [] count; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个时候，是先执行的派生类析构函数，再执行基类析构函数。</p>
<p>另一种结果是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~BaseClass() &#123; <span class="keyword">delete</span> [] name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeriveClass</span> :</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line">    <span class="comment">// 删掉了自己的析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个情况下，才是先执行基类析构函数，再执行派生类析构函数。</p>
<h1 id="8-别让异常逃离析构函数"><a href="#8-别让异常逃离析构函数" class="headerlink" title="8. 别让异常逃离析构函数"></a>8. 别让异常逃离析构函数</h1><blockquote>
<ul>
<li>析构函数绝对不要抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们（不传播）或结束程序。</li>
<li>如果接口使用者需要对某个操作函数运行期间抛出的异常做出反应，那么 <code>class</code> 应该提供一个普通函数（而不是在析构函数中）执行操作。</li>
</ul>
</blockquote>
<p>即便C++允许析构函数抛出异常，但是最好不要这样做。当然，吞掉异常也是有争议的，比如“草率地结束程序”可能会带来更严重的问题，或者“不明确的行为带来的风险”可能会带来不安全的问题等等，具体问题具体分析是比较好的。</p>
<p>但是，通常可以提供一个让用户在析构函数前控制异常的机会，例如使用“双重保险”来尽最大化确保问题得到解决。</p>
<h1 id="9-绝不在构造函数和析构函数过程中调用virtual函数"><a href="#9-绝不在构造函数和析构函数过程中调用virtual函数" class="headerlink" title="9. 绝不在构造函数和析构函数过程中调用virtual函数"></a>9. 绝不在构造函数和析构函数过程中调用virtual函数</h1><blockquote>
<p>  在构造和析构期间不要调用 <code>virtual</code> 函数，因为这类调用从不下降至派生类。</p>
</blockquote>
<p>不管怎样，都不应该在构造函数和析构函数内部去调用一个 <code>virtual</code> 函数，因为这样的操作是不可预估的，带来意想不到的结果。为什么这样？因为在基类中，构造函数执行阶段或者析构函数执行阶段<strong>只能看到基类的内容</strong>，所以在派生类中实现的程序，是不可用的。下面这句话直白且有效的指出了问题的所在：</p>
<blockquote>
<p>在基类（base-class）构造期间，<code>virtual</code> 函数不是 <code>virtual</code> 函数。</p>
</blockquote>
<p>也正是因为这样一个“对象在 <code>derived class</code> 构造函数开始执行前，不会成为一个 <code>derived class</code> 对象”的规则，所以最好在构造期间对 <code>virtual</code> 函数视而不见。</p>
<p>那么如何科学有效地去解决这个问题？当然是在基类中把需要在构造函数内执行地函数设置成非 <code>virtual</code> 函数。</p>
<p>总之就是，在基类构造和析构期间调用的 <code>virtual</code> 函数不可下降至派生类。</p>
<h1 id="10-令-operator-返回一个-reference-to-this"><a href="#10-令-operator-返回一个-reference-to-this" class="headerlink" title="10. 令 operator= 返回一个 reference to *this"></a>10. 令 operator= 返回一个 reference to *this</h1><blockquote>
<p>  令赋值（assignment）操作符（<code>=</code>）返回一个 reference to <code>*this</code>。</p>
</blockquote>
<p>为什么这样做呢？是因为可以实现类似于这样的程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>因此，我们在编写类的 <code>operator=</code> 操作符时，可以写成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseClass &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> BaseClass &amp;rhs) &#123;</span><br><span class="line">        <span class="comment">// 随便干点什么</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 关键在于这里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然啦，也可以不做返回，不过既然这是一个好的实践，那么没有确切的理由不去做，最好就去做。</p>
<h1 id="11-在-operator-中处理“自我赋值”"><a href="#11-在-operator-中处理“自我赋值”" class="headerlink" title="11. 在 operator= 中处理“自我赋值”"></a>11. 在 operator= 中处理“自我赋值”</h1><blockquote>
<ul>
<li>确保当对象自我赋值时，<code>operator=</code> 有可预估的行为。其中需要注意的包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序以及拷贝交换。</li>
<li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li>
</ul>
</blockquote>
<p>简而言之，就是需要考虑操作符两边是否是同一个对象，因为如果是同一个对象，会出现类似下面的问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseClass &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> BaseClass &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] data;</span><br><span class="line">        data = rhs.data;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BaseClass baseClass;</span><br><span class="line">    baseClass = baseClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己给自己赋值，没毛病，但是在运算符函数的 <code>delete data</code> 却带来了问题，因为它删除掉了自己的内存空间，却在下面那行 <code>data = rhs.data</code> 又想用了，而这时系统已经收回了这块空间，这样一来操作系统肯定是不干的，所以程序就报错了。</p>
<p>那么该如何解决呢？这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseClass &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> BaseClass &amp;rhs) &#123;</span><br><span class="line">        <span class="comment">// 多一个检查是否是自己的操作就可以了，也称证同测试</span></span><br><span class="line">        <span class="keyword">if</span> (&amp;rhs == <span class="keyword">this</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span> [] data;</span><br><span class="line">        data = rhs.data;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="12-复制对象时勿忘其每一个成分"><a href="#12-复制对象时勿忘其每一个成分" class="headerlink" title="12. 复制对象时勿忘其每一个成分"></a>12. 复制对象时勿忘其每一个成分</h1><blockquote>
<ul>
<li>拷贝函数应该确保复制了“对象内的所有成员变量”以及“所有的 <code>base class</code> 成员”。</li>
<li>不要尝试以某个拷贝函数去实现另一个拷贝函数，应该将两者共同的部分抽取到一个新的函数中去完成，然后由两个拷贝函数共用。</li>
</ul>
</blockquote>
<p>一般而言，如果自己不声明拷贝构造函数和拷贝赋值操作符，那么编译器会帮自己生成的，但是！重点来了！如果选择了自己去声明定义，那么麻烦事就来了（因为即便可能出错编译器也不会告诉你）。</p>
<p>尤其是一个类派生自基类的时候，就需要小心谨慎地去处理基类的对象，然而有些是 <code>private</code> 的，因此复制起来比较麻烦，这个时候可以使用这样的方式来解决问题：</p>
<ul>
<li>对于拷贝构造函数，在初始化列表中显式地去调用基类的拷贝构造函数，然后在子类的拷贝构造函数内部处理好自己的问题。</li>
<li>对于赋值拷贝操作符，在<strong>合适的</strong>位置显式调用基类的 <code>operator=()</code> 函数。</li>
</ul>
<p>具体例子见下面：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseClass() = <span class="keyword">default</span>;</span><br><span class="line">    BaseClass(<span class="keyword">int</span> sz, <span class="keyword">char</span> c) &#123; name = <span class="built_in">string</span>(sz, c); &#125;</span><br><span class="line">    BaseClass(<span class="keyword">const</span> BaseClass &amp;rhs) : name(rhs.name) &#123;&#125;</span><br><span class="line">    BaseClass &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> BaseClass &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = rhs.name;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> BaseClass &amp;rhs) &#123;</span><br><span class="line">        os &lt;&lt; rhs.name;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeriveClass</span> :</span> <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DeriveClass(<span class="keyword">int</span> a, <span class="keyword">int</span> sz, <span class="keyword">char</span> c) : BaseClass(sz, c), age(a) &#123;&#125;</span><br><span class="line">    <span class="comment">// 必须要调用基类的拷贝构造函数，否则不会拷贝构造完全</span></span><br><span class="line">    DeriveClass(<span class="keyword">const</span> DeriveClass &amp;rhs) : age(rhs.age), BaseClass(rhs) &#123;&#125;</span><br><span class="line">    DeriveClass &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> DeriveClass &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;rhs == <span class="keyword">this</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        age = rhs.age;</span><br><span class="line">        <span class="comment">// 如果不调用下面这句，将会出现没有拷贝基类 name 值的问题！</span></span><br><span class="line">        BaseClass::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> DeriveClass &amp;rhs) &#123;</span><br><span class="line">        os &lt;&lt; (BaseClass) rhs &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; rhs.age;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">DeriveClass <span class="title">d1</span><span class="params">(<span class="number">18</span>, <span class="number">3</span>, <span class="string">&#x27;1&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="function">DeriveClass <span class="title">d2</span><span class="params">(<span class="number">20</span>, <span class="number">5</span>, <span class="string">&#x27;2&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="function">DeriveClass <span class="title">d3</span><span class="params">(d1)</span></span>;</span><br><span class="line">    d1 = d2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; d2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; d3;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常输出：</span></span><br><span class="line"><span class="comment">     * 22222    20</span></span><br><span class="line"><span class="comment">     * 22222    20</span></span><br><span class="line"><span class="comment">     * 111      18</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果按照前两点建议，那么出现这样的情况概不负责；</span></span><br><span class="line"><span class="comment">     * 111      20</span></span><br><span class="line"><span class="comment">     * 22222    20</span></span><br><span class="line"><span class="comment">     *          18</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总而言之，一旦选择了自己去完成<strong>拷贝构造函数</strong>和<strong>复制拷贝操作符</strong>，那么就别怪编译器不厚道了，需要自己去谨慎操作。</p>
<h1 id="13-以对象管理资源"><a href="#13-以对象管理资源" class="headerlink" title="13. 以对象管理资源"></a>13. 以对象管理资源</h1><blockquote>
<ul>
<li>为防止资源泄漏，需要使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。</li>
<li>两个常被使用的RAII类分别是 <code>tr1::shared_ptr</code> （现已纳入C++11标准，不需要添加 <code>tr1</code> 即可使用） 和 <code>auto_ptr</code>（已被废弃，使用 <code>unique_ptr</code> 来代替） 智能指针。前者通常来说是比较合适的选择，因为可拷贝。后者会使被拷贝的对象变成 <code>null</code>。</li>
</ul>
</blockquote>
<p>以对象来管理资源的关键想法：</p>
<ul>
<li>获得资源后，立刻放进管理对象内部。</li>
<li>管理对象运用析构函数确保资源能够被释放。</li>
</ul>
<p>当然，对于所有的<strong>对象类</strong>数组，使用 <code>vector</code> 之类的STL是最好的选择，因为智能指针目前没有提供相应的删除对象数组的操作。</p>
<h1 id="14-在资源管理类中小心-copying-行为"><a href="#14-在资源管理类中小心-copying-行为" class="headerlink" title="14. 在资源管理类中小心 copying 行为"></a>14. 在资源管理类中小心 copying 行为</h1><blockquote>
<ul>
<li>复制RAII对象必须一并复制它所管理的资源，所以资源的 <code>copying</code> 行为决定RAII对象的 <code>copying</code> 行为。</li>
<li>普遍而常见的RAII类 <code>copying</code> 行为是：抑制 <code>copying</code> 、使用引用计数 <code>reference counting</code> 。</li>
</ul>
</blockquote>
<h1 id="15-在资源管理类中提供对原始资源的访问"><a href="#15-在资源管理类中提供对原始资源的访问" class="headerlink" title="15. 在资源管理类中提供对原始资源的访问"></a>15. 在资源管理类中提供对原始资源的访问</h1><blockquote>
<ul>
<li>APIs往往要求访问原始资源（raw resources），所以每一个RAII应该提供一个“取得其所管理的资源”的接口。</li>
<li>对原始资源的访可能经过显式或者隐式类型转换，一般而言显式类型转换比较安全，但是隐式类型转换对用户比较方便，考虑着用。</li>
</ul>
</blockquote>
<p>当把一个指针传递给资源管理类指针后，该怎样使用它呢？这是一个问题，而这一部分正好是解决这个问题的最佳实践。如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> BaseClass *base;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseClass() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> BaseClass *<span class="title">getBaseClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="literal">nullptr</span>) base = <span class="keyword">new</span> BaseClass();</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">BaseClass *BaseClass::base = <span class="keyword">new</span> BaseClass();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">unique_ptr</span>&lt;BaseClass&gt; <span class="title">up</span><span class="params">(BaseClass::getBaseClass())</span></span>;</span><br><span class="line">        up.<span class="built_in">get</span>()-&gt;printHello(); <span class="comment">// &gt;: Hello, World!</span></span><br><span class="line">        (*up).printHello();     <span class="comment">// &gt;: Hello, World!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简而言之，提供了两种方式去使用智能指针里面的原生指针。</p>
<p>在设计自己的资源管理类时，需要考虑这样一个问题：</p>
<ul>
<li>提供 <code>get()</code> 函数来访问原生指针。</li>
<li>提供隐式转换函数来访问原生指针。</li>
</ul>
<p>隐式转换函数如下例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FontHandle</span> &#123;</span>&#125;;</span><br><span class="line"><span class="function">FontHandle <span class="title">getFont</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FontHandle();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fontHandle)</span></span></span><br><span class="line"><span class="function">            : <span class="title">f</span><span class="params">(fontHandle)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 提供一个隐式转换函数，来放出内部指针。</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeFontSize</span><span class="params">(FontHandle f, <span class="keyword">int</span> newSize)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Font <span class="title">font</span><span class="params">(getFont())</span></span>;</span><br><span class="line">    changeFontSize(font, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="16-成对使用-new-和-delete-时要采用相同形式"><a href="#16-成对使用-new-和-delete-时要采用相同形式" class="headerlink" title="16. 成对使用 new 和 delete 时要采用相同形式"></a>16. 成对使用 new 和 delete 时要采用相同形式</h1><blockquote>
<p>  如果在 <code>new</code> 表达式中使用 <code>[]</code> ，必须在相应的 <code>delete</code> 表达式中也使用 <code>delete []</code> ，如果在 <code>new</code> 表达式中没使用 <code>[]</code> ，那么在 <code>delete</code> 中也不应该使用。</p>
</blockquote>
<p><strong>意外发现</strong>：对于基本数据类型，<code>delete</code> 和 <code>delete []</code> 都能够完成内存释放，但是对于自定义数据类型（对象）构成的数组，就不行了，必须使用 <code>delete []</code> 。</p>
<h1 id="17-以独立语句将-newed-对象放入智能指针"><a href="#17-以独立语句将-newed-对象放入智能指针" class="headerlink" title="17. 以独立语句将 newed 对象放入智能指针"></a>17. 以独立语句将 newed 对象放入智能指针</h1><blockquote>
<p>  以独立语句将 <code>new</code> 出来的对象存储在智能指针里，如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。</p>
</blockquote>
<p>为什么这样做呢？还不是因为C++的各种编译器规范不统一，对于处理程序的优先权没有明确的定义。</p>
<p>总而言之，要这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;BaseClass&gt; <span class="title">spb</span><span class="params">(<span class="keyword">new</span> BaseClass())</span></span>;</span><br><span class="line"><span class="built_in">process</span>(spb);</span><br></pre></td></tr></table></figure>
<p>而不是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;BaseClass&gt;(<span class="keyword">new</span> BaseClass()));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Commit Message规范参考</title>
    <url>/2020/10/03/Git-commit-message%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<p>磨刀不误砍柴工，整完规范再打工。</p>
<a id="more"></a>
<p>规范的 <code>Git commit</code> 标准能方便大家的交流和协作，以及方便对版本进行<strong>回顾</strong>和<strong>发布</strong>。 这里主要参考来自 <code>angular</code> 的 <code>git commit</code> 日志作为基本规范。</p>
<h1 id="1-日志基本规范"><a href="#1-日志基本规范" class="headerlink" title="1. 日志基本规范"></a>1. 日志基本规范</h1><p><code>&lt;type&gt;(&lt;scope&gt;) : &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;</code></p>
<p>说明如下：</p>
<ul>
<li><p><code>type</code> ：表示提交的类型，比如是修复了 <code>bug</code> 还是新增功（漏）能（洞），可选的列表如下：</p>
<ul>
<li><code>feat</code> ： 新增功能</li>
<li><code>fix</code> ： 修复问题</li>
<li><code>docs</code> ：修改文档，例如 <code>README</code>，<code>CHANGELOG</code>，<code>CONTRIBUTE</code> 等</li>
<li><code>style</code> ：格式化程序，例如修改空格、缩进，不改变程序逻辑</li>
<li><code>refactor</code> ：代码重构，但没有新功能，也没有修复问题</li>
<li><code>perf</code> ：优化，例如提升性能，优化体验</li>
<li><code>test</code> ：测试用例</li>
<li><code>chore</code> ：改变构建流程，例如增加依赖库、工具等</li>
<li><code>revert</code> ：回到上一个版本</li>
</ul>
</li>
<li><p><code>scope</code> ：可选内容，表示修改范围</p>
</li>
<li><code>subject</code> ：标题，描述主要变更内容，<strong>50</strong>字符以内</li>
<li><code>body</code> ：主体内容，更详细的说明，<strong>72</strong>字符以内，需要包括：<ul>
<li>为什么修改？</li>
<li>如何解决？</li>
<li>是否存在副作用？风险？</li>
</ul>
</li>
<li><code>footer</code> ：如果有的话，可以链接到一个 <code>issue</code> 或者相关文档或程序</li>
</ul>
<h1 id="2-分支规范"><a href="#2-分支规范" class="headerlink" title="2. 分支规范"></a>2. 分支规范</h1><p><strong>基本原则：</strong><code>master</code> 要设置为保护分支，不直接在 <code>master</code> 上进行代码修改和提交。</p>
<p>对于一般的 <code>feature</code> 更新和 <code>bugfix</code> ，都要从 <code>master</code> 分支上 <code>checkout</code> 下来一个开发分支进行操作，完成之后再合并回 <code>master</code> 上，并且打上 <code>tag</code> 标签，最后删除开发分支。</p>
<p>需要注意的是，分支命名规则有：</p>
<ol>
<li>分支版本命名规则：<code>分支类型_分支发布时间_分支功能</code></li>
<li>分支类型包括：<code>feature</code> ，<code>bugfix</code> ，<code>refactor</code> 三种类型</li>
<li>时间使用 <code>yyyyMMdd</code> 格式，不足补零</li>
<li>下划线命名法</li>
</ol>
<p>对于标签的管理，要使用 <code>3</code> 个数来表示，例如：<code>v1.2.3</code> ，有如下规范：</p>
<pre><code>1. 新功能添加使用第 `2` 位版本号，`bug` 修复使用第 `3` 位
 2. 例如：`v1.2.3-alpha-1`，`v-1.2.3-beta-1` 等
</code></pre><h1 id="3-工作流程示例"><a href="#3-工作流程示例" class="headerlink" title="3. 工作流程示例"></a>3. 工作流程示例</h1><ol>
<li><p>创建一个 <code>feature</code> 或者 <code>bugfix</code> 分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b feature_20201003_helloworld</span><br><span class="line">git checkout -b bugfix_20201003_store_key</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交代码到本地 <code>Git</code> 仓库，并填写规范的 <code>Git Commit Message</code> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add *</span><br><span class="line">git commit -m <span class="string">&quot;feat: 新增helloworld。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将代码同步到远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin feature_20201003_helloworld</span><br></pre></td></tr></table></figure>
</li>
<li><p>打上 <code>tag</code> 并同步</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag v0.0.1</span><br><span class="line">git push origin v0.0.1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>emmmm，还是多实践比较好，记是记不住😑……</p>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>开发规范</tag>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Group Task 3 | Speaking Is More Important</title>
    <url>/2020/10/07/Group-task-3-Speaking-is-more-important/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="啊偶，密码不大对" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">哦吼？需要密码才能看~🤔</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="1d43703d9b3d9978a5880f7c4b20fd62b3026bf8385b56d6a917aceefa7a78cf">f09366631cbbc7d465e403bed5c067c10b79d1451227a60a2ac8ed210a516d7ddbc1a6e66ab174bddaf5cde66df72a994642066f9d045e4807595af0cc5083afa11661a8a757cfef6e54db4b4079d8233939f27c35a5e88f871de4d848e8b5cc037c8223c3aeb7081ce8e457745f1ce85e74b16ee1740199cdcf0883fc378025ef9de7fd599ab5ce93cb450b9c4c1b5f2ba6e42fbf91af68567f000d0e50f143bbdf06347e3f5cac77d15a6f8e1f38b16bcdd48f866894f96087f81d15825225f823d45f0c329e0cfe3b9730a30d1c3ce9b4aa3099e660386d829dbb2b4d9e55f37dc90a87a62d16c496203a6f5cff6a905fdaf20896ee40fcf1a1732f0b9c8f14770a920d3e9b6e3f4d4792cedfbeb392e55c716faa2a01d0a70fd0c38f0cfb6ce305573a3d9ec813c75e6accd2c53c3fd2124be60b2d4c20ccd711dfe8ef0aa86cef90e437c2e0e49437b301ff0ca40f16e428922f928143642fd2e0c70306152f24dc9c071a8b3511cda064f0fc122c064185d251bad5455e2aca7b22a4bf0232652fa9936be2a4acec9d5954466ca3df19de2e368802503ec82233f5bc3341125b70ba1e64a83bf75fdcd239a9e661864307cc839cb2d15833d2f95c37330523a8223c890ecb7f3fdaf5c3226e53c18c5c0c43db2b0443560dbe4c4b7466db9a00824d3ffd4497fbcfc3aa70e0e0cbeb3cc5289ebdd277a23c7e5d960e834c7b24335eeab32751c54e0369f7dc690968705ecd87f031a4424670812fed832558a3ed5ab4d6cf2ff100b8f9c96e30449dd964da1a58a6fa03ab05ec800e6cd8c744dce1c200ec257e1b8a7e87bc37b15b6a774493994e9b94b32bdf05e468de7d5d8a9c6be7aeef17ad6c70269f055dc37dcf5181c477b7c00e64c7624e5d4a80f81428a503a4c1a6138df9904de89c3c5a4878a35354f8337668a0ce18e741e5f5b5f9c2c3f3ce4c7db3d99a4f39cf5bc3087bc93e95365d8d14cbe38c599666a0bfe40df20ba928e2a87bcbd88a7c3f507c01638acb8ff811b97307ea79fa7a267c116a518ae847a69af5b985e59d1550515fb3efca029d36f7d00a29262507e4f67ab8b6ee19ad5d9eed6b2d5e23c29050e87c80a6d9d28a6fdda50e40c8dbfdf58b3709e4795ee8ad53b802c3d3dddd7f704eb594dcaa5e485a524ddd780e317b12e2ce7a040476cc6ef439f608d101b99038b1975b9cca2e75c9d2003b7295c0421b1c23c93db16a9d3350b74dff9e37b0a92e63ab5509f4dd4125d191de7d16739b9689cfa2b3b1ef4ea69ea1513221fb78043608c57b7aadf59d4385711c0e44992917f29a57a0a336dce97aef2141a9e5823e7e3eb9bbcc723da0d1ac2c566cc3bc4572b32c010593ab549cc727cfe4c2296b82ee66d768bd5c5560ccd9e2f179b46d769542ca87b59513b713f48e87871bf406869cea3b31f6c1a700d4f319180ab20a73125e5f7ab87864da0a68802c393fc362808daa497c3e8cec080b0bd55361c3cf6739a9ee6ddb7761656ce267ae437e5d0853731c5ee3fc18b0350deac8c2d899ede35ab5bf3bcb96c89c5a23ffd2044bf4e1e037d3188c4129f608f5890c6f1c144bd35c7714c01730169050f7ed78dfe816ab7a30f4939ab89fa8b863bb1e6ca3fc3b6245d9ee0879f016654479173fde7740763e98b0dd28b2e426cb207144b275ccddc1f327b7c9564d7988c1c41aaba203a003cbfdca23c9bfc8d13a83aa5b136493e75eff2e1053ee76c9cf0dc12bae16b150e19bbc04c5216d27522fc2c96b2d363b660b3cf52b5e4937098103be85f7158dde2e40c1eaee76462df95bd649d77555a51ebb544fd011c21984d1f4c6da6dd9c741d7ab0aea4f29bc534a1acc89192af328d4e79210184cd402e7bc40e8e5d5291bafe4d08904fe31885fe78a775d9753b89c50fae393e3d449a00b1dcfeb355fe50302ee61c89864cc0ee23988a17d1ef80d61e423e0b05da73b188b6a7f3b80156944e9428add4b0da1f9d79f0b791a58344a81cf4d2ff8dce2398ec3d9e7fa661e0803f2bbc9404757aa0382e76d0caca7e59f21e45e206201984ef41fa5e3e9538381b21b9c919c405891b3c451cd15a623a6b2a4f3f7f3164c67c89655ce53ffbc39d3301508de3f15f344a078bfcaf3231af795b0ebcd44da4f3c29e428ae32ec4a3b1bbd98620b587fa18ce39b52e16512b795868a72f869a1fefd061f13f07508c2bb713e0f1bd007ce3b3beedcab71a9614e2ca0f302b9f88339f63ab9e8647796bc19e339438a7268fd546cff8ea38941fcc049d45af396bc53df965f9cac0081fb0583ecda92bd1a69f23f6c697b6694262975c3a7bd6a323961b62291871a66815b4a75a9f1735740f44fb76f1db9216954e0fe623feb3f3d65f344191bb26e4aeac42fac4b8ddda7a8612cbd3903ca5302517680bae049f1c3bdbf6076c44b012c8f43760a990d984eb52d06ba42e1dcca2debf9e30f8307f44339b4d738f92dee3a275b9ebf8eb5c1f53afd66046848dd36efabd0b8001d78410b078387f4d0ba53a4e272f5fda32561a8e90b55108338829726881d6d988fd926784d8b95dce920b8bfff14d7dccc40bd8cb3db8f97b3466c50810fa5142448d87168595b92d128acee6e554f9e877d7561da96bc9ae87d88bd02b760aff8312a349241ff6b0039ba96ab383f8c022dc00dc691e2611c3b7309731bb397b5f80d69ad2b77219946801273cb42e7bfc7da31ef92f27e50fd2ea34a7bb61bf050e6dfcc1563defa270691f27aa9c70079d7dc03a67c1836755a56deec2028738c420761b2da21b59122f60e6979265bfa82aa311bd22c5189f42a4d300494fe95a296c8a0efd866a6f836d583f3722adeaf8af3cbcba47ede341676aca12b19bd49787fae17be442b5d75ad0f084896385b2e78c309b99c1f53b706db4d69d2267f7dd63e65f1591707b86dd2a16f6afbb761868f128cb1999ee114e8efbf75a10b6884af050cd5f19f2039d1fa678a7e28cadbaf60940c2cd54f18ccce5361bc65cb9873e02988f171b7e13872ab0474111078a8e34e3c7a17bbefc4c368f910660b6569881c4ae493293d116ca5897281ba3c27c5e61818fdc53e18a05604d39eaaa1f2e3326a4fdc09d95cd384d1c787d615a821bc8591c8e7ec0e9f260f40b7ca158da5edff41736dd0225932f120b7224e9d55e9d2a721b10bbd3c2c3a4ce98592af1539e3cc375392acace66b6c4ef64870c4734f53b6aee19d903f342f63fbd69e70975a52462af459a8ee5094b4f030eaf33ee47b14a2e901c3ed6bef0ed8dd6154db9eb0daa46e2f8991f26f5ac1302f9a307590102ce56817cc444e5db6e1ee7c5f47fa5e5fcdfa5606c2d55adcaa586294f1bcdc8be5ce7ff7aab47e1addbcc9f781a4abb66da63a8a3b8bbc2399b59761b7876f9d21d5ad81241dda01e0782c5bc83d70ecbab1ce1dc3acffedeeccedd4f039b8dde95af542af176aac49573e2e3c088fc67d18105f88d5fe5152737660a83a1ea1d807cc1d9b31a4cb5871c66d18f64b6ad27e62efd85907a318d79d5d0357d2d081ab29e02424f6e5438a90dbe2a33d8eeeed560462317cd3f295105e3d4d3a2a6ffcad490c265e5d2762f42f4b9c1112c2a1658d31e1547802337a83a7e5dce0d1db40f0580421608a3d6cbb33b853cd4d3a0f7bb4b955fe43a656bd421458b099472e1b7827100ef1ca97d8023647b51dd7f69946a9c901b873fc4bb860d2eecb7900e70d166425937b37c9f6d57249bda7d89a1add36c0b3984f212123386dd610cf0965dbd36b5a32b069b6592041c78734ef1ae20d06ffc2c47466952983b4cb0ea73c4e3a8b60d5f266edbc02353a7ab1a1e398b4bd68dc63a2468403cc9dc820d2e5afc6d313d392aa35318a2cf1ffc4c3652226b48cd9271ce76bb812dec891d9b814dd6d782ac83fb85b099ac412f1bf32bdfad81550b8615cc5dc995c15fa5fa009445d68d0c07316a1a67642446cb4e9017393f776ab03f35bf8bbf2287b378fddc78932dd5e29a2b2493a037e95f8333556d90b77bf852e3cd58ebac223c61d37aad57856b055d8d28fd83ace109bdc588e86ac754c7374036ccc1c04d2ba2b5fbcd739657238f136fe9c35e636a71280676bed6f18716afc0d142a47ec0ad2f86b798e8ee88cf502077d1fa3d7dc22804e192c755eb2cf5d90aeafd1065b12e34c193e66b7b5c5eade794e8c407518dc377d2397358be79773e76b7e0b34f08f60e3a7ae989cd16b0b54af84d8ed5e280c881d7e9910ad0c1d9c5101c67f386ddd7457b2360c5017b77fc0b81d871150a5537330713534537f3b48feaebffe52769bd99badbe15c47efa2d262a2db38d6ebaaf359e050a68f023533174f719da94939f407b45cb80d476d9a3efb9051759a81dcf98536284ba286f428f21d436b8ce1996ab7ae2498382b2623f21433be10d25c6f29ee9cc216398e5317705d0d49c0f68f0cb8efcebda9309e5093759ae9633b487b9d43908caa3988f1772200a5723d215e1c3fcc565c8c3c0cbc050ba2419ca3171ff8fb8bc7b2b2e04c450138c04062e69f93ff04eb67103de142617997fe69ffc053728d03399f8eff6c65dc8f804144c11a27ee2a0c6bf913324c722638cf68b6cf411a80d128aed37c9875db41a2a91588505bc1374f3fbac1380082b37117638a76232d155332cff96cbb3c0fe70b8856bc7e2b0abfa5ec7b12ebb5c63e45cda9465bc456c4378d069024e961549d2d2f375a48d1d777130429326887c5442d9afd908796f9321200d266e0d8b2f4eb1317e22e5679140e90371d6c60c5cc0c6fe41e8292454686f3170d8f12c17c6a5ed0e7fdf570b26c5f7cd9e28a58f40536ef98953ba5a9daf1ac22cd01212a77b33ba268b7ed8356a98f5f93f44b2d0f5cbbe99e4ee798cc43cd0a79b78276389f6b699467ae91a2305811cc586b59fec10d3f705a0d4cf20ecad57573ec8ecbc9324fbc7cda19ac2be2dd0690e10d02640f9704f6256351bdb353c115bf6307b6dda8143ba591288db12de8f17f5e9591227b4791bd225ce006fe1e48289ed908c5d3bbdbfc4526bc5c13cb600a17dcdd03b3fa0e9525efb8d8308c4e1052240e0665a8da62bb0d72adc831bade5c1cb240ea38c9f3b9d3a6c6a37c7ba1ab122c66a5beda47deb00fd451cbb7f75554a52542be2ec2c88533972e5ecaae992ab8f36b2772c78a44d09882f24d3358e40da141e1f1fde3160f854a7f865d81f5b4906c96a6aabd604126c9724ac88d1b48cc7417e18c7ef5f7653a75000ee2f2a677c852d9ae37816a159d751af4d8a303fd88f909c356269516ac3a331528fc7e4188304648b054fc9be1c4dbde31c7de12d3190541683c0b41c427af268aa7cbdb6dd7bf5bf07403df8b1abd162f8ad09dbeffefcfccaf4c94aec82129f012ae11addbaaa0512a7f98622031dba06d991d7276583bd859dea6c88026a9ac370873dc3c5289b405a4a3b3594d0bc4dd4b4379b3a089dc354fa23f107d1932f6ca29f1b8eb312cc55faa91ff550f1913ee553a56a3173236f97436822c8c4aea98a7ad49a720973d4789cb76f17f11d3a064328fa6dd808d071261d605236bfb10e25a078ea6d20ed43530f3e8e9c2d1a82daa7ebbd3f1b94b9ea19a13c4c27c1c94c42cff513a7e8f37371fa18de0957b744cd73f93292d081a39daa00e8d3f27b4e0290167e39aa09758df22377ec4c6bcba4159bc242c955945011a0c1ba0b40c8276db171fb8e41e40406ec6ead6d38d01cf523b84a8374bad333f497ae1974341c0f0e780aca3b483fc4041962dc7530e47f20bb076c18d521ac6fae43dfe35fd0dec1836e22a701ae097a4b3307b83e2c1cf6dbaed4d17afc7d89d71a8e2c72ae26ee19cb8d0dbaccd05e75a54a4cf254778d1e664bb8795079b57ed14552e7c17022cb429bac8ec8ba158fa8dac9770156895463f6ec7447db0e604802c93b6877aa6e8888caf7bcfc22289436e4f88f0bde9a7c37970b0161aa2525fc1fa5c02c9e0a326bba5e21a71b3fe5ba8e1e86b00d5eab930adce5f4a0ff67d1a4d3c52392f3cbcf927c0edff5d9d0ee20ba8d0fdefb53f9cc56f88d4026f383dc18e6fd63c7af1d596b92b95cdff326ea0987204b572d33c95c37c0c0993d7aab92d16ed61e45cfef5aaa4be9355cbd028191c1b153ec0df3545ac09cff1c5f5b9d091c3610fb6f97c4f06bbb18fc62ed8b7cc04c23aa0649bfc3a4c563855d7f15d276c7f7087b7e43e601276e23a23a293bd98816d1b68adbd9fcea37f74541bed289d63740a303f73da65dc1275ffc4654b5c9dffdafa761bfebcffe42e7e54dc83bbf8ad6a848511ac3403dab8d38fb5d2ce25428d466670d345197cca99b194cbaaf083e94a9a33419df00a08bbad3378cfdb2d5024bfd1cea444d0a0f2d96296082e0954eb657c6e1d193eaee59bd50bf91630a90ad097f861d0ab7bef088bc16130de83cd3d1aed997daae56630c8619ab648f43183bdea7689ce6c9a814c724572f142c939a3479217c1085210392ab5604af1892c42c83aa1feae998891f9ac06e60c43308d32926661f49c19bf4bec75ee649dcf6780741a444ca98203f942e158e6517e82ae3eba669e1744f4261e54ecbb2dd5e192f039ce1af811fcb5b87ac83a732d454c5b3db5cf9cb3bfc5451283b0d1a1a1d6c8ecc2f0e58e82759bf85f951d4c46d6ea34d9aaf4c8ef4512df98075c88c5f1c55c7aa8f2d03710c09fc87212c330423ba87de1164c8860dcabe78bd3ed7a9d82672e28da72c128950f86bbd56be08f7dfa5054074ec8b7107990acbbb8049313e2b380160a8c8d8c05198a9200a99db3f4d751848f4922886bd70491c86d274bdbd6cab94084b44f752bd680e0b9deb4fe4ab5d8b65d1a0b569fdec070c096f6480acd3aa29e2264f29557e6bac2fed64e62f6b1adc1c823bf1ddf828bc25a9d9a4ae0174bdf39b51a3ebd8265a65ed80edd4bdd87777a6a23484700364ca195e77bd0bd2ef1ddc0c5254d55b45766ab98b542880e957c53f6b96fa59eb5a9be597895a4fd72c415281348217d18df7bacd48b0b1e760e0c4df60a12c3432a1f818efc6c66baafc5d84c8617a5c28ac5fb81b9426cff6962350552fcfad906c2d85fb7fb2226a6cc26f039b96295a5aed994b713492f5b1bfbcbd1e3cb903db8e6528cc95abe9c133dd445692c5f23b383230873d4014dfc68c9ae5a9af7e2c5886a47610dc3747dfb6744ff8151e295194f06b41cb09c3afcd0f93fabf58dbd816bd406c06892960a7fae2f2c1db9c86f9d1533baa787b83baf137874ae699e0701aa384040d6bf0fd294cc0a470c3fd616929c39370481f479a664005a69f4aff32dc8aba413a8f5391bd9efab10f3dd87916f9aeaa4d4f116c4a3baa6d27ea5facc124a62430a490ce1b5c</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>Private</tag>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT主题配置</title>
    <url>/2020/08/30/Hexo-NexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>首先安装</strong></p>
<p>首先安装好 <code>NexT</code> ，从 <a href="https://github.com/theme-next/hexo-theme-next">这里</a> 下载克隆最新的 <code>NexT</code> ，然后把内容解压到 <code>Hexo</code> 安装目录下的 <code>theses</code> 文件夹中，并且重命名为 <code>next</code>。</p>
<a id="more"></a>
<p><strong>配置文件</strong> </p>
<p>完成上面步骤后，在 <code>Hexo</code> 的安装目录下，有一个文件夹 <code>themes</code> 该文件夹中存放着主题文件，在 <code>themes\next\</code> 文件夹下有配置文件 <code>_config.yml</code> （以后称为 <strong>NexT 配置文件</strong>） ，在该文件中，内容可以说是巨大无比，抽取关键内容，可以对以下内容进行配置。NexT配置<a href="https://theme-next.org/docs/theme-settings/">详细文档</a></p>
<h2 id="1-网站图标"><a href="#1-网站图标" class="headerlink" title="1 网站图标"></a>1 网站图标</h2><p>找到自己中意的图标后，先调整尺寸，一般都是 <code>16 * 16</code> 用作网站小图标，<code>32 * 32</code> 及以上用作站点图标（用户头像类似），然后保存在 <code>&#123;Hexo_home&#125;\source\image\</code> 下。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/icon-16.png</span>            <span class="comment"># 小图标</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/icon-32.png</span>           <span class="comment"># 中等图标</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/icon-32.png</span> <span class="comment"># 适配 Apple 设备</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/icon.svg</span>   <span class="comment"># safari 浏览器的小图标，需要用 svg 格式</span></span><br></pre></td></tr></table></figure>
<h2 id="2-版权声明"><a href="#2-版权声明" class="headerlink" title="2. 版权声明"></a>2. 版权声明</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="3-主题样式以及暗黑模式"><a href="#3-主题样式以及暗黑模式" class="headerlink" title="3. 主题样式以及暗黑模式"></a>3. 主题样式以及暗黑模式</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模式</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暗黑模式</span></span><br><span class="line"><span class="attr">darkmode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="4-菜单栏"><a href="#4-菜单栏" class="headerlink" title="4. 菜单栏"></a>4. 菜单栏</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否打开某一个菜单栏，打开的话只需要将前面的 # 注释去掉</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment"># sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment"># commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否显示图标、是否显示角标</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="5-社交链接"><a href="#5-社交链接" class="headerlink" title="5. 社交链接"></a>5. 社交链接</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据需要进行添加就好了</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/hxz1998</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">huxz1998@163.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br></pre></td></tr></table></figure>
<h2 id="6-阅读更多（Read-More）"><a href="#6-阅读更多（Read-More）" class="headerlink" title="6. 阅读更多（Read More）"></a>6. 阅读更多（Read More）</h2><p>这个功能类似于 <strong>全文展开</strong> ，第一步打开 <strong>阅读全文</strong> 按钮：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">read_more_btn:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>第二步，在某一个文章中，添加 <code>&lt;!-- more --&gt;</code> 标签，该标签前面的内容将会被展示，后面的内容将会被折叠。</p>
<h2 id="7-字数统计，阅读时长-amp-本地查询"><a href="#7-字数统计，阅读时长-amp-本地查询" class="headerlink" title="7. 字数统计，阅读时长 &amp; 本地查询"></a>7. 字数统计，阅读时长 &amp; 本地查询</h2><p>参考 <strong>配置Hexo</strong> 一文。</p>
<h2 id="8-访客统计"><a href="#8-访客统计" class="headerlink" title="8. 访客统计"></a>8. 访客统计</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span>      </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>              <span class="comment"># 首先打开该插件</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>      <span class="comment"># 是否显示访客</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span> <span class="comment"># 该数字前面的图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>         <span class="comment"># 总浏览量</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span>     <span class="comment"># 还是图标~</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>          <span class="comment"># 文章浏览量</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span>      <span class="comment"># 仍旧是图标</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <url>/2020/08/28/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1. 准备环境"></a>1. 准备环境</h1><p>所需软件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.js	-&gt; v12.18.3</span><br><span class="line">npm     -&gt; 6.14.6 </span><br><span class="line">Git     -&gt; 2.16.2.windows1</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 <code>Hexo</code></h1><p>首先在自己的磁盘里创建一个目录，例如 <code>C:\Blog</code>，打开命令行工具，然后输入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:                      <span class="comment"># 进入C盘</span></span><br><span class="line"><span class="built_in">cd</span> Blog	                <span class="comment"># 进入 Blog 文件夹</span></span><br><span class="line">npm install -g hexo-cli <span class="comment"># 安装 hexo 这个过程超级漫长，建议去喝一杯咖啡，如果没有修改 npm 的镜像源的话</span></span><br></pre></td></tr></table></figure><br>假如上面的过程没有出现什么幺蛾子，没有报错，也没有警告，那么恭喜，现在来到了 <code>hexo</code> 软件。</p>
<h1 id="3-在-Github-创建-Pages"><a href="#3-在-Github-创建-Pages" class="headerlink" title="3. 在 Github 创建 Pages"></a>3. 在 <code>Github</code> 创建 <code>Pages</code></h1><p>这里有两种创建的方法，可以创建<strong>仓库</strong>归属的 <code>Pages</code>，也可以创建<strong>帐户</strong>归属的 <code>Pages</code>，这里创建的是后者（账户归属），不为别的，因为好看。两者的区别主要在：</p>
<ol>
<li>仓库归属的最终访问路径为：<code>https://github.com/&#123;username&#125;/&#123;repo&#125;</code></li>
<li>账户归属的最终访问路径为：<code>https://&#123;username&#125;.github.io/</code></li>
</ol>
<p>在创建过程中，需要把仓库名称设置为自己的账户名称这样才能实现上面的第二种。</p>
<h1 id="4-创建本地博客并本地预览"><a href="#4-创建本地博客并本地预览" class="headerlink" title="4. 创建本地博客并本地预览"></a>4. 创建本地博客并本地预览</h1><p>回到第 2 步的命令行中，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog     <span class="comment"># 初始化博客仓库</span></span><br><span class="line">hexo new HelloHexo <span class="comment"># 创建第一篇文章</span></span><br></pre></td></tr></table></figure>
<p>然后可以到目录 <code>C:\Blog\source\_post</code> 目录下看到 <code>HelloHexo.md</code> 文件，找一个称手的 <code>MarkDown</code> 编辑器，通过修改该文件内容来完成内容编写。</p>
<p>修改完成后，继续回到上面的命令行中，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean    <span class="comment"># （可选）清除缓存，方便后面重新生成 hexo c</span></span><br><span class="line">hexo generate <span class="comment"># 生成相关页面，也可以 hexo g</span></span><br><span class="line">hexo server   <span class="comment"># 启动本地预览，也可以 hexo s</span></span><br></pre></td></tr></table></figure>
<p>然后就可以在 <code>http://localhost:4000/</code> 中看到自己的博客预览了，如果成功看到，那么恭喜，可以再喝一杯咖啡了😝。</p>
<h1 id="5-2020年9月1日更新"><a href="#5-2020年9月1日更新" class="headerlink" title="5.  2020年9月1日更新"></a>5.  2020年9月1日更新</h1><p>当使用 <code>hexo s</code> 来启动本地服务，然后进去网页报类似于 <code>(node:23020) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency</code> 错误时，需要将 <code>node</code> 从 <code>14</code> 版本降为 <code>12</code> 版本。</p>
<p>如果在 <code>git bash</code> 中使用 <code>Ctrl + c</code> 快捷键终止服务未响应的话，需要更新 <code>git</code> 。</p>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu分区方案</title>
    <url>/2020/09/30/Ubuntu%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>在安装了五次系统之后……</p>
<a id="more"></a>
<p>自打到了实验室，我已经安装了五次 <code>Ubuntu20.04</code> 系统，事情是这样的：</p>
<p><strong>第一次安装：</strong>老师发给一台电脑，台式机，一块 <code>1T</code> 机械硬盘，一条 <code>8G</code> 内存，这对我来说已经够用了，毕竟不跑深度学习也不打游戏，装个 <code>Linux</code> 写写程序，做做项目绰绰有余，于是乎拿了U盘就装上了 <code>Ubuntu20.04</code>，装好之后，安装用的一堆IDE，编译器，从 <code>Github</code> 上 <code>clone</code> 到本地程序，跑了个样例程序，通过，心里一阵开心。可是这都是假的，安装好之后重新启动，竟然卡在了启动界面，第一次安装失败告终……</p>
<p><strong>第二次安装：</strong>鉴于上次安装失败，这次在每个步骤上都谨小慎微（其实没啥要注意的，因为都是傻瓜式安装），这次，安装好后之后就直接重启系统，发现没有问题，安装软件过程也没有问题，再次开心😊。可是好景不长，由于创建 <code>Python</code> 虚拟环境报错，决定重新尝试安装 <code>Python3</code> 来解决问题，重新安装肯定要先卸载呀，结果问题就出在这里，卸载之后就……直接把 <code>Linux</code> 的桌面环境给删掉了😭，（）于是就有了第三次的故事……</p>
<p><strong>第三次安装：</strong>鉴于前两次失败的故事，这次更加地谨小慎微，下载，安装，配置，拉取代码……终于，功夫不负有心人，这次安装很成功，成功在机器上安装好了 <code>Ubuntu20.04</code> ，运行了第一个加密算法，并得到了结果，美滋滋😋。不过，天总有不测风云，所以才有了下次的故事……</p>
<p><strong>第四次安装：</strong>今天下午来到实验室，研讨结束后，老师突然来了句：前几天买了固态硬盘（<code>1T</code>）和内存条（<code>8G</code>），加上去把机器升下级。我……（内心是快乐还是崩溃，老师不知道，我也不知道），开心是因为硬件得到了升级呀，更好的工作环境当然开心，崩溃是因为，又双叒叕要重装系统了……本想着有了前三次的教训，这次可以很顺利安装过来，不过，呜呜呜：这次又在硬盘分区上翻车了😣。</p>
<p>这不，立刻回来对硬盘分区进行研究，康康到底该咋分区，然后给自己也写个记录，以免以后一直去查别人的教程。</p>
<ol>
<li>首先是 <code>boot</code> 引导分区：<code>10G (10240)</code> ，<code>ext4</code> 格式，空间起始位置，主分区</li>
<li>然后是根目录 <code>/</code> ：<code>300G (307200)</code> ，<code>ext4</code> 格式，空间起始位置，逻辑分区</li>
<li>紧接着是交换空间 <code>swap</code> ：<code>32G(32768)</code> ，<code>swap</code> 格式，空间起始位置，逻辑分区</li>
<li>最后是家目录 <code>home</code>：<code>1000 - 10 - 300 - 32 = 658G (673792)</code>，<code>ext4</code> 格式，空间起始位置，逻辑分区</li>
</ol>
<p>说到这里，突发奇想地，对于 <code>Ubuntu20.04</code> 而言，是不是有个省时省力的方法：索性<strong>不分区</strong>，全部根目录 <code>/</code> ，这样更省力，省的这会儿满了，那会儿不够用了，省去了解决杂七杂八问题的时间，去看点书不好么？😐</p>
<p>等待第五次安装的验证结果。</p>
<hr>
<p>（2020年10月9日）哈哈哈哈嘿嘿嘿嘿盒盒盒盒，装好了👇</p>
<p><img data-src="https://s1.ax1x.com/2020/10/09/0rewOf.png" alt="装好后的截图~"></p>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World！</title>
    <url>/2020/08/27/hello-world/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="啊偶，密码不大对" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">哦吼？需要密码才能看~🤔</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="51f9fef9ce0d1847282e5e840ee1457a920059dd70106abc45727bf157e25499">bc206bc0c013051c70f75f9b6dfbfcaa8f1e981ef933fd63e36206be14784b135b8d8e771c3c0af2254037f4410f1d36dd1d110c00867c02da9746f9609e0c77724951d075eb3bd522b1ac665b4baf50a307b3f82a66c1854749b7135c54dc051b8a5b1253a7dd7cd637918a0e6d2e33ad6b162b9901a7415409cf5c6c6124a0e81bff9f7b7338154579f5572481d21dce6bf382c550ad7fee60cc83b43c87f86bea41bd3a9cf443f67cd995ed4b6676f2ff23a001b5f81735b80bd19219a4fc657227220695256fc865f0f12b569821dd6a8a647d5a22ec1e41c36d0baabf69690174c580e9d02eb46f2a113b40064f43e414d4f83be02cca00dead1e2c25e3caab42367b3c5e2fce250adc15cc97f54357355407ac09178f5b341cc9b31dc50041e413a6ba06ad046fb2fb22e4a352eb948e7eb20dd1fb25244b37d1251a8e955ae5fa3574747bde8d194dea657cb430e58b64186253e076690d51d81a8a0f51dd3cb9af49fcdaa9406a3a3e64bcfac191a1e014ece91af96a3afd1816caf35df2351e5f3e4d72168036270680c79a75e62342c772870c64a3a7abfcefa86836b94d3463c30707f9c02363aaceabe7</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>Private</tag>
        <tag>初出茅庐</tag>
      </tags>
  </entry>
  <entry>
    <title>优先级队列的简单探索</title>
    <url>/2020/10/19/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<p>优先级队列（Priority  Queue）是一种抽象数据结构（Abstract Data Type，ADT），操作和队列类似，但是和队列的<strong>先进先出</strong>不一样，优先级队列中先出的是优先级最高的元素，这样的数据结构在操作系统和现实生活中广泛存在，例如任务调度。在这里列举一个算法竞赛题目：第1500个丑数，来演示用法。</p>
<a id="more"></a>
<blockquote>
<p>  以下内容参考自《算法竞赛入门经典》（第二版）</p>
</blockquote>
<p>在C++中，优先级队列的定义在头文件 <code>&lt;queue&gt;</code> 中，通过 <code>priority_queue&lt;int&gt; pq</code> 类似的声明来使用。在默认的实现中，优先级队列是一种<strong>“越小的整数优先级越低”</strong>的优先级队列，除此之外，由于不是先进先出了，所以取值操作从 <code>front()</code> 变成了 <code>top()</code> 。</p>
<h1 id="1-自定义类型使用优先级队列"><a href="#1-自定义类型使用优先级队列" class="headerlink" title="1. 自定义类型使用优先级队列"></a>1. 自定义类型使用优先级队列</h1><h2 id="1-1-提供比较函数对象"><a href="#1-1-提供比较函数对象" class="headerlink" title="1.1 提供比较函数对象"></a>1.1 提供比较函数对象</h2><p>对于自定义类型，需要使用 <code>&lt;</code> 运算符来完成优先级比较，所以我们可以使用一个“长得像”函数的结构体来定义比较方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a % <span class="number">10</span> &gt; b % <span class="number">10</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 个位数 大的 优先级反而小</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; int_pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) int_pq.push(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; int_pq.top() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        int_pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 10 1 11 12 2 3 13 14 4 15 5 6 16 7 17 8 18 9 19</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了一个 <code>class</code> 来让一个对象“长得像”比较函数，当然也可以用 <code>struct</code> 来声明。此处实现的是“个位数大的整数优先级反而小”的例子。</p>
<p>当然，STL提供了更方便的方法来覆盖掉原来的 <code>less</code> 函数对象，那就是 <code>greater()</code> 函数对象，来方便实现一些常见的优先级队列，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;&gt;&gt; int_pq;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-将一个类设计成可比较的"><a href="#1-2-将一个类设计成可比较的" class="headerlink" title="1.2 将一个类设计成可比较的"></a>1.2 将一个类设计成可比较的</h2><p>顾名思义，就是对一个类重写 <code>&gt;</code> 运算符和 <code>&gt;</code> 运算符，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node(<span class="keyword">int</span> _val) : val(_val) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重写 &lt; 运算符，这样用来比较两个元素的优先级，less 函数调用</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;lhs, <span class="keyword">const</span> Node &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.val &lt; rhs.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 &gt; 运算符，greater 函数调用</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Node &amp;lhs, <span class="keyword">const</span> Node &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.val &gt; rhs.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> to_string(val); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，重写了这两个运算符，使用这两个运算符将会帮助优先级队列比较两个对象的优先级，使用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Node&gt; node_pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) node_pq.push(Node(i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; node_pq.top().toString() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        node_pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 使用 greater 来让数值越小优先级越大</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Node, <span class="built_in">vector</span>&lt;Node&gt;, greater&lt;Node&gt;&gt; rev_pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) rev_pq.push(Node(i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; rev_pq.top().toString() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        rev_pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，好用！😋😋😋</p>
<h1 id="2-丑数（Ugly-Numbers-UVa-136）"><a href="#2-丑数（Ugly-Numbers-UVa-136）" class="headerlink" title="2. 丑数（Ugly Numbers, UVa 136）"></a>2. 丑数（Ugly Numbers, UVa 136）</h1><p>丑数是指不能被<strong>2, 3, 5</strong>以外的其他<strong>素数</strong>整除的数，把丑数从小到大排序，得到：</p>
<script type="math/tex; mode=display">
1,2,3,4,5,6,8,9,10,12,15...</script><p>求第<strong>1500</strong>个丑数。</p>
<p><strong>【分析】</strong>：</p>
<p>从小到达生成丑数，最小的丑数是1，对于任意<strong>x，2x，3x</strong>也都是丑数。因此可以使用一个集合来保存所有的丑数（防止重复），使用优先级队列来保存用来生成丑数的数据（保证能够取到当前最小的丑数），这样每次可以得到3个丑数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/10/19.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/10/19 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> coeff[<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把丑数从小到大排序</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;LL, <span class="built_in">vector</span>&lt;LL&gt;, greater&lt;&gt;&gt; pq;</span><br><span class="line">    <span class="comment">// 丑数集合</span></span><br><span class="line">    <span class="built_in">set</span>&lt;LL&gt; s;</span><br><span class="line">    <span class="comment">// 初始值放进来</span></span><br><span class="line">    pq.push(<span class="number">1</span>);</span><br><span class="line">    s.insert(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; ++i) &#123;</span><br><span class="line">        LL x = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1500</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The 1500`th ugly number is &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            LL x2 = x * coeff[j];</span><br><span class="line">            <span class="keyword">if</span> (!s.count(x2)) &#123;</span><br><span class="line">                s.insert(x2);</span><br><span class="line">                pq.push(x2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>恭喜~解决一个简单题~😉</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全领域国际会议</title>
    <url>/2020/09/19/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E5%9B%BD%E9%99%85%E4%BC%9A%E8%AE%AE/</url>
    <content><![CDATA[<p>了解一下信息安全领域的国际顶会</p>
<a id="more"></a>
<h1 id="四大信息安全国际会议"><a href="#四大信息安全国际会议" class="headerlink" title="四大信息安全国际会议"></a>四大信息安全国际会议</h1><h2 id="1-CCS（Computer-and-Communications-Security）"><a href="#1-CCS（Computer-and-Communications-Security）" class="headerlink" title="1. CCS（Computer and Communications Security）"></a>1. <a href="https://dl.acm.org/conference/ccs">CCS（Computer and Communications Security）</a></h2><h3 id="通用信息"><a href="#通用信息" class="headerlink" title="通用信息"></a>通用信息</h3><p>名称：计算机与通信安全</p>
<p>日期：1993-今</p>
<p>位置：美国</p>
<h3 id="论文提交信息"><a href="#论文提交信息" class="headerlink" title="论文提交信息"></a>论文提交信息</h3><p>摘要：</p>
<p>全文：</p>
<p>演示方式：</p>
<h3 id="组织机构信息"><a href="#组织机构信息" class="headerlink" title="组织机构信息"></a>组织机构信息</h3><p>赞助者：SIGSAC</p>
<p>组织者：ACM</p>
<p>组织委员会：Committee on Publication Ethics (COPE)</p>
<p>学术委员会：ACM</p>
<p>其他委员会：</p>
<h3 id="参与者信息"><a href="#参与者信息" class="headerlink" title="参与者信息"></a>参与者信息</h3><p>参与者数量：</p>
<p>参会者要求：</p>
<p>会议VIP</p>
<p>其他成员</p>
<h3 id="会议程序"><a href="#会议程序" class="headerlink" title="会议程序"></a>会议程序</h3><p>会议手册：</p>
<p>邀请：</p>
<blockquote>
<p>  We invite submissions from academia, government, and industry presenting novel research on all theoretical and practical aspects of computer security, as well as case studies and implementation experiences.</p>
</blockquote>
<p>征文：<a href="https://www.acm.org/publications/authors/calls-for-papers">https://www.acm.org/publications/authors/calls-for-papers</a></p>
<hr>
<h2 id="2-USENIX-Security"><a href="#2-USENIX-Security" class="headerlink" title="2. USENIX Security"></a>2. <a href="https://www.usenix.org/conference/usenixsecurity21">USENIX Security</a></h2><h3 id="通用信息-1"><a href="#通用信息-1" class="headerlink" title="通用信息"></a>通用信息</h3><p>名称：USENIX 安全</p>
<p>日期：1975-今</p>
<p>位置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">USENIX Association</span><br><span class="line">2560 Ninth St., Suite 215</span><br><span class="line">Berkeley, CA 94710</span><br><span class="line">USA</span><br></pre></td></tr></table></figure>
<h3 id="论文提交信息-1"><a href="#论文提交信息-1" class="headerlink" title="论文提交信息"></a>论文提交信息</h3><p>摘要：</p>
<p>全文：</p>
<p>演示方式：</p>
<h3 id="组织机构信息-1"><a href="#组织机构信息-1" class="headerlink" title="组织机构信息"></a>组织机构信息</h3><p>赞助者：USENIX</p>
<p>组织者：Michael Bailey, Rachel Greenstadt</p>
<p>组织委员会：Yousra Aafer, <em>University of Waterloo</em>, Ruba Abu-Salma, <em>University College London and Inria</em> …</p>
<p>学术委员会：</p>
<p>其他委员会：Srdjan Capkun, <em>ETH Zurich</em></p>
<h3 id="参与者信息-1"><a href="#参与者信息-1" class="headerlink" title="参与者信息"></a>参与者信息</h3><p>参与者数量：</p>
<p>参会者要求：</p>
<p>会议VIP：</p>
<p>其他成员</p>
<h3 id="会议程序-1"><a href="#会议程序-1" class="headerlink" title="会议程序"></a>会议程序</h3><p>会议手册：<a href="https://www.usenix.org/conferences/coc">https://www.usenix.org/conferences/coc</a></p>
<p>邀请：</p>
<blockquote>
<p>Invited talks and panel discussions will be held in parallel with the refereed paper sessions. Please submit topic suggestions and talk and panel proposals via email to <a href="mailto:sec21it@usenix.org">sec21it@usenix.org</a> by Thursday, February 4, 2021.</p>
</blockquote>
<p>征文：<a href="https://www.usenix.org/conference/usenixsecurity21/call-for-papers">https://www.usenix.org/conference/usenixsecurity21/call-for-papers</a></p>
<hr>
<h2 id="3-IEEE-Symposium-on-Security-and-Privacy"><a href="#3-IEEE-Symposium-on-Security-and-Privacy" class="headerlink" title="3. IEEE Symposium on Security and Privacy"></a>3. <a href="http://www.ieee-security.org/TC/SP-Index.html">IEEE Symposium on Security and Privacy</a></h2><h3 id="通用信息-2"><a href="#通用信息-2" class="headerlink" title="通用信息"></a>通用信息</h3><p>名称：IEEE 安全隐私研讨会</p>
<p>日期：1980-今</p>
<p>位置：美国</p>
<h3 id="论文提交信息-2"><a href="#论文提交信息-2" class="headerlink" title="论文提交信息"></a>论文提交信息</h3><p>摘要：</p>
<p>全文：</p>
<p>演示方式：</p>
<h3 id="组织机构信息-2"><a href="#组织机构信息-2" class="headerlink" title="组织机构信息"></a>组织机构信息</h3><p>赞助者：IEEE Computer Security Technical Committee on Security and Privacy</p>
<p>组织者：2019：Sean Peisert</p>
<p>组织委员会：IEEE Computer Security Technical Committee</p>
<p>学术委员会：Technical Committee on Security and Privacy</p>
<p>其他委员会：</p>
<h3 id="参与者信息-2"><a href="#参与者信息-2" class="headerlink" title="参与者信息"></a>参与者信息</h3><p>参与者数量：</p>
<p>参会者要求：</p>
<p>会议VIP：</p>
<p>其他成员</p>
<h3 id="会议程序-2"><a href="#会议程序-2" class="headerlink" title="会议程序"></a>会议程序</h3><p>会议手册：<a href="https://www.usenix.org/conferences/coc">https://www.usenix.org/conferences/coc</a></p>
<p>邀请：</p>
<p>征文：<a href="https://www.ieee-security.org/TC/SP2021/cfpapers.html">https://www.ieee-security.org/TC/SP2021/cfpapers.html</a></p>
<hr>
<h2 id="4-NDSS"><a href="#4-NDSS" class="headerlink" title="4. NDSS"></a>4. <a href="https://www.ndss-symposium.org/">NDSS</a></h2><h3 id="通用信息-3"><a href="#通用信息-3" class="headerlink" title="通用信息"></a>通用信息</h3><p>名称：Network and Distributed System Security Symposium</p>
<p>日期：1992-今</p>
<p>位置：美国</p>
<h3 id="论文提交信息-3"><a href="#论文提交信息-3" class="headerlink" title="论文提交信息"></a>论文提交信息</h3><p>摘要：<a href="https://www.ndss-symposium.org/ndss2020/templates/">https://www.ndss-symposium.org/ndss2020/templates/</a></p>
<p>全文：</p>
<p>演示方式：</p>
<h3 id="组织机构信息-3"><a href="#组织机构信息-3" class="headerlink" title="组织机构信息"></a>组织机构信息</h3><p>赞助者：NFS、Google、Intel、Internet Society、CISCO</p>
<p>组织者：NDSS 2020</p>
<p>组织委员会：Trent Jaeger, co-chair, <em>Pennsylvania State University</em></p>
<p>学术委员会：NDSS 2020 Program Committee</p>
<p>其他委员会：</p>
<h3 id="参与者信息-3"><a href="#参与者信息-3" class="headerlink" title="参与者信息"></a>参与者信息</h3><p>参与者数量：</p>
<p>参会者要求：</p>
<ol>
<li><p>University Researchers and Educators</p>
</li>
<li><p>Chief Technology and Privacy Officers</p>
</li>
<li><p>Security Analysts and System Administrators</p>
</li>
<li><p>Operations and Security Managers</p>
</li>
</ol>
<p><em>Attendance is limited to foster maximum exchange of information and ideas.</em></p>
<p>会议VIP：</p>
<p>其他成员</p>
<h3 id="会议程序-3"><a href="#会议程序-3" class="headerlink" title="会议程序"></a>会议程序</h3><p>会议手册：<a href="https://www.ndss-symposium.org/ndss2020/coronavirus-covid-19-update/">https://www.ndss-symposium.org/ndss2020/coronavirus-covid-19-update/</a></p>
<p>邀请：</p>
<p>征文：<a href="https://www.ndss-symposium.org/ndss-2021/call-for-papers/">https://www.ndss-symposium.org/ndss-2021/call-for-papers/</a></p>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>初出茅庐</tag>
        <tag>信息安全会议</tag>
      </tags>
  </entry>
  <entry>
    <title>再探C++的类（构造函数）</title>
    <url>/2020/10/18/%E5%86%8D%E6%8E%A2CPP%E7%9A%84%E7%B1%BB%EF%BC%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>  以下内容参考自 <a href="https://book.douban.com/subject/25708312/">C++ Primer (5th)</a></p>
</blockquote>
<a id="more"></a>
<h1 id="1-构造函数初始值列表"><a href="#1-构造函数初始值列表" class="headerlink" title="1. 构造函数初始值列表"></a>1. 构造函数初始值列表</h1><p>在之前使用Java时候，经常这样初始化成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitData</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> desc = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    InitData(<span class="keyword">int</span> _id, <span class="built_in">string</span> &amp;_desc) &#123;</span><br><span class="line">        id = _id;</span><br><span class="line">        desc = _desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种初始化方法结果是正确的，但是没有用到C++的构造函数<strong>初始值操作</strong>，用的是<strong>赋值操作</strong>，所以效率比较高的是这样的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitData</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> desc = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    InitData(<span class="keyword">int</span> _id, <span class="built_in">string</span> &amp;_desc) : id(_id), desc(_desc) &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造函数有时候不能缺少，例如使用到了<strong>常量值</strong>和<strong>引用类型的初始值</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstRef</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConstRef(<span class="keyword">int</span> ii) : i(ii), const_i(ii), ref_i(i) &#123;&#125;</span><br><span class="line">    <span class="comment">// 如果这个时候使用赋值操作的话，就会出问题，例如：</span></span><br><span class="line">    ConstRef(<span class="keyword">int</span> ii) &#123;</span><br><span class="line">        i = ii;</span><br><span class="line">        const_i = ii; <span class="comment">// 报错，不能对 const 进行赋值操作</span></span><br><span class="line">        ref_i = i;   <span class="comment">// 报错，没有初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> const_i;</span><br><span class="line">    <span class="keyword">int</span> &amp;ref_i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  如果成员是 <code>const</code> 、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表来为这些成员提供初始值。</p>
</blockquote>
<p>而且，这两种方法还会影响到性能问题，初始化和赋值相比较而言，前者直接初始化数据成员，而后者先初始化，再赋值，所以最好是养成使用初始化列表的方法。</p>
<p><strong>初始化成员列表的顺序</strong>也很重要，如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> j, i;</span><br><span class="line">    <span class="comment">// 下面这个顺序是错误的，因为需要先初始化 i，但实际上初始化了 j</span></span><br><span class="line"><span class="comment">//    int i, j;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X(<span class="keyword">int</span> val) : j(val), i(j) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过~最好不使用同一个对象的其他成员来初始化。</p>
<p>也可以使用默认实参和构造函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegating_Constructor</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> _name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> _age = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 实际上，如果每一个参数都提供了默认值，那么就等于提供了默认构造函数</span></span><br><span class="line">    Delegating_Constructor(<span class="built_in">string</span> name = <span class="string">&quot;name&quot;</span>, <span class="keyword">int</span> age = <span class="number">0</span>) : _name(name), _age(age) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="2-委托构造函数"><a href="#2-委托构造函数" class="headerlink" title="2. 委托构造函数"></a>2. 委托构造函数</h1><p>在 <code>C++11</code> 中，提供了构造函数的另一种使用方法，构造函数A使用构造函数B来传递构造，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegating_Constructor</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> _name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> _age = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 非委托构造函数</span></span><br><span class="line">    <span class="comment">// 实际上，如果每一个参数都提供了默认值，那么就等于提供了默认构造函数</span></span><br><span class="line">    Delegating_Constructor(<span class="built_in">string</span> name = <span class="string">&quot;name&quot;</span>, <span class="keyword">int</span> age = <span class="number">0</span>) : _name(name), _age(age) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时如果再提供这样的函数，那么将会报错</span></span><br><span class="line">    <span class="comment">// call of overloaded &#x27;Delegating_Constructor()&#x27; is ambiguous</span></span><br><span class="line">    <span class="comment">// Delegating_Constructor() &#123;&#125;</span></span><br><span class="line">    <span class="comment">// 委托构造函数，委托上面的构造函数</span></span><br><span class="line">    Delegating_Constructor(<span class="keyword">int</span> age) : Delegating_Constructor(<span class="string">&quot;&quot;</span>, age) &#123;&#125;</span><br><span class="line">    Delegating_Constructor(<span class="built_in">string</span> name) : Delegating_Constructor(name, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="3-默认构造函数"><a href="#3-默认构造函数" class="headerlink" title="3. 默认构造函数"></a>3. 默认构造函数</h1><blockquote>
<p>  如果在一个类中，提供了其他构造函数，那么最好也提供一个默认构造函数。</p>
</blockquote>
<p>需要注意的是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并没有使用到默认构造函数来创建一个对象，而是声明了一个函数，接受一个空参数列表，返回一个 Sales_Data 对象</span></span><br><span class="line"><span class="function">Sales_Data <span class="title">obj</span><span class="params">()</span></span>; </span><br><span class="line">obj.isbn(); <span class="comment">// 报错，因为 obj 是一个函数</span></span><br></pre></td></tr></table></figure>
<h1 id="4-隐式类型转换"><a href="#4-隐式类型转换" class="headerlink" title="4. 隐式类型转换"></a>4. 隐式类型转换</h1><p>这个是万万没想到的，还有这个操作！例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_Data</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_Data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_Data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) : bookNo(s) &#123;&#125;</span><br><span class="line">    Sales_Data(<span class="keyword">int</span> _id) : id(_id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 (int _id) 构造函数来创建这个对象</span></span><br><span class="line">    Sales_Data sdint = (Sales_Data) <span class="number">1</span>;</span><br><span class="line">    Sales_Data sdstring = (Sales_Data) name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是需要注意的是，这个隐式类型转换，只能<strong>转换一次</strong>，不能连续两次转换，例如：<code>&quot;abc&quot; -&gt; string -&gt; const string</code>，这样是不行的。</p>
<p>也可使用 <code>explicit</code> 关键字来声明，这个构造函数<strong>不能</strong>用来隐式类型转换！但是仍然可以使用<strong>构造函数</strong>方法以及 <code>static_cast&lt;&gt;()</code> 函数来强制类型转换。</p>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>初识C++的类</title>
    <url>/2020/10/08/%E5%88%9D%E8%AF%86CPP%E7%9A%84%E7%B1%BB/</url>
    <content><![CDATA[<p>这两天补了补C++关于类的内容，参考的是  <a href="https://book.douban.com/subject/25708312/">C++ Primer (5th)</a>。</p>
<blockquote>
<p>   类的基本思想是<strong>数据抽象（Data Abstraction）</strong>和<strong>封装（encapsulation）</strong>。数据抽象是一种依赖接口（interface）和实现（implementation）分离的编程技术。封装实现了类的接口和实现的分离。</p>
</blockquote>
<a id="more"></a>
<h1 id="1-定义抽象数据类型"><a href="#1-定义抽象数据类型" class="headerlink" title="1. 定义抽象数据类型"></a>1. 定义抽象数据类型</h1><p>假设有这么一个类：它是书籍的抽象，包括三个字段：</p>
<ul>
<li><code>isbn</code>：书籍的 <code>ISBN</code> 号</li>
<li><code>units_sold</code>：书籍的销售数量</li>
<li><code>revenue</code>：书籍的销售额</li>
</ul>
<p>那么这个类可以是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> bookNo; 			<span class="comment">// isbn</span></span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;<span class="comment">// 卖出去多少本</span></span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;;	<span class="comment">// 这本书所获得的收入</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 四个构造函数</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) : bookNo(s) &#123;&#125;;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p) : bookNo(s), units_sold(n), revenue(p * n) &#123;&#125;;</span><br><span class="line">    Sales_data(istream &amp;);</span><br><span class="line">    <span class="comment">// 两个成员函数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;;	<span class="comment">// 获取到这本书的 isbn 号，默认 inline 函数</span></span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;)</span></span>;<span class="comment">// 将两个 Sales_Data 出售量相加</span></span><br><span class="line">    <span class="comment">// 友元声明函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个非成员接口函数</span></span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.avg_price();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span> </span>&#123;</span><br><span class="line">    Sales_data sum = lhs;</span><br><span class="line">    sum.combine(rhs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-1-成员函数"><a href="#1-1-成员函数" class="headerlink" title="1.1 成员函数"></a>1.1 成员函数</h2><p>其中的 <code>double avg_price() const;</code> 、 <code>string isbn() const;</code>  、 <code>Sales_data &amp;combine(const Sales_data &amp;);</code> 均只有声明，并未具体定义。</p>
<blockquote>
<p>  成员函数必须在类的内部<strong>声明</strong>，但是不是必须在类的内部<strong>定义</strong>。而且定义在类内部的函数是隐式 <code>inline</code> 的。</p>
<p>  成员函数通过一个名为 <code>this</code> 的额外隐式参数来访问调用它的那个对象。</p>
</blockquote>
<p>例如，当我们在调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">total.isbn();</span><br></pre></td></tr></table></figure>
<p>实际上编译器会把 <code>total</code> 的地址传递给 <code>isbn()</code> 的隐式形参 <code>this</code>，可以当作以下调用过程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data::isbn(&amp;total);</span><br></pre></td></tr></table></figure>
<p>这一点可以类比 <code>Python</code> 中成员函数的 <code>self</code> 变量。在成员函数体内部去使用任何对象的成员，都会被看作是 <code>this</code> 的隐式引用过程。例如， <code>isbn()</code> 函数的调用可以等价为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;;</span><br></pre></td></tr></table></figure>
<p>而且，每个对象的 <code>this</code> 指针总是指向该对象自己，所以它是默认 <code>const</code> 的（一个常量指针），不允许改变 <code>this</code> 中的地址。</p>
<h2 id="1-2-const-成员函数"><a href="#1-2-const-成员函数" class="headerlink" title="1.2 const 成员函数"></a>1.2 <code>const</code> 成员函数</h2><blockquote>
<p>  紧随参数列表之后的 <code>const</code> 关键字，作用是修改隐式 <code>this</code> 指针的类型。</p>
</blockquote>
<p>例如 <code>isbn()</code> 函数，函数签名末尾附带了一个 <code>const</code> ，这个 <code>const</code> 意思是说，在这个函数内部，不允许修改调用者的内容（当然也有例外，例如声明了 <code>mutable</code> 的成员😮）。简而言之 <code>const</code> 放在函数签名之后意思是：对象只能读不能写。</p>
<blockquote>
<p>  常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p>
</blockquote>
<h2 id="1-3-定义一个返回-this-对象的函数"><a href="#1-3-定义一个返回-this-对象的函数" class="headerlink" title="1.3 定义一个返回 this 对象的函数"></a>1.3 定义一个返回 <code>this</code> 对象的函数</h2><p>来，直接看例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;rhs)</span> </span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，功能类似于 <code>+=</code>，其返回值为 <code>Sales_data &amp;</code> 一个引用类型，那么最后返回值为 <code>*this</code>，也就把调用者给带了回来。这样写的好处在于，可以这样子用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">data.combine(b).combine(c).combine(e).......</span><br></pre></td></tr></table></figure>
<h2 id="1-4-定义类相关的非成员函数"><a href="#1-4-定义类相关的非成员函数" class="headerlink" title="1.4 定义类相关的非成员函数"></a>1.4 定义类相关的非成员函数</h2><p>例如上面例子中的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>三个函数，这三个函数并不是成员函数，但是它们做了一些辅助工作，所以它们和 <code>Sales_data</code> 类相关，这样的函数<strong>一般都要放到类声明的头文件内</strong>，这样方便用户引入一个头文件就可以使用了。</p>
<h2 id="1-5-定义构造函数"><a href="#1-5-定义构造函数" class="headerlink" title="1.5 定义构造函数"></a>1.5 定义构造函数</h2><p>关于构造函数，和 <code>Java</code> 它们都类似：没返回值，函数名和类名同名，可重载，如果一个都没有那么编译器会默认给补上，如果有任意一个那么编译器不补……在这里主要说一个不同的：</p>
<p><code>= default</code> 默认构造函数：这是 <code>C++11</code> 带来的新特性，当定义了其他（有参数）的构造函数后，如果还需要默认空参数列表的构造函数，可以使用 <code>Sales_data() = default;</code> 来让编译器继续补上。同样的，如果在类内部，那么该函数就是 <code>inline</code> 的。</p>
<p>初始值列表可以使用 <code>Sales_data(const string &amp;s) : bookNo(s) &#123;&#125;;</code> 这样的形式来定义，<code>:</code> 冒号加 <code>()</code> 定义法（自己想的名字😊）</p>
<h1 id="2-访问控制和封装"><a href="#2-访问控制和封装" class="headerlink" title="2. 访问控制和封装"></a>2. 访问控制和封装</h1><p>使用 <code>public</code> 、<code>protected</code> 、<code>private</code> 访问说明符来控制下面的内容是可以怎样访问的。</p>
<p>使用 <code>struct</code> 和 <code>class</code> 关键字来声明类，仅仅在访问方式上有所差别：</p>
<blockquote>
<p>  使用 <code>struct</code> 时，默认类的成员都是 <code>public</code> 的；使用 <code>class</code> 时，默认类的成员都是 <code>private</code> 的。所以仅仅通过编程风格就可决定使用哪一个。</p>
</blockquote>
<h2 id="2-1-友元"><a href="#2-1-友元" class="headerlink" title="2.1 友元"></a>2.1 友元</h2><p>这个东西就是方便了非本类的内容来访问本类的内容。例如：其他类或者其他不属于自己的函数，例如的例如：上面的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 友元声明函数</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这三个方法原来是没办法访问类内的私有变量的，例如 <code>revenue</code> 成员，但是加上 <code>friend</code> 之后就可以了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.avg_price();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>友元声明只能放到类的内部，但是类内出现的具体位置不限。而且友元不受访问控制的限制。</p>
<blockquote>
<p>  一般来说，最好在类的定义开始或者结束前的位置集中声明友元。</p>
</blockquote>
<p>除此之外，友元不能传递，例如 <code>B</code> 是 <code>A</code> 的友元，<code>C</code> 是 <code>B</code> 的友元，那么 <code>C</code> 也不能访问人家 <code>A</code> 的私有变量，谁的朋友就是谁的，不能乱来。</p>
<p>还有一个需要注意的地方，友元函数在类内声明之后，如果在同一个文件里实现，有两种选择，一种就是直接在类内实现，另一个就是类外内联。如果这两个都不满意，需要放到另外的文件夹里进行实现，在同一个文件里必须内联。</p>
<p>而且，如果是类的成员函数去调用类的友元函数，那么也是必须被声明过的（不过，并不是所有的编译器都要求这样的规定）。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//    X() &#123; f(); &#125; 错误的！f() 还没有声明！</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// void X::g() &#123; return f(); &#125; 错误的！因为 f() 还没有得到声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f(); &#125;</span><br></pre></td></tr></table></figure>
<p>（这里 CLion 有坑！暂时没填！具体现象就是：有时候不单独再声明一遍也可以直接使用友元函数，就是没语法提示，但有时候直接就是报错！换个构造函数、填充初始值都能让这个问题解决。具体参考下面的 <code>X.hh</code> 和 <code>X.cc</code>）</p>
<h2 id="2-X-聊点好玩的"><a href="#2-X-聊点好玩的" class="headerlink" title="2.X 聊点好玩的"></a>2.X 聊点好玩的</h2><p><strong>封装的好处</strong>，两个优点：</p>
<ul>
<li>确保用户代码不会无意间破坏封装对象的状态</li>
<li>被封装的具体实现，可以随时改变，只要对外的接口没变就行</li>
</ul>
<h1 id="3-其他特性"><a href="#3-其他特性" class="headerlink" title="3. 其他特性"></a>3. 其他特性</h1><h2 id="3-1-成员类型别名"><a href="#3-1-成员类型别名" class="headerlink" title="3.1 成员类型别名"></a>3.1 成员类型别名</h2><p>使用 <code>typedef type name</code> 或者 <code>using name = type</code> 来完成定义。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line"><span class="keyword">using</span> ScreenIndex = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt;::size_type;</span><br></pre></td></tr></table></figure>
<p>那么在下文中，就可以这样使用了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Screen(pos ht, pos wd, <span class="keyword">char</span> c) : <span class="built_in">height</span>(ht), <span class="built_in">width</span>(wd), contents(ht * wd, c) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(ScreenIndex index)</span></span>;</span><br></pre></td></tr></table></figure>
<p>而且用来定义类型的成员必须放在最前面，因为<strong>先定义后使用</strong>。</p>
<h2 id="3-2-内联函数-inline"><a href="#3-2-内联函数-inline" class="headerlink" title="3.2 内联函数 inline"></a>3.2 内联函数 <code>inline</code></h2><blockquote>
<p>   在类的内部定义的成员函数默认为 <code>inline</code> 类型，当然也有一些规模较小的函数适合于被声明成内联函数，然后放在类外进行定义。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line">    <span class="comment">// 声明一个友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Windows_Mgr</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用类型别名等价地去声明一个类型名字</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> contents[<span class="built_in">cursor</span>]; &#125;   <span class="comment">// 隐式内联函数</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">get</span><span class="params">(pos r, pos c)</span> <span class="keyword">const</span></span>;          	<span class="comment">// 显式内联函数</span></span><br><span class="line">    <span class="function">Screen &amp;<span class="title">move</span><span class="params">(pos r, pos c)</span></span>;                     <span class="comment">// 能在外面被设置为内联函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line">    pos <span class="built_in">height</span> = <span class="number">0</span>, <span class="built_in">width</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::move</span><span class="params">(pos r, pos c)</span> </span>&#123;</span><br><span class="line">    pos row = r * <span class="built_in">width</span>;</span><br><span class="line">    <span class="built_in">cursor</span> = row + c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">// 把自己返回回去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，使用内联函数时要注意：</p>
<p>要么在 <code>.hh</code> 头文件中写好 <code>inline</code> 函数的定义（和声明在同一个文件中），要么在 <code>.cc</code> 文件中不要写当作一个普通成员函数。</p>
<h2 id="3-3-可变数据成员"><a href="#3-3-可变数据成员" class="headerlink" title="3.3 可变数据成员"></a>3.3 可变数据成员</h2><p><code>mutable</code> 扭转一切，即便调用一个 <code>const</code> 方法，如果内部修改的变量是声明为 <code>mutable</code> 的，那么它也可以正常修改，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> assess_ctr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_somethings</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sales_data::do_somethings</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    assess_ctr++; <span class="comment">// 这样也是成立的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了~🥱这次就先到这里……😪😪😪</p>
<h1 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h1><p><code>Sales_data.hh</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/10/7.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/10/7 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CXX_EXE_SALES_DATA_HH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CXX_EXE_SALES_DATA_HH</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> assess_ctr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) : bookNo(s) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p) : bookNo(s), units_sold(n), revenue(p * n) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Sales_data(istream &amp;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span> </span>&#123;</span><br><span class="line">        Sales_data sum = lhs;</span><br><span class="line">        sum.combine(rhs);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">get_units</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_somethings</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="title">Sales_data::get_units</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> units_sold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sales_data::do_somethings</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    assess_ctr++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.avg_price();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//CXX_EXE_SALES_DATA_HH</span></span></span><br></pre></td></tr></table></figure>
<p><code>Sales_data.cc</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/10/7.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/10/7 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Sales_data.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (units_sold) <span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;rhs)</span> </span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sales_data::Sales_data(istream &amp;is) &#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>X.cc</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/10/8.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/10/8 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;X.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">X::get_id</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>X.hh</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/10/8.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/10/8 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CXX_EXE_X_HH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CXX_EXE_X_HH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">helloX</span><span class="params">(<span class="keyword">const</span> X &amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello World!&quot;</span> &lt;&lt; x.id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_id</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//CXX_EXE_X_HH</span></span></span><br></pre></td></tr></table></figure>
<p><code>CMakeLists.txt</code>:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(CXX_Exe)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cc</span><br><span class="line">        Sales_data.cc Sales_data.hh</span><br><span class="line">        Screen.hh Screen.cc</span><br><span class="line">        Windows_Mgr.hh Windows_Mgr.cc</span><br><span class="line">        X.hh X.cc</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Hexo</title>
    <url>/2020/08/29/%E9%85%8D%E7%BD%AEHexo/</url>
    <content><![CDATA[<p><strong>配置文件 <code>_config.yml</code></strong></p>
<p>在 <code>Hexo</code> 的安装目录下， 有一个文件 <code>_config.yml</code> （以后称为 <strong>Hexo 配置文件</strong> ，在该文件中，可以对以以下内容进行配置。</p>
<a id="more"></a>
<h2 id="1-站点信息"><a href="#1-站点信息" class="headerlink" title="1. 站点信息"></a>1. 站点信息</h2><p>在这个配置中，可以对站点的基本信息进行修改。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">CHerrY</span> <span class="comment"># 站点标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;门前大桥下，C#C++，快来快来数一数，Java煮青蛙~&#x27;</span>  <span class="comment"># 子标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;算法分析，基础架构&#x27;</span> <span class="comment"># 站点描述，用来展示给访客的</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&#x27;算法分析分享，技术博客，LeetCode，个人博客&#x27;</span>  <span class="comment"># 给搜索引擎用的</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">CHerrY</span>  <span class="comment"># 作者信息，博客中的作者默认署名</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment"># 语言信息，Hexo支持多种语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span>    <span class="comment"># 时区配置，默认使用计算机的当地时间</span></span><br></pre></td></tr></table></figure>
<h2 id="2-URL-配置"><a href="#2-URL-配置" class="headerlink" title="2. URL 配置"></a>2. <code>URL</code> 配置</h2><p>该配置将会影响到博客内 <strong>图片</strong> 的访问、外链等信息。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://hxz1998.github.io/</span> <span class="comment"># 站点域名，如果有的话可以设置自己的域名</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span>                         <span class="comment"># 配置根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>  <span class="comment"># URL 组成格式</span></span><br></pre></td></tr></table></figure>
<h2 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3. 扩展"></a>3. 扩展</h2><p>对 <code>Hexo</code> 进行扩展所用到的配置，每一个插件需要去查看插件自己的说明文档。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插件扩展到： https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment"># 主题扩展到： https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span> <span class="comment"># 设置主题为 next</span></span><br></pre></td></tr></table></figure>
<h2 id="4-部署分发"><a href="#4-部署分发" class="headerlink" title="4. 部署分发"></a>4. 部署分发</h2><p>将博客部署到哪里，就配置这里~</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span> <span class="comment"># 部署服务类型，在这里我使用的是 Github 和 Gitee，因此选 git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># 仓库名称“们”，之所以使用“们”，是因为可以同步多个git仓库</span></span><br><span class="line">    <span class="attr">gitee:</span> <span class="string">https://gitee.com/hxz1998/hxz1998.git</span>  </span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://github.com/hxz1998/hxz1998.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h2 id="5-字数统计，阅读时长（可选）"><a href="#5-字数统计，阅读时长（可选）" class="headerlink" title="5. 字数统计，阅读时长（可选）"></a>5. 字数统计，阅读时长（可选）</h2><p><strong>下面内容在Hexo配置文件中并不存在，别害怕，自己添加就完事儿了。</strong> 这里主要对博客的一些额外的功能进行配置，需要结合 <code>hexo-symbols-count-time</code> 插件进行使用。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>     <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure>
<h3 id="5-1-hexo-symbols-count-time-安装"><a href="#5-1-hexo-symbols-count-time-安装" class="headerlink" title="5.1 hexo-symbols-count-time 安装"></a>5.1 <code>hexo-symbols-count-time</code> 安装</h3><p>打开心心念念的命令行终端，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time	<span class="comment"># 过程很快，没有多大</span></span><br></pre></td></tr></table></figure>
<p>等待安装完成，<strong>重新生成</strong> 、启动 <code>Hexo</code> 即可查看效果。</p>
<h3 id="5-2-配置-NexT-中的内容"><a href="#5-2-配置-NexT-中的内容" class="headerlink" title="5.2 配置 NexT 中的内容"></a>5.2 配置 <code>NexT</code> 中的内容</h3><p>将 <code>symbol_count_time</code> 启用：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>   <span class="comment"># 分隔的元数据</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>   <span class="comment"># 文章字数 </span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span> <span class="comment"># 总字数</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>                 <span class="comment"># 平均字长（字符以字为单位）</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>               <span class="comment"># 每分钟字数</span></span><br></pre></td></tr></table></figure>
<p>上面的数字都可以修改，当然，还可以参考来自 <a href="https://github.com/theme-next/hexo-symbols-count-time">官方</a> 指导：</p>
<blockquote>
<p><strong>注意对于中国用户：</strong>因为在有关中国语文平均字长<code>~1.5</code>，如果你在大多数情况下，写中国的职位（不含混合英文），建议设置<code>awl</code>到<code>2</code>和<code>wpm</code>到<code>300</code>。<br>但是，如果您通常将自己的帖子与英语混在一起，则<code>awl</code>to <code>4</code>和<code>wpm</code>to <code>275</code>会很好。</p>
</blockquote>
<h2 id="6-搜索（可选）"><a href="#6-搜索（可选）" class="headerlink" title="6. 搜索（可选）"></a>6. 搜索（可选）</h2><p>同样的，这是一个在 <strong>Hexo配置文件中并不存在的内容，需要额外添加。</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span> </span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span>  <span class="comment"># 将搜索索引放到哪里</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span>       <span class="comment"># 搜索字段</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span>     <span class="comment"># 是否检索内容</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span>      <span class="comment"># 生成格式</span></span><br></pre></td></tr></table></figure>
<p> 配置完之后，仍然需要额外配置 <code>NexT</code> 主题的配置文件 <code>next\_config.xml</code> 才可以生效。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span>	</span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>	</span><br></pre></td></tr></table></figure>
<h3 id="6-1-hexo-generator-searchdb-安装"><a href="#6-1-hexo-generator-searchdb-安装" class="headerlink" title="6.1 hexo-generator-searchdb 安装"></a>6.1 <code>hexo-generator-searchdb</code> 安装</h3><p>继续使用上面心心念念的终端，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>等待安装完成，<strong>重新生成</strong> 、再次启动 <code>Hexo</code> 即可查看效果。</p>
<h2 id="7-标签云"><a href="#7-标签云" class="headerlink" title="7. 标签云"></a>7. 标签云</h2><p>首先要建立存放标签的页面，打开喜欢用的命令行终端，并输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>然后就可以在 <code>Hexo_home\source\</code> 文件夹下看到有 <code>tags\index.md</code> 文件，对该文件进行修改成如下内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 标签云              # 展示标题</span><br><span class="line">date: 2020-08-27 23:03:38 # 创建时间，一般不需要改</span><br><span class="line">type: &quot;tags&quot;              # <span class="xml"><span class="tag">&lt;<span class="name">---</span> 这个才是添加的重点！</span></span></span><br></pre></td></tr></table></figure>
<p>然后刷新就可以在主页面菜单中看到 <strong>标签</strong> 这一栏了。</p>
<h2 id="8-分类"><a href="#8-分类" class="headerlink" title="8. 分类"></a>8. 分类</h2><p>对于分类页面的建立，和上面 <strong>第七条</strong> 一样。</p>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>ZUC算法了解</title>
    <url>/2020/09/22/ZUC%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>ZUC算法是一个<strong>面向字的流加密</strong>算法。它使用一个<strong>128</strong>位的初始密钥 <code>key</code> 和一个<strong>128</strong>位的初始向量 <code>iv</code> 来作为输入，可以输出若干个<strong>32</strong>位字的密钥流，也就就是说每<strong>32</strong>位字在这里称为一个密钥字。这样产生的密钥流可以用于加密和解密。</p>
<a id="more"></a>
<blockquote>
<p>  以下内容参考自 ZUC 标准文档</p>
</blockquote>
<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在ZUC算法中，有两个执行阶段，分别是<strong>初始化阶段</strong>和<strong>工作阶段</strong>。在初始化阶段中， <code>key</code> 和 <code>iv</code> 被初始化完成。在工作阶段中，每个<strong>时钟脉冲</strong>都能产生一个<strong>32位字</strong>的密钥流输出。</p>
<h1 id="2-符号与约定"><a href="#2-符号与约定" class="headerlink" title="2. 符号与约定"></a>2. 符号与约定</h1><h2 id="2-1-数制表示"><a href="#2-1-数制表示" class="headerlink" title="2.1 数制表示"></a>2.1 数制表示</h2><p>下文使用<strong>十进制</strong>、<strong>十六进制</strong>、<strong>二进制</strong>进行表示例如：</p>
<script type="math/tex; mode=display">
\begin{align*}
a &= 123456 \space\space\space\space十进制表示法\\\\ 
&= 0x1E240\space\space\space\space 十六进制表示\\\\
&= 00011110001001000000_2 二进制表示
\end{align*}</script><h2 id="2-2-比特序"><a href="#2-2-比特序" class="headerlink" title="2.2 比特序"></a>2.2 比特序</h2><p>在下文中，所有数据变量的左侧是高有效位（字节），右侧为低有效位（字节）。例如：$a = 100110101100110010100100_2$，那么它的最高有效位是$1$（最左侧的），最低有效位是$0$（最右侧的）。</p>
<h2 id="2-3-符号约定"><a href="#2-3-符号约定" class="headerlink" title="2.3 符号约定"></a>2.3 符号约定</h2><script type="math/tex; mode=display">
\begin{align*}
+ &| 两个整数相加\\\\
ab &| 两个整数相乘 \\\\
= &| 赋值\\\\
mod &| 模二加\\\\
\oplus &| 异或运算\\\\
\boxplus &| 模 2^32 加法运算\\\\
a||b &| 将字符串 a 和 b 串联 \\\\
a_H &| a 的高**16**为\\\\
a_L &| a 的低**16**位\\\\
a <<<_n k &| 循环左移\\\\
a>>1 &| 右移\\\\
(a_1, a_2, ..., a_n,)\to(b_1, b_2, ... b_n) &| 将向量 a_i 挨个赋值给 b_i\\\\
\end{align*}</script><h1 id="3-算法描述"><a href="#3-算法描述" class="headerlink" title="3. 算法描述"></a>3. 算法描述</h1><h2 id="3-1-算法结构"><a href="#3-1-算法结构" class="headerlink" title="3.1 算法结构"></a>3.1 算法结构</h2><p>如下图所示，<code>ZUC</code> 算法有三层结构，第一层是一个16级线性反馈移位寄存器（LSFR，linear feedback shift register）。中间是一个比特重组层（BR，bit-reorganization）。最下层是一个非线性函数$F$。</p>
<p><img data-src="https://s1.ax1x.com/2020/09/22/wOM9TU.jpg" alt="ZUC算法结构"></p>
<h2 id="3-2-线性反馈移位寄存器（LSFR）"><a href="#3-2-线性反馈移位寄存器（LSFR）" class="headerlink" title="3.2 线性反馈移位寄存器（LSFR）"></a>3.2 线性反馈移位寄存器（LSFR）</h2><p>线性反馈移位寄存器（LSFR）有<strong>16</strong>个<strong>31</strong>比特的单元（$s_0, s_1, … , s_{15}, s_i\in {1, 2, 3, … , 2^{31}-1}$），它的运行有两种模式：初始化模式和工作模式。</p>
<p>在<strong>初始化阶段</strong>，LFSR读入一个<strong>31</strong>位的输入字 <code>u</code> ，它通过从非线性函数 <code>F</code> 的<strong>32</strong>位输出 <code>W</code> 中删除最右边的位来获得，例如：<code>u = W &gt;&gt; 1</code>，具体的工作方式如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
& \space LSFRWithInitializationMode(u): \\\\
& 1. \qquad v = 2^{15}s_{15}+2^{17}s_{13}+2^{21}s_{10}+2^{20}s_{4}+(1 + 2^8)s_0\space mod(2^{31}-1) \\\\
& 2. \qquad s_{16} = (v + u)\space mod(2^{31} - 1) \\\\
& 3. \qquad if s_{16}=0, then\space set\space s_{16}=2^{31} - 1 \\\\
& 4. \qquad(s_1, s_2, ... s_{16})\to(s_0, s_1, ... , s_{15})\\\\
\end{align*}</script><p>在<strong>工作阶段</strong>，LSFR不会接收任何输入，并且按照下面方式工作：</p>
<script type="math/tex; mode=display">
\begin{align*}
&LFSRWithWorkMode() \\\\
&1. \qquad s_{16} = 2^{15}s_{15}+2^{17}s_{13}+2^{21}s_{10}+2^{20}s_{4}+(1+2^8)s_0\space mod(2^{31} - 1)\\\\
&2. \qquad if\space s_{16}=0,\space then \space set \space s_{16}=2^{31} - 1\\\\
&3. \qquad(s_1, s_2, ... s_{16})\to(s_0, s_1, ... , s_{15})\\\\
\end{align*}</script><p><strong>Tips：</strong>在 <code>LFSRWithInitializationMode</code> 函数中的 Step.1 ，可以使用如下操作来实现：</p>
<script type="math/tex; mode=display">
v=(s_{15}<<<_{31}15)+(s_{13}<<<_{31}17)+(s_{10}<<<_{31}21)+(s_{4}<<<_{31}20)+(s_{0}<<<_{31}8)+s_{0}\space mod(2^{31}-1)</script><p>当然，可以类比着对 <code>LFSRWithWordMode()</code> 中的 Step.1 进行实现。</p>
<h2 id="3-3-比特重组（BR）"><a href="#3-3-比特重组（BR）" class="headerlink" title="3.3 比特重组（BR）"></a>3.3 比特重组（BR）</h2><p>中间层是一个比特重组算法。它从<strong>LFSR</strong>中提取出来 <code>128</code> 比特，然后组成 <code>4</code> 个 <code>32</code> 位的字，前三个字是提供给底层非线性 <code>F</code> 函数使用的，最后一个字用来生成密钥流。重组后的 $X_0, X_1, X_2, X_3$，如下所示：</p>
<script type="math/tex; mode=display">
\begin{align*}
&Bitreorganization() \\\\
&1. \qquad X_0 = s_{15H}||s_{14L}\\\\
&2. \qquad X_1 = s_{11L}||s_{9H}\\\\
&3. \qquad X_2 = s_{7L}||s_{5H}\\\\
&4. \qquad X_3 = s_{2L}||s_{0H}
\end{align*}</script><p>注意：这里的 $s_i$ 是 <code>31</code> 比特的整数类型，所以 $s_{iH}$ 表示的是 $s_i$ 的 <code>30...15</code> 位而不是 <code>31...16</code> 位。</p>
<h2 id="3-4-非线性函数-F"><a href="#3-4-非线性函数-F" class="headerlink" title="3.4 非线性函数 F"></a>3.4 非线性函数 F</h2><p>非线性函数 <code>F</code> 有两个 <code>32</code> 比特的记忆单元 $R_1$ 和 $R_2$，输入为 <code>3</code> 个 <code>32</code> 比特的字：$X_0, X_1, X_2$，输出一个 <code>32</code> 比特的字 <code>W</code>。具体描述如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
&F(X_0, X_1, X_2) \\\\
&1. \qquad W = (X_0\oplus R_1)\boxplus R_2 \\\\
&2. \qquad W_1 = (R_1\boxplus X_1) \\\\
&3. \qquad W_2 = (R_2\oplus X_2) \\\\
&4. \qquad R_1 = S(L_1(W_{1L}||W_{2H})) \\\\
&5. \qquad R_2 = S(L_2(W_{2L}||W_{1H}))
\end{align*}</script><p>这里的 <code>S</code> 是一个 <code>32*32</code> 大小的 <code>S-Box</code>，而 $L_1$，$L_2$ 是线性变换。</p>
<h3 id="3-4-1-S-Box"><a href="#3-4-1-S-Box" class="headerlink" title="3.4.1 S-Box"></a>3.4.1 S-Box</h3><p><code>32*32</code>大小的 <code>S-Box</code>（<code>S</code>），其实是四个大小为 <code>8*8</code>的 <code>S-boxes</code> 并置而成，例如：$S=(S_0, S_1, S_2, S_3)$，这里的 $S_0 = S_2,S_1 = S_3$。那么 $S_0$ 和 $S_1$ 具体内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> S0[<span class="number">256</span>] = &#123;</span><br><span class="line">    <span class="number">0x3e</span>,<span class="number">0x72</span>,<span class="number">0x5b</span>,<span class="number">0x47</span>,<span class="number">0xca</span>,<span class="number">0xe0</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x04</span>,<span class="number">0xd1</span>,<span class="number">0x54</span>,<span class="number">0x98</span>,<span class="number">0x09</span>,<span class="number">0xb9</span>,<span class="number">0x6d</span>,<span class="number">0xcb</span>,</span><br><span class="line">    <span class="number">0x7b</span>,<span class="number">0x1b</span>,<span class="number">0xf9</span>,<span class="number">0x32</span>,<span class="number">0xaf</span>,<span class="number">0x9d</span>,<span class="number">0x6a</span>,<span class="number">0xa5</span>,<span class="number">0xb8</span>,<span class="number">0x2d</span>,<span class="number">0xfc</span>,<span class="number">0x1d</span>,<span class="number">0x08</span>,<span class="number">0x53</span>,<span class="number">0x03</span>,<span class="number">0x90</span>,</span><br><span class="line">    <span class="number">0x4d</span>,<span class="number">0x4e</span>,<span class="number">0x84</span>,<span class="number">0x99</span>,<span class="number">0xe4</span>,<span class="number">0xce</span>,<span class="number">0xd9</span>,<span class="number">0x91</span>,<span class="number">0xdd</span>,<span class="number">0xb6</span>,<span class="number">0x85</span>,<span class="number">0x48</span>,<span class="number">0x8b</span>,<span class="number">0x29</span>,<span class="number">0x6e</span>,<span class="number">0xac</span>,</span><br><span class="line">    <span class="number">0xcd</span>,<span class="number">0xc1</span>,<span class="number">0xf8</span>,<span class="number">0x1e</span>,<span class="number">0x73</span>,<span class="number">0x43</span>,<span class="number">0x69</span>,<span class="number">0xc6</span>,<span class="number">0xb5</span>,<span class="number">0xbd</span>,<span class="number">0xfd</span>,<span class="number">0x39</span>,<span class="number">0x63</span>,<span class="number">0x20</span>,<span class="number">0xd4</span>,<span class="number">0x38</span>,</span><br><span class="line">    <span class="number">0x76</span>,<span class="number">0x7d</span>,<span class="number">0xb2</span>,<span class="number">0xa7</span>,<span class="number">0xcf</span>,<span class="number">0xed</span>,<span class="number">0x57</span>,<span class="number">0xc5</span>,<span class="number">0xf3</span>,<span class="number">0x2c</span>,<span class="number">0xbb</span>,<span class="number">0x14</span>,<span class="number">0x21</span>,<span class="number">0x06</span>,<span class="number">0x55</span>,<span class="number">0x9b</span>,</span><br><span class="line">    <span class="number">0xe3</span>,<span class="number">0xef</span>,<span class="number">0x5e</span>,<span class="number">0x31</span>,<span class="number">0x4f</span>,<span class="number">0x7f</span>,<span class="number">0x5a</span>,<span class="number">0xa4</span>,<span class="number">0x0d</span>,<span class="number">0x82</span>,<span class="number">0x51</span>,<span class="number">0x49</span>,<span class="number">0x5f</span>,<span class="number">0xba</span>,<span class="number">0x58</span>,<span class="number">0x1c</span>,</span><br><span class="line">    <span class="number">0x4a</span>,<span class="number">0x16</span>,<span class="number">0xd5</span>,<span class="number">0x17</span>,<span class="number">0xa8</span>,<span class="number">0x92</span>,<span class="number">0x24</span>,<span class="number">0x1f</span>,<span class="number">0x8c</span>,<span class="number">0xff</span>,<span class="number">0xd8</span>,<span class="number">0xae</span>,<span class="number">0x2e</span>,<span class="number">0x01</span>,<span class="number">0xd3</span>,<span class="number">0xad</span>,</span><br><span class="line">    <span class="number">0x3b</span>,<span class="number">0x4b</span>,<span class="number">0xda</span>,<span class="number">0x46</span>,<span class="number">0xeb</span>,<span class="number">0xc9</span>,<span class="number">0xde</span>,<span class="number">0x9a</span>,<span class="number">0x8f</span>,<span class="number">0x87</span>,<span class="number">0xd7</span>,<span class="number">0x3a</span>,<span class="number">0x80</span>,<span class="number">0x6f</span>,<span class="number">0x2f</span>,<span class="number">0xc8</span>,</span><br><span class="line">    <span class="number">0xb1</span>,<span class="number">0xb4</span>,<span class="number">0x37</span>,<span class="number">0xf7</span>,<span class="number">0x0a</span>,<span class="number">0x22</span>,<span class="number">0x13</span>,<span class="number">0x28</span>,<span class="number">0x7c</span>,<span class="number">0xcc</span>,<span class="number">0x3c</span>,<span class="number">0x89</span>,<span class="number">0xc7</span>,<span class="number">0xc3</span>,<span class="number">0x96</span>,<span class="number">0x56</span>,</span><br><span class="line">    <span class="number">0x07</span>,<span class="number">0xbf</span>,<span class="number">0x7e</span>,<span class="number">0xf0</span>,<span class="number">0x0b</span>,<span class="number">0x2b</span>,<span class="number">0x97</span>,<span class="number">0x52</span>,<span class="number">0x35</span>,<span class="number">0x41</span>,<span class="number">0x79</span>,<span class="number">0x61</span>,<span class="number">0xa6</span>,<span class="number">0x4c</span>,<span class="number">0x10</span>,<span class="number">0xfe</span>,</span><br><span class="line">    <span class="number">0xbc</span>,<span class="number">0x26</span>,<span class="number">0x95</span>,<span class="number">0x88</span>,<span class="number">0x8a</span>,<span class="number">0xb0</span>,<span class="number">0xa3</span>,<span class="number">0xfb</span>,<span class="number">0xc0</span>,<span class="number">0x18</span>,<span class="number">0x94</span>,<span class="number">0xf2</span>,<span class="number">0xe1</span>,<span class="number">0xe5</span>,<span class="number">0xe9</span>,<span class="number">0x5d</span>,</span><br><span class="line">    <span class="number">0xd0</span>,<span class="number">0xdc</span>,<span class="number">0x11</span>,<span class="number">0x66</span>,<span class="number">0x64</span>,<span class="number">0x5c</span>,<span class="number">0xec</span>,<span class="number">0x59</span>,<span class="number">0x42</span>,<span class="number">0x75</span>,<span class="number">0x12</span>,<span class="number">0xf5</span>,<span class="number">0x74</span>,<span class="number">0x9c</span>,<span class="number">0xaa</span>,<span class="number">0x23</span>,</span><br><span class="line">    <span class="number">0x0e</span>,<span class="number">0x86</span>,<span class="number">0xab</span>,<span class="number">0xbe</span>,<span class="number">0x2a</span>,<span class="number">0x02</span>,<span class="number">0xe7</span>,<span class="number">0x67</span>,<span class="number">0xe6</span>,<span class="number">0x44</span>,<span class="number">0xa2</span>,<span class="number">0x6c</span>,<span class="number">0xc2</span>,<span class="number">0x93</span>,<span class="number">0x9f</span>,<span class="number">0xf1</span>,</span><br><span class="line">    <span class="number">0xf6</span>,<span class="number">0xfa</span>,<span class="number">0x36</span>,<span class="number">0xd2</span>,<span class="number">0x50</span>,<span class="number">0x68</span>,<span class="number">0x9e</span>,<span class="number">0x62</span>,<span class="number">0x71</span>,<span class="number">0x15</span>,<span class="number">0x3d</span>,<span class="number">0xd6</span>,<span class="number">0x40</span>,<span class="number">0xc4</span>,<span class="number">0xe2</span>,<span class="number">0x0f</span>,</span><br><span class="line">    <span class="number">0x8e</span>,<span class="number">0x83</span>,<span class="number">0x77</span>,<span class="number">0x6b</span>,<span class="number">0x25</span>,<span class="number">0x05</span>,<span class="number">0x3f</span>,<span class="number">0x0c</span>,<span class="number">0x30</span>,<span class="number">0xea</span>,<span class="number">0x70</span>,<span class="number">0xb7</span>,<span class="number">0xa1</span>,<span class="number">0xe8</span>,<span class="number">0xa9</span>,<span class="number">0x65</span>,</span><br><span class="line">    <span class="number">0x8d</span>,<span class="number">0x27</span>,<span class="number">0x1a</span>,<span class="number">0xdb</span>,<span class="number">0x81</span>,<span class="number">0xb3</span>,<span class="number">0xa0</span>,<span class="number">0xf4</span>,<span class="number">0x45</span>,<span class="number">0x7a</span>,<span class="number">0x19</span>,<span class="number">0xdf</span>,<span class="number">0xee</span>,<span class="number">0x78</span>,<span class="number">0x34</span>,<span class="number">0x60</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> S1[<span class="number">256</span>] = &#123;</span><br><span class="line">    <span class="number">0x55</span>,<span class="number">0xc2</span>,<span class="number">0x63</span>,<span class="number">0x71</span>,<span class="number">0x3b</span>,<span class="number">0xc8</span>,<span class="number">0x47</span>,<span class="number">0x86</span>,<span class="number">0x9f</span>,<span class="number">0x3c</span>,<span class="number">0xda</span>,<span class="number">0x5b</span>,<span class="number">0x29</span>,<span class="number">0xaa</span>,<span class="number">0xfd</span>,<span class="number">0x77</span>,</span><br><span class="line">    <span class="number">0x8c</span>,<span class="number">0xc5</span>,<span class="number">0x94</span>,<span class="number">0x0c</span>,<span class="number">0xa6</span>,<span class="number">0x1a</span>,<span class="number">0x13</span>,<span class="number">0x00</span>,<span class="number">0xe3</span>,<span class="number">0xa8</span>,<span class="number">0x16</span>,<span class="number">0x72</span>,<span class="number">0x40</span>,<span class="number">0xf9</span>,<span class="number">0xf8</span>,<span class="number">0x42</span>,</span><br><span class="line">    <span class="number">0x44</span>,<span class="number">0x26</span>,<span class="number">0x68</span>,<span class="number">0x96</span>,<span class="number">0x81</span>,<span class="number">0xd9</span>,<span class="number">0x45</span>,<span class="number">0x3e</span>,<span class="number">0x10</span>,<span class="number">0x76</span>,<span class="number">0xc6</span>,<span class="number">0xa7</span>,<span class="number">0x8b</span>,<span class="number">0x39</span>,<span class="number">0x43</span>,<span class="number">0xe1</span>,</span><br><span class="line">    <span class="number">0x3a</span>,<span class="number">0xb5</span>,<span class="number">0x56</span>,<span class="number">0x2a</span>,<span class="number">0xc0</span>,<span class="number">0x6d</span>,<span class="number">0xb3</span>,<span class="number">0x05</span>,<span class="number">0x22</span>,<span class="number">0x66</span>,<span class="number">0xbf</span>,<span class="number">0xdc</span>,<span class="number">0x0b</span>,<span class="number">0xfa</span>,<span class="number">0x62</span>,<span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0xdd</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x06</span>,<span class="number">0x36</span>,<span class="number">0xc9</span>,<span class="number">0xc1</span>,<span class="number">0xcf</span>,<span class="number">0xf6</span>,<span class="number">0x27</span>,<span class="number">0x52</span>,<span class="number">0xbb</span>,<span class="number">0x69</span>,<span class="number">0xf5</span>,<span class="number">0xd4</span>,<span class="number">0x87</span>,</span><br><span class="line">    <span class="number">0x7f</span>,<span class="number">0x84</span>,<span class="number">0x4c</span>,<span class="number">0xd2</span>,<span class="number">0x9c</span>,<span class="number">0x57</span>,<span class="number">0xa4</span>,<span class="number">0xbc</span>,<span class="number">0x4f</span>,<span class="number">0x9a</span>,<span class="number">0xdf</span>,<span class="number">0xfe</span>,<span class="number">0xd6</span>,<span class="number">0x8d</span>,<span class="number">0x7a</span>,<span class="number">0xeb</span>,</span><br><span class="line">    <span class="number">0x2b</span>,<span class="number">0x53</span>,<span class="number">0xd8</span>,<span class="number">0x5c</span>,<span class="number">0xa1</span>,<span class="number">0x14</span>,<span class="number">0x17</span>,<span class="number">0xfb</span>,<span class="number">0x23</span>,<span class="number">0xd5</span>,<span class="number">0x7d</span>,<span class="number">0x30</span>,<span class="number">0x67</span>,<span class="number">0x73</span>,<span class="number">0x08</span>,<span class="number">0x09</span>,</span><br><span class="line">    <span class="number">0xee</span>,<span class="number">0xb7</span>,<span class="number">0x70</span>,<span class="number">0x3f</span>,<span class="number">0x61</span>,<span class="number">0xb2</span>,<span class="number">0x19</span>,<span class="number">0x8e</span>,<span class="number">0x4e</span>,<span class="number">0xe5</span>,<span class="number">0x4b</span>,<span class="number">0x93</span>,<span class="number">0x8f</span>,<span class="number">0x5d</span>,<span class="number">0xdb</span>,<span class="number">0xa9</span>,</span><br><span class="line">    <span class="number">0xad</span>,<span class="number">0xf1</span>,<span class="number">0xae</span>,<span class="number">0x2e</span>,<span class="number">0xcb</span>,<span class="number">0x0d</span>,<span class="number">0xfc</span>,<span class="number">0xf4</span>,<span class="number">0x2d</span>,<span class="number">0x46</span>,<span class="number">0x6e</span>,<span class="number">0x1d</span>,<span class="number">0x97</span>,<span class="number">0xe8</span>,<span class="number">0xd1</span>,<span class="number">0xe9</span>,</span><br><span class="line">    <span class="number">0x4d</span>,<span class="number">0x37</span>,<span class="number">0xa5</span>,<span class="number">0x75</span>,<span class="number">0x5e</span>,<span class="number">0x83</span>,<span class="number">0x9e</span>,<span class="number">0xab</span>,<span class="number">0x82</span>,<span class="number">0x9d</span>,<span class="number">0xb9</span>,<span class="number">0x1c</span>,<span class="number">0xe0</span>,<span class="number">0xcd</span>,<span class="number">0x49</span>,<span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0x01</span>,<span class="number">0xb6</span>,<span class="number">0xbd</span>,<span class="number">0x58</span>,<span class="number">0x24</span>,<span class="number">0xa2</span>,<span class="number">0x5f</span>,<span class="number">0x38</span>,<span class="number">0x78</span>,<span class="number">0x99</span>,<span class="number">0x15</span>,<span class="number">0x90</span>,<span class="number">0x50</span>,<span class="number">0xb8</span>,<span class="number">0x95</span>,<span class="number">0xe4</span>,</span><br><span class="line">    <span class="number">0xd0</span>,<span class="number">0x91</span>,<span class="number">0xc7</span>,<span class="number">0xce</span>,<span class="number">0xed</span>,<span class="number">0x0f</span>,<span class="number">0xb4</span>,<span class="number">0x6f</span>,<span class="number">0xa0</span>,<span class="number">0xcc</span>,<span class="number">0xf0</span>,<span class="number">0x02</span>,<span class="number">0x4a</span>,<span class="number">0x79</span>,<span class="number">0xc3</span>,<span class="number">0xde</span>,</span><br><span class="line">    <span class="number">0xa3</span>,<span class="number">0xef</span>,<span class="number">0xea</span>,<span class="number">0x51</span>,<span class="number">0xe6</span>,<span class="number">0x6b</span>,<span class="number">0x18</span>,<span class="number">0xec</span>,<span class="number">0x1b</span>,<span class="number">0x2c</span>,<span class="number">0x80</span>,<span class="number">0xf7</span>,<span class="number">0x74</span>,<span class="number">0xe7</span>,<span class="number">0xff</span>,<span class="number">0x21</span>,</span><br><span class="line">    <span class="number">0x5a</span>,<span class="number">0x6a</span>,<span class="number">0x54</span>,<span class="number">0x1e</span>,<span class="number">0x41</span>,<span class="number">0x31</span>,<span class="number">0x92</span>,<span class="number">0x35</span>,<span class="number">0xc4</span>,<span class="number">0x33</span>,<span class="number">0x07</span>,<span class="number">0x0a</span>,<span class="number">0xba</span>,<span class="number">0x7e</span>,<span class="number">0x0e</span>,<span class="number">0x34</span>,</span><br><span class="line">    <span class="number">0x88</span>,<span class="number">0xb1</span>,<span class="number">0x98</span>,<span class="number">0x7c</span>,<span class="number">0xf3</span>,<span class="number">0x3d</span>,<span class="number">0x60</span>,<span class="number">0x6c</span>,<span class="number">0x7b</span>,<span class="number">0xca</span>,<span class="number">0xd3</span>,<span class="number">0x1f</span>,<span class="number">0x32</span>,<span class="number">0x65</span>,<span class="number">0x04</span>,<span class="number">0x28</span>,</span><br><span class="line">    <span class="number">0x64</span>,<span class="number">0xbe</span>,<span class="number">0x85</span>,<span class="number">0x9b</span>,<span class="number">0x2f</span>,<span class="number">0x59</span>,<span class="number">0x8a</span>,<span class="number">0xd7</span>,<span class="number">0xb0</span>,<span class="number">0x25</span>,<span class="number">0xac</span>,<span class="number">0xaf</span>,<span class="number">0x12</span>,<span class="number">0x03</span>,<span class="number">0xe2</span>,<span class="number">0xf2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-2-线性变换"><a href="#3-4-2-线性变换" class="headerlink" title="3.4.2 线性变换"></a>3.4.2 线性变换</h3><p>对于 $L_1$ 和 $L_2$ 线性变换而言，都是将 <code>32</code> 位的字转换成另一个 <code>32</code> 位的字，具体转换如下：</p>
<script type="math/tex; mode=display">
L_1(X)=X\oplus (X<<<_{32}2)\oplus (X<<<_{32}10)\oplus (X<<<_{32}18) \oplus(X<<<_{32}24)\\\\
L_2(X)=X\oplus (X<<<_{32}8)\oplus (X<<<_{32}14)\oplus (X<<<_{32}22) \oplus(X<<<_{32}30)</script><h2 id="3-5-密钥装入"><a href="#3-5-密钥装入" class="headerlink" title="3.5 密钥装入"></a>3.5 密钥装入</h2><p>密钥装入过程，将会把初始密钥 <code>k(128 bits)</code> 和 <code>iv(128 bits)</code> 扩展成 <code>16</code> 个 <code>31</code> 位整数，作为 <code>LFSR</code> 的初始状态。</p>
<p>装载过程如下：</p>
<script type="math/tex; mode=display">
k = k_0||k_1||k_2||...||k_{15}</script><p>和：</p>
<script type="math/tex; mode=display">
iv=iv_0||iv_1||...||iv_{15}</script><p>这里的 $k_i$ 和 $iv_i$ 均为 <code>8</code> 位的字节，然后构造 <code>D</code>， <code>D</code> 为 <code>240</code> 比特的常量，可以按照如下方式分成 <code>16</code> 个 <code>15</code> 位的子串：</p>
<script type="math/tex; mode=display">
\begin{align*}
d_0 = 100010011010111_2, \\\\
d_1 = 010011010111100_2,\\\\
d_2 = 110001001101011_2,\\\\
d_3 = 001001101011110_2,\\\\
d_4 = 101011110001001_2,\\\\
d_5 = 011010111100010_2,\\\\
d_6 = 111000100110101_2,\\\\
d_7 = 000100110101111_2,\\\\
d_8= 100110101111000_2,\\\\
d_9 = 010111100010011_2,\\\\
d_{10} = 110101111000100_2,\\\\
d_{11} = 001101011110001_2,\\\\
\end{align*}</script><p>那么 $D=d_0||d_1||…||d_{15}$。</p>
<p>对于 $s_i$，有：$s_i = k_i||d_i||iv_i$。</p>
<h1 id="3-6-ZUC算法执行过程"><a href="#3-6-ZUC算法执行过程" class="headerlink" title="3.6 ZUC算法执行过程"></a>3.6 ZUC算法执行过程</h1><p>两个阶段：初始化阶段和工作阶段。</p>
<h2 id="3-6-1-初始化阶段"><a href="#3-6-1-初始化阶段" class="headerlink" title="3.6.1 初始化阶段"></a>3.6.1 初始化阶段</h2><p>在初始化阶段，算法将 <code>128</code> 比特的 <code>key</code> 和 <code>iv</code> 载入并处理，然后装入到 <code>LFSR</code> 中，与此同时，设置 <code>32</code> 比特的记忆单元 $R_1$ 和 $R_2$（初始化为 <code>0</code>）。然后执行下面的操作 <code>31</code> 次。</p>
<script type="math/tex; mode=display">
\begin{align*}
&1. \qquad Bitreorganization()\\\\
&2. \qquad w=F(X_0,X_1,X_2)\\\\
&3. \qquad LFSRWithInitializationMode(w>>1)\\\\
\end{align*}</script><h3 id="3-6-2-工作阶段"><a href="#3-6-2-工作阶段" class="headerlink" title="3.6.2 工作阶段"></a>3.6.2 工作阶段</h3><p>初始化完成后，算法立刻进入工作阶段。在该阶段，算法执行下面操作一次，并且丢掉 <code>F</code> 的输出 <code>W</code>：</p>
<script type="math/tex; mode=display">
\begin{align*}
&1. \qquad Bitreorganization()\\\\
&2. \qquad F(X_0,X_1,X_2) \\\\
&3. \qquad LFSRWithWorkMode()\\\\
\end{align*}</script><p>然后算法再进入密钥流产生阶段，在每次迭代时，下面操作执行一次，并输出一次 <code>32</code> 比特的字 <code>Z</code> 作为输出。</p>
<script type="math/tex; mode=display">
\begin{align*}
&1. \qquad Bitreorganization()\\\\
&2. \qquad Z=F(X_0,X_1,X_2)\oplus X_3 \\\\
&3. \qquad LFSRWithWorkMode()\\\\
\end{align*}</script><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="A-C语言实现"><a href="#A-C语言实现" class="headerlink" title="A. C语言实现"></a>A. C语言实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ZUC.h&quot;</span></span></span><br><span class="line"><span class="comment">/* ——————————————————————- */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u32;</span><br><span class="line"><span class="comment">/* ——————————————————————- */</span></span><br><span class="line"><span class="comment">/* the state registers of LFSR */</span></span><br><span class="line">u32 LFSR_S0;</span><br><span class="line">u32 LFSR_S1;</span><br><span class="line">u32 LFSR_S2;</span><br><span class="line">u32 LFSR_S3;</span><br><span class="line">u32 LFSR_S4;</span><br><span class="line">u32 LFSR_S5;</span><br><span class="line">u32 LFSR_S6;</span><br><span class="line">u32 LFSR_S7;</span><br><span class="line">u32 LFSR_S8;</span><br><span class="line">u32 LFSR_S9;</span><br><span class="line">u32 LFSR_S10;</span><br><span class="line">u32 LFSR_S11;</span><br><span class="line">u32 LFSR_S12;</span><br><span class="line">u32 LFSR_S13;</span><br><span class="line">u32 LFSR_S14;</span><br><span class="line">u32 LFSR_S15;</span><br><span class="line"><span class="comment">/* the registers of F */</span></span><br><span class="line">u32 F_R1;</span><br><span class="line">u32 F_R2;</span><br><span class="line"><span class="comment">/* the outputs of BitReorganization */</span></span><br><span class="line">u32 BRC_X0;</span><br><span class="line">u32 BRC_X1;</span><br><span class="line">u32 BRC_X2;</span><br><span class="line">u32 BRC_X3;</span><br><span class="line"><span class="comment">/* the s-boxes */</span></span><br><span class="line">u8 S0[<span class="number">256</span>] = &#123;</span><br><span class="line">        <span class="number">0x3e</span>, <span class="number">0x72</span>, <span class="number">0x5b</span>, <span class="number">0x47</span>, <span class="number">0xca</span>, <span class="number">0xe0</span>, <span class="number">0x00</span>, <span class="number">0x33</span>, <span class="number">0x04</span>, <span class="number">0xd1</span>, <span class="number">0x54</span>, <span class="number">0x98</span>, <span class="number">0x09</span>, <span class="number">0xb9</span>, <span class="number">0x6d</span>, <span class="number">0xcb</span>,</span><br><span class="line">        <span class="number">0x7b</span>, <span class="number">0x1b</span>, <span class="number">0xf9</span>, <span class="number">0x32</span>, <span class="number">0xaf</span>, <span class="number">0x9d</span>, <span class="number">0x6a</span>, <span class="number">0xa5</span>, <span class="number">0xb8</span>, <span class="number">0x2d</span>, <span class="number">0xfc</span>, <span class="number">0x1d</span>, <span class="number">0x08</span>, <span class="number">0x53</span>, <span class="number">0x03</span>, <span class="number">0x90</span>,</span><br><span class="line">        <span class="number">0x4d</span>, <span class="number">0x4e</span>, <span class="number">0x84</span>, <span class="number">0x99</span>, <span class="number">0xe4</span>, <span class="number">0xce</span>, <span class="number">0xd9</span>, <span class="number">0x91</span>, <span class="number">0xdd</span>, <span class="number">0xb6</span>, <span class="number">0x85</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x29</span>, <span class="number">0x6e</span>, <span class="number">0xac</span>,</span><br><span class="line">        <span class="number">0xcd</span>, <span class="number">0xc1</span>, <span class="number">0xf8</span>, <span class="number">0x1e</span>, <span class="number">0x73</span>, <span class="number">0x43</span>, <span class="number">0x69</span>, <span class="number">0xc6</span>, <span class="number">0xb5</span>, <span class="number">0xbd</span>, <span class="number">0xfd</span>, <span class="number">0x39</span>, <span class="number">0x63</span>, <span class="number">0x20</span>, <span class="number">0xd4</span>, <span class="number">0x38</span>,</span><br><span class="line">        <span class="number">0x76</span>, <span class="number">0x7d</span>, <span class="number">0xb2</span>, <span class="number">0xa7</span>, <span class="number">0xcf</span>, <span class="number">0xed</span>, <span class="number">0x57</span>, <span class="number">0xc5</span>, <span class="number">0xf3</span>, <span class="number">0x2c</span>, <span class="number">0xbb</span>, <span class="number">0x14</span>, <span class="number">0x21</span>, <span class="number">0x06</span>, <span class="number">0x55</span>, <span class="number">0x9b</span>,</span><br><span class="line">        <span class="number">0xe3</span>, <span class="number">0xef</span>, <span class="number">0x5e</span>, <span class="number">0x31</span>, <span class="number">0x4f</span>, <span class="number">0x7f</span>, <span class="number">0x5a</span>, <span class="number">0xa4</span>, <span class="number">0x0d</span>, <span class="number">0x82</span>, <span class="number">0x51</span>, <span class="number">0x49</span>, <span class="number">0x5f</span>, <span class="number">0xba</span>, <span class="number">0x58</span>, <span class="number">0x1c</span>,</span><br><span class="line">        <span class="number">0x4a</span>, <span class="number">0x16</span>, <span class="number">0xd5</span>, <span class="number">0x17</span>, <span class="number">0xa8</span>, <span class="number">0x92</span>, <span class="number">0x24</span>, <span class="number">0x1f</span>, <span class="number">0x8c</span>, <span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xae</span>, <span class="number">0x2e</span>, <span class="number">0x01</span>, <span class="number">0xd3</span>, <span class="number">0xad</span>,</span><br><span class="line">        <span class="number">0x3b</span>, <span class="number">0x4b</span>, <span class="number">0xda</span>, <span class="number">0x46</span>, <span class="number">0xeb</span>, <span class="number">0xc9</span>, <span class="number">0xde</span>, <span class="number">0x9a</span>, <span class="number">0x8f</span>, <span class="number">0x87</span>, <span class="number">0xd7</span>, <span class="number">0x3a</span>, <span class="number">0x80</span>, <span class="number">0x6f</span>, <span class="number">0x2f</span>, <span class="number">0xc8</span>,</span><br><span class="line">        <span class="number">0xb1</span>, <span class="number">0xb4</span>, <span class="number">0x37</span>, <span class="number">0xf7</span>, <span class="number">0x0a</span>, <span class="number">0x22</span>, <span class="number">0x13</span>, <span class="number">0x28</span>, <span class="number">0x7c</span>, <span class="number">0xcc</span>, <span class="number">0x3c</span>, <span class="number">0x89</span>, <span class="number">0xc7</span>, <span class="number">0xc3</span>, <span class="number">0x96</span>, <span class="number">0x56</span>,</span><br><span class="line">        <span class="number">0x07</span>, <span class="number">0xbf</span>, <span class="number">0x7e</span>, <span class="number">0xf0</span>, <span class="number">0x0b</span>, <span class="number">0x2b</span>, <span class="number">0x97</span>, <span class="number">0x52</span>, <span class="number">0x35</span>, <span class="number">0x41</span>, <span class="number">0x79</span>, <span class="number">0x61</span>, <span class="number">0xa6</span>, <span class="number">0x4c</span>, <span class="number">0x10</span>, <span class="number">0xfe</span>,</span><br><span class="line">        <span class="number">0xbc</span>, <span class="number">0x26</span>, <span class="number">0x95</span>, <span class="number">0x88</span>, <span class="number">0x8a</span>, <span class="number">0xb0</span>, <span class="number">0xa3</span>, <span class="number">0xfb</span>, <span class="number">0xc0</span>, <span class="number">0x18</span>, <span class="number">0x94</span>, <span class="number">0xf2</span>, <span class="number">0xe1</span>, <span class="number">0xe5</span>, <span class="number">0xe9</span>, <span class="number">0x5d</span>,</span><br><span class="line">        <span class="number">0xd0</span>, <span class="number">0xdc</span>, <span class="number">0x11</span>, <span class="number">0x66</span>, <span class="number">0x64</span>, <span class="number">0x5c</span>, <span class="number">0xec</span>, <span class="number">0x59</span>, <span class="number">0x42</span>, <span class="number">0x75</span>, <span class="number">0x12</span>, <span class="number">0xf5</span>, <span class="number">0x74</span>, <span class="number">0x9c</span>, <span class="number">0xaa</span>, <span class="number">0x23</span>,</span><br><span class="line">        <span class="number">0x0e</span>, <span class="number">0x86</span>, <span class="number">0xab</span>, <span class="number">0xbe</span>, <span class="number">0x2a</span>, <span class="number">0x02</span>, <span class="number">0xe7</span>, <span class="number">0x67</span>, <span class="number">0xe6</span>, <span class="number">0x44</span>, <span class="number">0xa2</span>, <span class="number">0x6c</span>, <span class="number">0xc2</span>, <span class="number">0x93</span>, <span class="number">0x9f</span>, <span class="number">0xf1</span>,</span><br><span class="line">        <span class="number">0xf6</span>, <span class="number">0xfa</span>, <span class="number">0x36</span>, <span class="number">0xd2</span>, <span class="number">0x50</span>, <span class="number">0x68</span>, <span class="number">0x9e</span>, <span class="number">0x62</span>, <span class="number">0x71</span>, <span class="number">0x15</span>, <span class="number">0x3d</span>, <span class="number">0xd6</span>, <span class="number">0x40</span>, <span class="number">0xc4</span>, <span class="number">0xe2</span>, <span class="number">0x0f</span>,</span><br><span class="line">        <span class="number">0x8e</span>, <span class="number">0x83</span>, <span class="number">0x77</span>, <span class="number">0x6b</span>, <span class="number">0x25</span>, <span class="number">0x05</span>, <span class="number">0x3f</span>, <span class="number">0x0c</span>, <span class="number">0x30</span>, <span class="number">0xea</span>, <span class="number">0x70</span>, <span class="number">0xb7</span>, <span class="number">0xa1</span>, <span class="number">0xe8</span>, <span class="number">0xa9</span>, <span class="number">0x65</span>,</span><br><span class="line">        <span class="number">0x8d</span>, <span class="number">0x27</span>, <span class="number">0x1a</span>, <span class="number">0xdb</span>, <span class="number">0x81</span>, <span class="number">0xb3</span>, <span class="number">0xa0</span>, <span class="number">0xf4</span>, <span class="number">0x45</span>, <span class="number">0x7a</span>, <span class="number">0x19</span>, <span class="number">0xdf</span>, <span class="number">0xee</span>, <span class="number">0x78</span>, <span class="number">0x34</span>, <span class="number">0x60</span></span><br><span class="line">&#125;;</span><br><span class="line">u8 S1[<span class="number">256</span>] = &#123;</span><br><span class="line">        <span class="number">0x55</span>, <span class="number">0xc2</span>, <span class="number">0x63</span>, <span class="number">0x71</span>, <span class="number">0x3b</span>, <span class="number">0xc8</span>, <span class="number">0x47</span>, <span class="number">0x86</span>, <span class="number">0x9f</span>, <span class="number">0x3c</span>, <span class="number">0xda</span>, <span class="number">0x5b</span>, <span class="number">0x29</span>, <span class="number">0xaa</span>, <span class="number">0xfd</span>, <span class="number">0x77</span>,</span><br><span class="line">        <span class="number">0x8c</span>, <span class="number">0xc5</span>, <span class="number">0x94</span>, <span class="number">0x0c</span>, <span class="number">0xa6</span>, <span class="number">0x1a</span>, <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0xe3</span>, <span class="number">0xa8</span>, <span class="number">0x16</span>, <span class="number">0x72</span>, <span class="number">0x40</span>, <span class="number">0xf9</span>, <span class="number">0xf8</span>, <span class="number">0x42</span>,</span><br><span class="line">        <span class="number">0x44</span>, <span class="number">0x26</span>, <span class="number">0x68</span>, <span class="number">0x96</span>, <span class="number">0x81</span>, <span class="number">0xd9</span>, <span class="number">0x45</span>, <span class="number">0x3e</span>, <span class="number">0x10</span>, <span class="number">0x76</span>, <span class="number">0xc6</span>, <span class="number">0xa7</span>, <span class="number">0x8b</span>, <span class="number">0x39</span>, <span class="number">0x43</span>, <span class="number">0xe1</span>,</span><br><span class="line">        <span class="number">0x3a</span>, <span class="number">0xb5</span>, <span class="number">0x56</span>, <span class="number">0x2a</span>, <span class="number">0xc0</span>, <span class="number">0x6d</span>, <span class="number">0xb3</span>, <span class="number">0x05</span>, <span class="number">0x22</span>, <span class="number">0x66</span>, <span class="number">0xbf</span>, <span class="number">0xdc</span>, <span class="number">0x0b</span>, <span class="number">0xfa</span>, <span class="number">0x62</span>, <span class="number">0x48</span>,</span><br><span class="line">        <span class="number">0xdd</span>, <span class="number">0x20</span>, <span class="number">0x11</span>, <span class="number">0x06</span>, <span class="number">0x36</span>, <span class="number">0xc9</span>, <span class="number">0xc1</span>, <span class="number">0xcf</span>, <span class="number">0xf6</span>, <span class="number">0x27</span>, <span class="number">0x52</span>, <span class="number">0xbb</span>, <span class="number">0x69</span>, <span class="number">0xf5</span>, <span class="number">0xd4</span>, <span class="number">0x87</span>,</span><br><span class="line">        <span class="number">0x7f</span>, <span class="number">0x84</span>, <span class="number">0x4c</span>, <span class="number">0xd2</span>, <span class="number">0x9c</span>, <span class="number">0x57</span>, <span class="number">0xa4</span>, <span class="number">0xbc</span>, <span class="number">0x4f</span>, <span class="number">0x9a</span>, <span class="number">0xdf</span>, <span class="number">0xfe</span>, <span class="number">0xd6</span>, <span class="number">0x8d</span>, <span class="number">0x7a</span>, <span class="number">0xeb</span>,</span><br><span class="line">        <span class="number">0x2b</span>, <span class="number">0x53</span>, <span class="number">0xd8</span>, <span class="number">0x5c</span>, <span class="number">0xa1</span>, <span class="number">0x14</span>, <span class="number">0x17</span>, <span class="number">0xfb</span>, <span class="number">0x23</span>, <span class="number">0xd5</span>, <span class="number">0x7d</span>, <span class="number">0x30</span>, <span class="number">0x67</span>, <span class="number">0x73</span>, <span class="number">0x08</span>, <span class="number">0x09</span>,</span><br><span class="line">        <span class="number">0xee</span>, <span class="number">0xb7</span>, <span class="number">0x70</span>, <span class="number">0x3f</span>, <span class="number">0x61</span>, <span class="number">0xb2</span>, <span class="number">0x19</span>, <span class="number">0x8e</span>, <span class="number">0x4e</span>, <span class="number">0xe5</span>, <span class="number">0x4b</span>, <span class="number">0x93</span>, <span class="number">0x8f</span>, <span class="number">0x5d</span>, <span class="number">0xdb</span>, <span class="number">0xa9</span>,</span><br><span class="line">        <span class="number">0xad</span>, <span class="number">0xf1</span>, <span class="number">0xae</span>, <span class="number">0x2e</span>, <span class="number">0xcb</span>, <span class="number">0x0d</span>, <span class="number">0xfc</span>, <span class="number">0xf4</span>, <span class="number">0x2d</span>, <span class="number">0x46</span>, <span class="number">0x6e</span>, <span class="number">0x1d</span>, <span class="number">0x97</span>, <span class="number">0xe8</span>, <span class="number">0xd1</span>, <span class="number">0xe9</span>,</span><br><span class="line">        <span class="number">0x4d</span>, <span class="number">0x37</span>, <span class="number">0xa5</span>, <span class="number">0x75</span>, <span class="number">0x5e</span>, <span class="number">0x83</span>, <span class="number">0x9e</span>, <span class="number">0xab</span>, <span class="number">0x82</span>, <span class="number">0x9d</span>, <span class="number">0xb9</span>, <span class="number">0x1c</span>, <span class="number">0xe0</span>, <span class="number">0xcd</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0xb6</span>, <span class="number">0xbd</span>, <span class="number">0x58</span>, <span class="number">0x24</span>, <span class="number">0xa2</span>, <span class="number">0x5f</span>, <span class="number">0x38</span>, <span class="number">0x78</span>, <span class="number">0x99</span>, <span class="number">0x15</span>, <span class="number">0x90</span>, <span class="number">0x50</span>, <span class="number">0xb8</span>, <span class="number">0x95</span>, <span class="number">0xe4</span>,</span><br><span class="line">        <span class="number">0xd0</span>, <span class="number">0x91</span>, <span class="number">0xc7</span>, <span class="number">0xce</span>, <span class="number">0xed</span>, <span class="number">0x0f</span>, <span class="number">0xb4</span>, <span class="number">0x6f</span>, <span class="number">0xa0</span>, <span class="number">0xcc</span>, <span class="number">0xf0</span>, <span class="number">0x02</span>, <span class="number">0x4a</span>, <span class="number">0x79</span>, <span class="number">0xc3</span>, <span class="number">0xde</span>,</span><br><span class="line">        <span class="number">0xa3</span>, <span class="number">0xef</span>, <span class="number">0xea</span>, <span class="number">0x51</span>, <span class="number">0xe6</span>, <span class="number">0x6b</span>, <span class="number">0x18</span>, <span class="number">0xec</span>, <span class="number">0x1b</span>, <span class="number">0x2c</span>, <span class="number">0x80</span>, <span class="number">0xf7</span>, <span class="number">0x74</span>, <span class="number">0xe7</span>, <span class="number">0xff</span>, <span class="number">0x21</span>,</span><br><span class="line">        <span class="number">0x5a</span>, <span class="number">0x6a</span>, <span class="number">0x54</span>, <span class="number">0x1e</span>, <span class="number">0x41</span>, <span class="number">0x31</span>, <span class="number">0x92</span>, <span class="number">0x35</span>, <span class="number">0xc4</span>, <span class="number">0x33</span>, <span class="number">0x07</span>, <span class="number">0x0a</span>, <span class="number">0xba</span>, <span class="number">0x7e</span>, <span class="number">0x0e</span>, <span class="number">0x34</span>,</span><br><span class="line">        <span class="number">0x88</span>, <span class="number">0xb1</span>, <span class="number">0x98</span>, <span class="number">0x7c</span>, <span class="number">0xf3</span>, <span class="number">0x3d</span>, <span class="number">0x60</span>, <span class="number">0x6c</span>, <span class="number">0x7b</span>, <span class="number">0xca</span>, <span class="number">0xd3</span>, <span class="number">0x1f</span>, <span class="number">0x32</span>, <span class="number">0x65</span>, <span class="number">0x04</span>, <span class="number">0x28</span>,</span><br><span class="line">        <span class="number">0x64</span>, <span class="number">0xbe</span>, <span class="number">0x85</span>, <span class="number">0x9b</span>, <span class="number">0x2f</span>, <span class="number">0x59</span>, <span class="number">0x8a</span>, <span class="number">0xd7</span>, <span class="number">0xb0</span>, <span class="number">0x25</span>, <span class="number">0xac</span>, <span class="number">0xaf</span>, <span class="number">0x12</span>, <span class="number">0x03</span>, <span class="number">0xe2</span>, <span class="number">0xf2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the constants D */</span></span><br><span class="line">u32 EK_d[<span class="number">16</span>] = &#123;</span><br><span class="line">        <span class="number">0x44D7</span>, <span class="number">0x26BC</span>, <span class="number">0x626B</span>, <span class="number">0x135E</span>, <span class="number">0x5789</span>, <span class="number">0x35E2</span>, <span class="number">0x7135</span>, <span class="number">0x09AF</span>,</span><br><span class="line">        <span class="number">0x4D78</span>, <span class="number">0x2F13</span>, <span class="number">0x6BC4</span>, <span class="number">0x1AF1</span>, <span class="number">0x5E26</span>, <span class="number">0x3C4D</span>, <span class="number">0x789A</span>, <span class="number">0x47AC</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ——————————————————————- */</span></span><br><span class="line"><span class="comment">/* c = a + b mod (2^31 – 1) */</span></span><br><span class="line"><span class="function">u32 <span class="title">AddM</span><span class="params">(u32 a, u32 b)</span> </span>&#123;</span><br><span class="line">    u32 c = a + b;</span><br><span class="line">    <span class="keyword">return</span> (c &amp; <span class="number">0x7FFFFFFF</span>) + (c &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* LFSR with initialization mode */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MulByPow2(x, k) ((((x) <span class="meta-string">&lt;&lt; k) | ((x) &gt;&gt; (31 - k))) &amp; 0x7FFFFFFF)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LFSRWithInitialisationMode</span><span class="params">(u32 u)</span> </span>&#123;</span><br><span class="line">    u32 f, v;</span><br><span class="line">    f = LFSR_S0;</span><br><span class="line">    v = MulByPow2(LFSR_S0, <span class="number">8</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S4, <span class="number">20</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S10, <span class="number">21</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S13, <span class="number">17</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S15, <span class="number">15</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    f = AddM(f, u);</span><br><span class="line"><span class="comment">/* update the state */</span></span><br><span class="line">    LFSR_S0 = LFSR_S1;</span><br><span class="line">    LFSR_S1 = LFSR_S2;</span><br><span class="line">    LFSR_S2 = LFSR_S3;</span><br><span class="line">    LFSR_S3 = LFSR_S4;</span><br><span class="line">    LFSR_S4 = LFSR_S5;</span><br><span class="line">    LFSR_S5 = LFSR_S6;</span><br><span class="line">    LFSR_S6 = LFSR_S7;</span><br><span class="line">    LFSR_S7 = LFSR_S8;</span><br><span class="line">    LFSR_S8 = LFSR_S9;</span><br><span class="line">    LFSR_S9 = LFSR_S10;</span><br><span class="line">    LFSR_S10 = LFSR_S11;</span><br><span class="line">    LFSR_S11 = LFSR_S12;</span><br><span class="line">    LFSR_S12 = LFSR_S13;</span><br><span class="line">    LFSR_S13 = LFSR_S14;</span><br><span class="line">    LFSR_S14 = LFSR_S15;</span><br><span class="line">    LFSR_S15 = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LFSR with work mode */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LFSRWithWorkMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    u32 f, v;</span><br><span class="line">    f = LFSR_S0;</span><br><span class="line">    v = MulByPow2(LFSR_S0, <span class="number">8</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S4, <span class="number">20</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S10, <span class="number">21</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S13, <span class="number">17</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line">    v = MulByPow2(LFSR_S15, <span class="number">15</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"><span class="comment">/* update the state */</span></span><br><span class="line">    LFSR_S0 = LFSR_S1;</span><br><span class="line">    LFSR_S1 = LFSR_S2;</span><br><span class="line">    LFSR_S2 = LFSR_S3;</span><br><span class="line">    LFSR_S3 = LFSR_S4;</span><br><span class="line">    LFSR_S4 = LFSR_S5;</span><br><span class="line">    LFSR_S5 = LFSR_S6;</span><br><span class="line">    LFSR_S6 = LFSR_S7;</span><br><span class="line">    LFSR_S7 = LFSR_S8;</span><br><span class="line">    LFSR_S8 = LFSR_S9;</span><br><span class="line">    LFSR_S9 = LFSR_S10;</span><br><span class="line">    LFSR_S10 = LFSR_S11;</span><br><span class="line">    LFSR_S11 = LFSR_S12;</span><br><span class="line">    LFSR_S12 = LFSR_S13;</span><br><span class="line">    LFSR_S13 = LFSR_S14;</span><br><span class="line">    LFSR_S14 = LFSR_S15;</span><br><span class="line">    LFSR_S15 = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BitReorganization */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitReorganization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BRC_X0 = ((LFSR_S15 &amp; <span class="number">0x7FFF8000</span>) &lt;&lt; <span class="number">1</span>) | (LFSR_S14 &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">    BRC_X1 = ((LFSR_S11 &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>) | (LFSR_S9 &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    BRC_X2 = ((LFSR_S7 &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>) | (LFSR_S5 &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    BRC_X3 = ((LFSR_S2 &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>) | (LFSR_S0 &gt;&gt; <span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROT(a, k) (((a) <span class="meta-string">&lt;&lt; k) | ((a) &gt;&gt; (32 - k)))</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* L1 */</span></span><br><span class="line"><span class="function">u32 <span class="title">L1</span><span class="params">(u32 X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (X ^ ROT(X, <span class="number">2</span>) ^ ROT(X, <span class="number">10</span>) ^ ROT(X, <span class="number">18</span>) ^ ROT(X, <span class="number">24</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* L2 */</span></span><br><span class="line"><span class="function">u32 <span class="title">L2</span><span class="params">(u32 X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (X ^ ROT(X, <span class="number">8</span>) ^ ROT(X, <span class="number">14</span>) ^ ROT(X, <span class="number">22</span>) ^ ROT(X, <span class="number">30</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKEU32(a, b, c, d) (((u32)(a) &lt;&lt; 24) | ((u32)(b) &lt;&lt; 16)| ((u32)(c) &lt;&lt; 8) | ((u32)(d)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* F */</span></span><br><span class="line"><span class="function">u32 <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    u32 W, W1, W2, u, v;</span><br><span class="line">    W = (BRC_X0 ^ F_R1) + F_R2;</span><br><span class="line">    W1 = F_R1 + BRC_X1;</span><br><span class="line">    W2 = F_R2 ^ BRC_X2;</span><br><span class="line">    u = L1((W1 &lt;&lt; <span class="number">16</span>) | (W2 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    v = L2((W2 &lt;&lt; <span class="number">16</span>) | (W1 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    F_R1 = MAKEU32(S0[u &gt;&gt; <span class="number">24</span>], S1[(u &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>],</span><br><span class="line">                   S0[(u &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>], S1[u &amp; <span class="number">0xFF</span>]);</span><br><span class="line">    F_R2 = MAKEU32(S0[v &gt;&gt; <span class="number">24</span>], S1[(v &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>],</span><br><span class="line">                   S0[(v &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>], S1[v &amp; <span class="number">0xFF</span>]);</span><br><span class="line">    <span class="keyword">return</span> W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKEU31(a, b, c) (((u32)(a) &lt;&lt; 23) | ((u32)(b) &lt;&lt; 8) | (u32)(c))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialization</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *k, <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span> </span>&#123;</span><br><span class="line">    u32 w, nCount;</span><br><span class="line"><span class="comment">/* expand key */</span></span><br><span class="line">    LFSR_S0 = MAKEU31(k[<span class="number">0</span>], EK_d[<span class="number">0</span>], iv[<span class="number">0</span>]);</span><br><span class="line">    LFSR_S1 = MAKEU31(k[<span class="number">1</span>], EK_d[<span class="number">1</span>], iv[<span class="number">1</span>]);</span><br><span class="line">    LFSR_S2 = MAKEU31(k[<span class="number">2</span>], EK_d[<span class="number">2</span>], iv[<span class="number">2</span>]);</span><br><span class="line">    LFSR_S3 = MAKEU31(k[<span class="number">3</span>], EK_d[<span class="number">3</span>], iv[<span class="number">3</span>]);</span><br><span class="line">    LFSR_S4 = MAKEU31(k[<span class="number">4</span>], EK_d[<span class="number">4</span>], iv[<span class="number">4</span>]);</span><br><span class="line">    LFSR_S5 = MAKEU31(k[<span class="number">5</span>], EK_d[<span class="number">5</span>], iv[<span class="number">5</span>]);</span><br><span class="line">    LFSR_S6 = MAKEU31(k[<span class="number">6</span>], EK_d[<span class="number">6</span>], iv[<span class="number">6</span>]);</span><br><span class="line">    LFSR_S7 = MAKEU31(k[<span class="number">7</span>], EK_d[<span class="number">7</span>], iv[<span class="number">7</span>]);</span><br><span class="line">    LFSR_S8 = MAKEU31(k[<span class="number">8</span>], EK_d[<span class="number">8</span>], iv[<span class="number">8</span>]);</span><br><span class="line">    LFSR_S9 = MAKEU31(k[<span class="number">9</span>], EK_d[<span class="number">9</span>], iv[<span class="number">9</span>]);</span><br><span class="line">    LFSR_S10 = MAKEU31(k[<span class="number">10</span>], EK_d[<span class="number">10</span>], iv[<span class="number">10</span>]);</span><br><span class="line">    LFSR_S11 = MAKEU31(k[<span class="number">11</span>], EK_d[<span class="number">11</span>], iv[<span class="number">11</span>]);</span><br><span class="line">    LFSR_S12 = MAKEU31(k[<span class="number">12</span>], EK_d[<span class="number">12</span>], iv[<span class="number">12</span>]);</span><br><span class="line">    LFSR_S13 = MAKEU31(k[<span class="number">13</span>], EK_d[<span class="number">13</span>], iv[<span class="number">13</span>]);</span><br><span class="line">    LFSR_S14 = MAKEU31(k[<span class="number">14</span>], EK_d[<span class="number">14</span>], iv[<span class="number">14</span>]);</span><br><span class="line">    LFSR_S15 = MAKEU31(k[<span class="number">15</span>], EK_d[<span class="number">15</span>], iv[<span class="number">15</span>]);</span><br><span class="line"><span class="comment">/* set F_R1 and F_R2 to zero */</span></span><br><span class="line">    F_R1 = <span class="number">0</span>;</span><br><span class="line">    F_R2 = <span class="number">0</span>;</span><br><span class="line">    nCount = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">while</span> (nCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        BitReorganization();</span><br><span class="line">        w = F();</span><br><span class="line">        LFSRWithInitialisationMode(w &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        nCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateKeyStream</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *pKeyStream, <span class="keyword">unsigned</span> <span class="keyword">int</span> KeyStreamLen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    &#123;</span><br><span class="line">        BitReorganization();</span><br><span class="line">        F(); <span class="comment">/* discard the output of F */</span></span><br><span class="line">        LFSRWithWorkMode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KeyStreamLen; i++) &#123;</span><br><span class="line">        BitReorganization();</span><br><span class="line">        pKeyStream[i] = F() ^ BRC_X3;</span><br><span class="line">        LFSRWithWorkMode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-C-实现（和C基本一样）"><a href="#B-C-实现（和C基本一样）" class="headerlink" title="B. C++实现（和C基本一样）"></a>B. C++实现（和C基本一样）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ZUC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* state registers LFSR */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> LFSR_S[<span class="number">16</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* F registers */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> F_R1 ;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> F_R2 ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output of BR procedure */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> BRC_X[<span class="number">4</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* S-boxes */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> S0[<span class="number">256</span>] = &#123;</span><br><span class="line">    <span class="number">0x3e</span>,<span class="number">0x72</span>,<span class="number">0x5b</span>,<span class="number">0x47</span>,<span class="number">0xca</span>,<span class="number">0xe0</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x04</span>,<span class="number">0xd1</span>,<span class="number">0x54</span>,<span class="number">0x98</span>,<span class="number">0x09</span>,<span class="number">0xb9</span>,<span class="number">0x6d</span>,<span class="number">0xcb</span>,</span><br><span class="line">    <span class="number">0x7b</span>,<span class="number">0x1b</span>,<span class="number">0xf9</span>,<span class="number">0x32</span>,<span class="number">0xaf</span>,<span class="number">0x9d</span>,<span class="number">0x6a</span>,<span class="number">0xa5</span>,<span class="number">0xb8</span>,<span class="number">0x2d</span>,<span class="number">0xfc</span>,<span class="number">0x1d</span>,<span class="number">0x08</span>,<span class="number">0x53</span>,<span class="number">0x03</span>,<span class="number">0x90</span>,</span><br><span class="line">    <span class="number">0x4d</span>,<span class="number">0x4e</span>,<span class="number">0x84</span>,<span class="number">0x99</span>,<span class="number">0xe4</span>,<span class="number">0xce</span>,<span class="number">0xd9</span>,<span class="number">0x91</span>,<span class="number">0xdd</span>,<span class="number">0xb6</span>,<span class="number">0x85</span>,<span class="number">0x48</span>,<span class="number">0x8b</span>,<span class="number">0x29</span>,<span class="number">0x6e</span>,<span class="number">0xac</span>,</span><br><span class="line">    <span class="number">0xcd</span>,<span class="number">0xc1</span>,<span class="number">0xf8</span>,<span class="number">0x1e</span>,<span class="number">0x73</span>,<span class="number">0x43</span>,<span class="number">0x69</span>,<span class="number">0xc6</span>,<span class="number">0xb5</span>,<span class="number">0xbd</span>,<span class="number">0xfd</span>,<span class="number">0x39</span>,<span class="number">0x63</span>,<span class="number">0x20</span>,<span class="number">0xd4</span>,<span class="number">0x38</span>,</span><br><span class="line">    <span class="number">0x76</span>,<span class="number">0x7d</span>,<span class="number">0xb2</span>,<span class="number">0xa7</span>,<span class="number">0xcf</span>,<span class="number">0xed</span>,<span class="number">0x57</span>,<span class="number">0xc5</span>,<span class="number">0xf3</span>,<span class="number">0x2c</span>,<span class="number">0xbb</span>,<span class="number">0x14</span>,<span class="number">0x21</span>,<span class="number">0x06</span>,<span class="number">0x55</span>,<span class="number">0x9b</span>,</span><br><span class="line">    <span class="number">0xe3</span>,<span class="number">0xef</span>,<span class="number">0x5e</span>,<span class="number">0x31</span>,<span class="number">0x4f</span>,<span class="number">0x7f</span>,<span class="number">0x5a</span>,<span class="number">0xa4</span>,<span class="number">0x0d</span>,<span class="number">0x82</span>,<span class="number">0x51</span>,<span class="number">0x49</span>,<span class="number">0x5f</span>,<span class="number">0xba</span>,<span class="number">0x58</span>,<span class="number">0x1c</span>,</span><br><span class="line">    <span class="number">0x4a</span>,<span class="number">0x16</span>,<span class="number">0xd5</span>,<span class="number">0x17</span>,<span class="number">0xa8</span>,<span class="number">0x92</span>,<span class="number">0x24</span>,<span class="number">0x1f</span>,<span class="number">0x8c</span>,<span class="number">0xff</span>,<span class="number">0xd8</span>,<span class="number">0xae</span>,<span class="number">0x2e</span>,<span class="number">0x01</span>,<span class="number">0xd3</span>,<span class="number">0xad</span>,</span><br><span class="line">    <span class="number">0x3b</span>,<span class="number">0x4b</span>,<span class="number">0xda</span>,<span class="number">0x46</span>,<span class="number">0xeb</span>,<span class="number">0xc9</span>,<span class="number">0xde</span>,<span class="number">0x9a</span>,<span class="number">0x8f</span>,<span class="number">0x87</span>,<span class="number">0xd7</span>,<span class="number">0x3a</span>,<span class="number">0x80</span>,<span class="number">0x6f</span>,<span class="number">0x2f</span>,<span class="number">0xc8</span>,</span><br><span class="line">    <span class="number">0xb1</span>,<span class="number">0xb4</span>,<span class="number">0x37</span>,<span class="number">0xf7</span>,<span class="number">0x0a</span>,<span class="number">0x22</span>,<span class="number">0x13</span>,<span class="number">0x28</span>,<span class="number">0x7c</span>,<span class="number">0xcc</span>,<span class="number">0x3c</span>,<span class="number">0x89</span>,<span class="number">0xc7</span>,<span class="number">0xc3</span>,<span class="number">0x96</span>,<span class="number">0x56</span>,</span><br><span class="line">    <span class="number">0x07</span>,<span class="number">0xbf</span>,<span class="number">0x7e</span>,<span class="number">0xf0</span>,<span class="number">0x0b</span>,<span class="number">0x2b</span>,<span class="number">0x97</span>,<span class="number">0x52</span>,<span class="number">0x35</span>,<span class="number">0x41</span>,<span class="number">0x79</span>,<span class="number">0x61</span>,<span class="number">0xa6</span>,<span class="number">0x4c</span>,<span class="number">0x10</span>,<span class="number">0xfe</span>,</span><br><span class="line">    <span class="number">0xbc</span>,<span class="number">0x26</span>,<span class="number">0x95</span>,<span class="number">0x88</span>,<span class="number">0x8a</span>,<span class="number">0xb0</span>,<span class="number">0xa3</span>,<span class="number">0xfb</span>,<span class="number">0xc0</span>,<span class="number">0x18</span>,<span class="number">0x94</span>,<span class="number">0xf2</span>,<span class="number">0xe1</span>,<span class="number">0xe5</span>,<span class="number">0xe9</span>,<span class="number">0x5d</span>,</span><br><span class="line">    <span class="number">0xd0</span>,<span class="number">0xdc</span>,<span class="number">0x11</span>,<span class="number">0x66</span>,<span class="number">0x64</span>,<span class="number">0x5c</span>,<span class="number">0xec</span>,<span class="number">0x59</span>,<span class="number">0x42</span>,<span class="number">0x75</span>,<span class="number">0x12</span>,<span class="number">0xf5</span>,<span class="number">0x74</span>,<span class="number">0x9c</span>,<span class="number">0xaa</span>,<span class="number">0x23</span>,</span><br><span class="line">    <span class="number">0x0e</span>,<span class="number">0x86</span>,<span class="number">0xab</span>,<span class="number">0xbe</span>,<span class="number">0x2a</span>,<span class="number">0x02</span>,<span class="number">0xe7</span>,<span class="number">0x67</span>,<span class="number">0xe6</span>,<span class="number">0x44</span>,<span class="number">0xa2</span>,<span class="number">0x6c</span>,<span class="number">0xc2</span>,<span class="number">0x93</span>,<span class="number">0x9f</span>,<span class="number">0xf1</span>,</span><br><span class="line">    <span class="number">0xf6</span>,<span class="number">0xfa</span>,<span class="number">0x36</span>,<span class="number">0xd2</span>,<span class="number">0x50</span>,<span class="number">0x68</span>,<span class="number">0x9e</span>,<span class="number">0x62</span>,<span class="number">0x71</span>,<span class="number">0x15</span>,<span class="number">0x3d</span>,<span class="number">0xd6</span>,<span class="number">0x40</span>,<span class="number">0xc4</span>,<span class="number">0xe2</span>,<span class="number">0x0f</span>,</span><br><span class="line">    <span class="number">0x8e</span>,<span class="number">0x83</span>,<span class="number">0x77</span>,<span class="number">0x6b</span>,<span class="number">0x25</span>,<span class="number">0x05</span>,<span class="number">0x3f</span>,<span class="number">0x0c</span>,<span class="number">0x30</span>,<span class="number">0xea</span>,<span class="number">0x70</span>,<span class="number">0xb7</span>,<span class="number">0xa1</span>,<span class="number">0xe8</span>,<span class="number">0xa9</span>,<span class="number">0x65</span>,</span><br><span class="line">    <span class="number">0x8d</span>,<span class="number">0x27</span>,<span class="number">0x1a</span>,<span class="number">0xdb</span>,<span class="number">0x81</span>,<span class="number">0xb3</span>,<span class="number">0xa0</span>,<span class="number">0xf4</span>,<span class="number">0x45</span>,<span class="number">0x7a</span>,<span class="number">0x19</span>,<span class="number">0xdf</span>,<span class="number">0xee</span>,<span class="number">0x78</span>,<span class="number">0x34</span>,<span class="number">0x60</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> S1[<span class="number">256</span>] = &#123;</span><br><span class="line">    <span class="number">0x55</span>,<span class="number">0xc2</span>,<span class="number">0x63</span>,<span class="number">0x71</span>,<span class="number">0x3b</span>,<span class="number">0xc8</span>,<span class="number">0x47</span>,<span class="number">0x86</span>,<span class="number">0x9f</span>,<span class="number">0x3c</span>,<span class="number">0xda</span>,<span class="number">0x5b</span>,<span class="number">0x29</span>,<span class="number">0xaa</span>,<span class="number">0xfd</span>,<span class="number">0x77</span>,</span><br><span class="line">    <span class="number">0x8c</span>,<span class="number">0xc5</span>,<span class="number">0x94</span>,<span class="number">0x0c</span>,<span class="number">0xa6</span>,<span class="number">0x1a</span>,<span class="number">0x13</span>,<span class="number">0x00</span>,<span class="number">0xe3</span>,<span class="number">0xa8</span>,<span class="number">0x16</span>,<span class="number">0x72</span>,<span class="number">0x40</span>,<span class="number">0xf9</span>,<span class="number">0xf8</span>,<span class="number">0x42</span>,</span><br><span class="line">    <span class="number">0x44</span>,<span class="number">0x26</span>,<span class="number">0x68</span>,<span class="number">0x96</span>,<span class="number">0x81</span>,<span class="number">0xd9</span>,<span class="number">0x45</span>,<span class="number">0x3e</span>,<span class="number">0x10</span>,<span class="number">0x76</span>,<span class="number">0xc6</span>,<span class="number">0xa7</span>,<span class="number">0x8b</span>,<span class="number">0x39</span>,<span class="number">0x43</span>,<span class="number">0xe1</span>,</span><br><span class="line">    <span class="number">0x3a</span>,<span class="number">0xb5</span>,<span class="number">0x56</span>,<span class="number">0x2a</span>,<span class="number">0xc0</span>,<span class="number">0x6d</span>,<span class="number">0xb3</span>,<span class="number">0x05</span>,<span class="number">0x22</span>,<span class="number">0x66</span>,<span class="number">0xbf</span>,<span class="number">0xdc</span>,<span class="number">0x0b</span>,<span class="number">0xfa</span>,<span class="number">0x62</span>,<span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0xdd</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x06</span>,<span class="number">0x36</span>,<span class="number">0xc9</span>,<span class="number">0xc1</span>,<span class="number">0xcf</span>,<span class="number">0xf6</span>,<span class="number">0x27</span>,<span class="number">0x52</span>,<span class="number">0xbb</span>,<span class="number">0x69</span>,<span class="number">0xf5</span>,<span class="number">0xd4</span>,<span class="number">0x87</span>,</span><br><span class="line">    <span class="number">0x7f</span>,<span class="number">0x84</span>,<span class="number">0x4c</span>,<span class="number">0xd2</span>,<span class="number">0x9c</span>,<span class="number">0x57</span>,<span class="number">0xa4</span>,<span class="number">0xbc</span>,<span class="number">0x4f</span>,<span class="number">0x9a</span>,<span class="number">0xdf</span>,<span class="number">0xfe</span>,<span class="number">0xd6</span>,<span class="number">0x8d</span>,<span class="number">0x7a</span>,<span class="number">0xeb</span>,</span><br><span class="line">    <span class="number">0x2b</span>,<span class="number">0x53</span>,<span class="number">0xd8</span>,<span class="number">0x5c</span>,<span class="number">0xa1</span>,<span class="number">0x14</span>,<span class="number">0x17</span>,<span class="number">0xfb</span>,<span class="number">0x23</span>,<span class="number">0xd5</span>,<span class="number">0x7d</span>,<span class="number">0x30</span>,<span class="number">0x67</span>,<span class="number">0x73</span>,<span class="number">0x08</span>,<span class="number">0x09</span>,</span><br><span class="line">    <span class="number">0xee</span>,<span class="number">0xb7</span>,<span class="number">0x70</span>,<span class="number">0x3f</span>,<span class="number">0x61</span>,<span class="number">0xb2</span>,<span class="number">0x19</span>,<span class="number">0x8e</span>,<span class="number">0x4e</span>,<span class="number">0xe5</span>,<span class="number">0x4b</span>,<span class="number">0x93</span>,<span class="number">0x8f</span>,<span class="number">0x5d</span>,<span class="number">0xdb</span>,<span class="number">0xa9</span>,</span><br><span class="line">    <span class="number">0xad</span>,<span class="number">0xf1</span>,<span class="number">0xae</span>,<span class="number">0x2e</span>,<span class="number">0xcb</span>,<span class="number">0x0d</span>,<span class="number">0xfc</span>,<span class="number">0xf4</span>,<span class="number">0x2d</span>,<span class="number">0x46</span>,<span class="number">0x6e</span>,<span class="number">0x1d</span>,<span class="number">0x97</span>,<span class="number">0xe8</span>,<span class="number">0xd1</span>,<span class="number">0xe9</span>,</span><br><span class="line">    <span class="number">0x4d</span>,<span class="number">0x37</span>,<span class="number">0xa5</span>,<span class="number">0x75</span>,<span class="number">0x5e</span>,<span class="number">0x83</span>,<span class="number">0x9e</span>,<span class="number">0xab</span>,<span class="number">0x82</span>,<span class="number">0x9d</span>,<span class="number">0xb9</span>,<span class="number">0x1c</span>,<span class="number">0xe0</span>,<span class="number">0xcd</span>,<span class="number">0x49</span>,<span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0x01</span>,<span class="number">0xb6</span>,<span class="number">0xbd</span>,<span class="number">0x58</span>,<span class="number">0x24</span>,<span class="number">0xa2</span>,<span class="number">0x5f</span>,<span class="number">0x38</span>,<span class="number">0x78</span>,<span class="number">0x99</span>,<span class="number">0x15</span>,<span class="number">0x90</span>,<span class="number">0x50</span>,<span class="number">0xb8</span>,<span class="number">0x95</span>,<span class="number">0xe4</span>,</span><br><span class="line">    <span class="number">0xd0</span>,<span class="number">0x91</span>,<span class="number">0xc7</span>,<span class="number">0xce</span>,<span class="number">0xed</span>,<span class="number">0x0f</span>,<span class="number">0xb4</span>,<span class="number">0x6f</span>,<span class="number">0xa0</span>,<span class="number">0xcc</span>,<span class="number">0xf0</span>,<span class="number">0x02</span>,<span class="number">0x4a</span>,<span class="number">0x79</span>,<span class="number">0xc3</span>,<span class="number">0xde</span>,</span><br><span class="line">    <span class="number">0xa3</span>,<span class="number">0xef</span>,<span class="number">0xea</span>,<span class="number">0x51</span>,<span class="number">0xe6</span>,<span class="number">0x6b</span>,<span class="number">0x18</span>,<span class="number">0xec</span>,<span class="number">0x1b</span>,<span class="number">0x2c</span>,<span class="number">0x80</span>,<span class="number">0xf7</span>,<span class="number">0x74</span>,<span class="number">0xe7</span>,<span class="number">0xff</span>,<span class="number">0x21</span>,</span><br><span class="line">    <span class="number">0x5a</span>,<span class="number">0x6a</span>,<span class="number">0x54</span>,<span class="number">0x1e</span>,<span class="number">0x41</span>,<span class="number">0x31</span>,<span class="number">0x92</span>,<span class="number">0x35</span>,<span class="number">0xc4</span>,<span class="number">0x33</span>,<span class="number">0x07</span>,<span class="number">0x0a</span>,<span class="number">0xba</span>,<span class="number">0x7e</span>,<span class="number">0x0e</span>,<span class="number">0x34</span>,</span><br><span class="line">    <span class="number">0x88</span>,<span class="number">0xb1</span>,<span class="number">0x98</span>,<span class="number">0x7c</span>,<span class="number">0xf3</span>,<span class="number">0x3d</span>,<span class="number">0x60</span>,<span class="number">0x6c</span>,<span class="number">0x7b</span>,<span class="number">0xca</span>,<span class="number">0xd3</span>,<span class="number">0x1f</span>,<span class="number">0x32</span>,<span class="number">0x65</span>,<span class="number">0x04</span>,<span class="number">0x28</span>,</span><br><span class="line">    <span class="number">0x64</span>,<span class="number">0xbe</span>,<span class="number">0x85</span>,<span class="number">0x9b</span>,<span class="number">0x2f</span>,<span class="number">0x59</span>,<span class="number">0x8a</span>,<span class="number">0xd7</span>,<span class="number">0xb0</span>,<span class="number">0x25</span>,<span class="number">0xac</span>,<span class="number">0xaf</span>,<span class="number">0x12</span>,<span class="number">0x03</span>,<span class="number">0xe2</span>,<span class="number">0xf2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* D constants */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EK_d[<span class="number">16</span>] = &#123;</span><br><span class="line">    <span class="number">0x44D7</span>, <span class="number">0x26BC</span>, <span class="number">0x626B</span>, <span class="number">0x135E</span>, <span class="number">0x5789</span>, <span class="number">0x35E2</span>, <span class="number">0x7135</span>, <span class="number">0x09AF</span>,</span><br><span class="line">    <span class="number">0x4D78</span>, <span class="number">0x2F13</span>, <span class="number">0x6BC4</span>, <span class="number">0x1AF1</span>, <span class="number">0x5E26</span>, <span class="number">0x3C4D</span>, <span class="number">0x789A</span>, <span class="number">0x47AC</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">AddM</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> c = a + b;</span><br><span class="line">	<span class="keyword">return</span> (c &amp; <span class="number">0x7FFFFFFF</span>) + (c &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MulByPow2(x, k) ((((x) <span class="meta-string">&lt;&lt; k) | ((x) &gt;&gt; (31 - k))) &amp; 0x7FFFFFFF)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LFSR */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LFSRWithInitializationMode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> f, v;</span><br><span class="line"></span><br><span class="line">    f = LFSR_S[<span class="number">0</span>];</span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">0</span>], <span class="number">8</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">4</span>], <span class="number">20</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">10</span>], <span class="number">21</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">13</span>], <span class="number">17</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">15</span>], <span class="number">15</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    f = AddM(f, u);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update the state */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">        LFSR_S[i] = LFSR_S[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    LFSR_S[<span class="number">15</span>] = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LFSR with work mode */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LFSRWithWorkMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> f, v;</span><br><span class="line"></span><br><span class="line">    f = LFSR_S[<span class="number">0</span>];</span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">0</span>], <span class="number">8</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">4</span>], <span class="number">20</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">10</span>], <span class="number">21</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">13</span>], <span class="number">17</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    v = MulByPow2(LFSR_S[<span class="number">15</span>], <span class="number">15</span>);</span><br><span class="line">    f = AddM(f, v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update state */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">        LFSR_S[i] = LFSR_S[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    LFSR_S[<span class="number">15</span>] = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bit Reorganization Procedure */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitReorganization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BRC_X[<span class="number">0</span>] = ((LFSR_S[<span class="number">15</span>] &amp; <span class="number">0x7FFF8000</span>) &lt;&lt; <span class="number">1</span>) | (LFSR_S[<span class="number">14</span>] &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">    BRC_X[<span class="number">1</span>] = ((LFSR_S[<span class="number">11</span>] &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>) | (LFSR_S[<span class="number">9</span>] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    BRC_X[<span class="number">2</span>] = ((LFSR_S[<span class="number">7</span>] &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>) | (LFSR_S[<span class="number">5</span>] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    BRC_X[<span class="number">3</span>] = ((LFSR_S[<span class="number">2</span>] &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>) | (LFSR_S[<span class="number">0</span>] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROT(a, k) (((a) <span class="meta-string">&lt;&lt; k) | ((a) &gt;&gt; (32 - k)))</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* linear transformation L1 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">L1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (X ^ ROT(X, <span class="number">2</span>) ^ ROT(X, <span class="number">10</span>) ^ ROT(X, <span class="number">18</span>) ^ ROT(X, <span class="number">24</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* linear transformation L2 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">L2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (X ^ ROT(X, <span class="number">8</span>) ^ ROT(X, <span class="number">14</span>) ^ ROT(X, <span class="number">22</span>) ^ ROT(X, <span class="number">30</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create 32-bit word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKEU32(a, b, c ,d) (\</span></span><br><span class="line">((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a) &lt;&lt; <span class="number">24</span>) \</span><br><span class="line">| ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(b) &lt;&lt; <span class="number">16</span>) \</span><br><span class="line">| ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(c) &lt;&lt; <span class="number">8</span>) \</span><br><span class="line">| ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(d)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* non-linear function F */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> W, W1, W2, u, v;</span><br><span class="line"></span><br><span class="line">    W = (BRC_X[<span class="number">0</span>] ^ F_R1) + F_R2;</span><br><span class="line">    W1 = F_R1 + BRC_X[<span class="number">1</span>];</span><br><span class="line">    W2 = F_R2 ^ BRC_X[<span class="number">2</span>];</span><br><span class="line">    u = L1((W1 &lt;&lt; <span class="number">16</span>) | (W2 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    v = L2((W2 &lt;&lt; <span class="number">16</span>) | (W1 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    F_R1 = MAKEU32(S0[u &gt;&gt; <span class="number">24</span>], S1[(u &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>], S0[(u &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>], S1[u &amp; <span class="number">0xFF</span>]);</span><br><span class="line">    F_R2 = MAKEU32(S0[v &gt;&gt; <span class="number">24</span>], S1[(v &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>], S0[(v &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>], S1[v &amp; <span class="number">0xFF</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKEU31(a, b, c) ( \</span></span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">0</span>) \</span><br><span class="line">    | (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a)) &lt;&lt; <span class="number">23</span>) \</span><br><span class="line">    | ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(b) &lt;&lt; <span class="number">8</span>) \</span><br><span class="line">    | (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">0</span>) \</span><br><span class="line">    | (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(c)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialization</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *k, <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* expand key */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">        LFSR_S[i] = MAKEU31(k[i], EK_d[i], iv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* set F_R1 and F_R2 to zero */</span></span><br><span class="line">    F_R1 = <span class="number">0</span>;</span><br><span class="line">    F_R2 = <span class="number">0</span>;	</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nCount = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">while</span> (nCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        BitReorganization();</span><br><span class="line">        w = F();</span><br><span class="line">        LFSRWithInitializationMode(w &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        nCount--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BitReorganization();</span><br><span class="line">    F();</span><br><span class="line">    LFSRWithWorkMode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateKeyStream</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *pKeyStream, <span class="keyword">unsigned</span> <span class="keyword">int</span> KeyStreamLen)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* working cycles */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; KeyStreamLen; ++i)&#123;</span><br><span class="line">        BitReorganization();</span><br><span class="line">        pKeyStream[i] = F() ^ BRC_X[<span class="number">3</span>];</span><br><span class="line">        LFSRWithWorkMode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>ZUC</tag>
        <tag>加密算法</tag>
        <tag>信息安全</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>再再探C++的类（析构函数，运算符重载，继承，动态内存分配）</title>
    <url>/2020/10/19/%E5%86%8D%E5%86%8D%E6%8E%A2CPP%E7%9A%84%E7%B1%BB%EF%BC%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%89/</url>
    <content><![CDATA[<p>嗯，终于到了这个专题的终篇……😑。</p>
<p>类，基类，虚基类，抽象基类，抽象虚基类傻傻分不清。</p>
<p>继承，公有继承保护继承私有继承多重继承两眼一抹黑。</p>
<a id="more"></a>
<blockquote>
<p>  内容参考自《C++ Primer Plus》（第六版）</p>
</blockquote>
<p>文如其题，挨个了解：</p>
<ul>
<li>析构函数</li>
<li>运算符重载<ul>
<li>成员函数重载呢，还是友元函数重载呢？</li>
</ul>
</li>
<li>继承<ul>
<li>访问控制，<code>public, protected, private</code></li>
<li>抽象基类（Abstract Base Class，ABC）</li>
</ul>
</li>
<li>多重继承<ul>
<li>虚基类</li>
<li>使用哪一个方法？</li>
</ul>
</li>
<li>当然，还有需要小心处理的动态内存分配（这次实在写不下了，写吐了🤮🤢，还是下次来个动态内存专题吧😛）</li>
</ul>
<h1 id="1-析构函数"><a href="#1-析构函数" class="headerlink" title="1. 析构函数"></a>1. 析构函数</h1><p>创建出来一个对象，在作用域结束后，程序会自动对这个对象进行销毁，这时候会调用一个特殊的成员函数——析构函数。</p>
<p>析构函数完成的任务主要是内存释放，资源释放等收尾工作。</p>
<p>同构造函数一样，当类的设计者不给类提供析构函数时，编译器会提供一个默认的析构函数，这个默认的析构函数什么也不做。至于什么时候调用析构函数嘛，当然是由编译器来决定。一般来说，使用 <code>new</code> 创建出来的对象，需要使用 <code>delete</code> 来主动释放。</p>
<p>具体例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeConstructor</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DeConstructor(<span class="keyword">int</span> <span class="built_in">size</span>) &#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">size</span>];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;创建了一个 &quot;</span> + to_string(<span class="built_in">size</span>) + <span class="string">&quot; 大小的 char 数组&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~DeConstructor() &#123;</span><br><span class="line">        <span class="keyword">delete</span> name;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;把创建出来的数组空间释放掉了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">DeConstructor <span class="title">deConstructor</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="comment">// &gt;: 创建了一个 20 大小的 char 数组</span></span><br><span class="line">    <span class="comment">// &gt;: 把创建出来的数组空间释放掉了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-运算符重载"><a href="#2-运算符重载" class="headerlink" title="2. 运算符重载"></a>2. 运算符重载</h1><p>简而言之，就是把基础类型的运算符搬到了自定义类型上来，遵循原有的运算符句法规则，来个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hours = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minutes = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Time() = <span class="keyword">default</span>;</span><br><span class="line">    Time(<span class="keyword">int</span> _hours, <span class="keyword">int</span> _minutes) : hours(_hours), minutes(_minutes) &#123;&#125;</span><br><span class="line">    Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp;time) <span class="keyword">const</span> &#123;</span><br><span class="line">        Time tmp;</span><br><span class="line">        tmp.minutes = minutes + time.minutes;</span><br><span class="line">        tmp.hours = hours + time.hours + tmp.minutes / <span class="number">60</span>;</span><br><span class="line">        tmp.minutes %= <span class="number">60</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Time &amp;time) &#123;</span><br><span class="line">        os &lt;&lt; time.hours &lt;&lt; <span class="string">&quot; hourse &quot;</span> &lt;&lt; time.minutes &lt;&lt; <span class="string">&quot; minutes.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Time <span class="title">start</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; start &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 1 hourse 2 minutes.</span></span><br><span class="line">    <span class="function">Time <span class="title">end</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">end</span> = start + <span class="built_in">end</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">end</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// &gt;: 11 hourse 22 minutes.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，引入了两个运算符重载，分别是 <code>+</code> 和 <code>&lt;&lt;</code> ，两种不同的方式：<strong>成员函数运算符重载</strong>，以及<strong>友元函数运算符重载</strong>。在运算符重载时，写成 <code>const</code> 函数是很有帮助的，例如一个 <code>const Time time</code> 也可以调用这个方法，不过额外的开销是运算内部的对象创建。</p>
<p><code>+</code> 运算符的重载是最一般的操作，定义了两个 <code>Time</code> 类型进行 <code>+</code> 运算时要执行的操作，这里使用了成员函数运算符重载方法，所以可以直接使用 <code>this</code> 指针访问调用者的 <code>minutes</code> 和 <code>hours</code> 。当然，它也可以写成友元函数的形式。</p>
<p><code>&lt;&lt;</code> 运算符重载是另一类典型重载方式，使用友元函数来重载，这个时候就需要按照运算符规则（双目运算符）来提供左右两个参数（需要注意顺序~），当然也可以写成 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">const</span> Time &amp;time, ostream &amp;os)</span><br></pre></td></tr></table></figure>
<p> 但是调用该函数时成了 <code>time &lt;&lt; cout</code>，这样一来，不感觉哪里怪怪的么🙄？</p>
<h2 id="2-1-重载限制"><a href="#2-1-重载限制" class="headerlink" title="2.1 重载限制"></a>2.1 重载限制</h2><ol>
<li>重载后的运算符必须至少有一个操作数是用户定义的类型。</li>
<li>使用运算符时，不能违反运算符原来的句法规则。</li>
<li>不能创建新运算符。</li>
<li>不能重载下面的运算符：<ul>
<li><code>size_of, . , *, ::, ?:, typeid, const_cast, dynamic_cast, reinterpret_cast, static_cast</code></li>
</ul>
</li>
<li>下面的运算符只能通过成员函数重载：<ul>
<li><code>=, (), [], -&gt;</code></li>
</ul>
</li>
</ol>
<h2 id="2-2-使用成员函数？还是非成员函数？"><a href="#2-2-使用成员函数？还是非成员函数？" class="headerlink" title="2.2 使用成员函数？还是非成员函数？"></a>2.2 使用成员函数？还是非成员函数？</h2><p>除了上面提到的四种运算符，这两种实现方式都是可以的。在成员函数实现方式中，一个操作数会通过 <code>this</code> 指针默认传递进来，而对于友元函数来说，两个操作数都需要显式参数传递。</p>
<p>不过，两种方式只能使用一种，如果两个都定义了，那么会出现<strong>二义性</strong>错误，从而导致编译错误。</p>
<h1 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h1><p>在这部分开始时，先来了解几个通用概念。</p>
<p>派生一个类：使用 <code>class &lt;ClassName&gt; : public/protected/private &lt;Base_ClassName&gt;&#123;&#125;;</code> 形式来声明，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableTennisPlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">bool</span> hasTable;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TableTennisPlayer(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name) : TableTennisPlayer(name, <span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    TableTennisPlayer(<span class="keyword">const</span> <span class="built_in">string</span> &amp;_name, <span class="keyword">bool</span> _hasTable) : name(_name), hasTable(_hasTable) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">has_table</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_table</span><span class="params">(<span class="keyword">bool</span> _hasTable)</span> </span>&#123; hasTable = _hasTable; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生自 TableTennisPlayer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RatedPlayer</span> :</span> <span class="keyword">public</span> TableTennisPlayer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rating = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造自己的同时，把基类也给构造好了</span></span><br><span class="line">    RatedPlayer(<span class="keyword">int</span> r = <span class="number">0</span>) : rating(r), TableTennisPlayer(<span class="string">&quot;&quot;</span>, <span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    RatedPlayer(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name = <span class="string">&quot;non-name&quot;</span>, <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">bool</span> hasTable = <span class="literal">false</span>) :</span><br><span class="line">            rating(r), TableTennisPlayer(name, hasTable) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类不管怎样都不能直接访问基类的私有属性，即便公有派生也不行🤭。</p>
<p>在派生类的构造过程中，会先把基类给构造，如果在这个过程中没有显式调用基类的构造函数，那么会调用一个默认的基类构造函数。所以一般要自己显式指定，例如上面的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RatedPlayer(<span class="keyword">int</span> r = <span class="number">0</span>) : rating(r), TableTennisPlayer(<span class="string">&quot;&quot;</span>, <span class="literal">false</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在内存释放过程中，是先释放基类，再释放派生类。</p>
<p>在派生类的文件位置存放上，一般来说要和基类放到一个文件下，方便访问同时也方便查找，对于类的定义也是。</p>
<p>派生类可以使用基类方法（前提是方法不是私有的）</p>
<p>基类指针可以在不进行显式转换的情况下，指向派生类对象；而基类引用也可以在不进行显式转换的情况下引用派生类对象。但是这样一来只能使用基类的方法（因为指针真的把当前对象看作了基类对象😧）。</p>
<p><strong>继承：坚持使用 is-a 关系</strong>：</p>
<ul>
<li>公有继承不能建立 <code>is-like-a</code> 关系</li>
<li>公有继承不能建立 <code>is-implemented-as-a</code> 关系</li>
<li>公有继承不能建立 <code>uses-a</code> 关系</li>
</ul>
<h2 id="3-1-访问控制"><a href="#3-1-访问控制" class="headerlink" title="3.1 访问控制"></a>3.1 访问控制</h2><p><strong>编译器的默认是私有派生！</strong></p>
<h3 id="3-1-1-公有派生（Public）"><a href="#3-1-1-公有派生（Public）" class="headerlink" title="3.1.1 公有派生（Public）"></a>3.1.1 公有派生（Public）</h3><blockquote>
<p>  使用公有派生，基类的公有成员将成为派生类的公有成员，基类的私有成员也会成为派生类的一部分（在内存上包含关系），但是只能通过公有或保护方法来访问。</p>
</blockquote>
<h3 id="3-1-2-保护派生（Protected）"><a href="#3-1-2-保护派生（Protected）" class="headerlink" title="3.1.2 保护派生（Protected）"></a>3.1.2 保护派生（Protected）</h3><blockquote>
<p>  派生类的成员可以直接访问基类的保护成员和公有成员，但仍然不能访问基类的私有成员。对外部来说，保护成员的可访问性和私有成员是一样的，在类的外部均不可访问。</p>
</blockquote>
<h3 id="3-1-3-私有派生（Private）"><a href="#3-1-3-私有派生（Private）" class="headerlink" title="3.1.3 私有派生（Private）"></a>3.1.3 私有派生（Private）</h3><blockquote>
<p>  私有派生之后，基类的公有成员和保护成员，都成了派生类的私有成员，构成了一种 has-a 的关系。</p>
</blockquote>
<h2 id="3-2-抽象基类"><a href="#3-2-抽象基类" class="headerlink" title="3.2 抽象基类"></a>3.2 抽象基类</h2><p>抽象基类顾名思义，就是这个类不允许被实例化，它抽象出了派生类需要实现的功能，但本身并不进行实现，只声明接口，不提供定义。而且从抽象基类派生出来的类，需要强制实现它定义的抽象接口。</p>
<p>当然，抽象基类也不会太小气以至于所有方法都不给实现，它也会根据需要提供一些已定义的方法（派生出来的类都需要用的，而且处理过程一样的）。例如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEllipse</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseEllipse(<span class="keyword">double</span> x0 = <span class="number">0</span>, <span class="keyword">double</span> y0 = <span class="number">0</span>) : x(x0), y(y0) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> nx, <span class="keyword">int</span> ny)</span> </span>&#123; x = nx, y = ny; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~BaseEllipse() &#123;&#125;</span><br><span class="line">    <span class="comment">// 使用 =0 来指出这个类是一个抽象类，这时不可以直接实例化该类，这个虚函数是纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> BaseEllipse &amp;baseEllipse) &#123;</span><br><span class="line">        os &lt;&lt; baseEllipse.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; baseEllipse.y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; baseEllipse.area();</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> BaseEllipse &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span> r0) : r(r0), BaseEllipse(<span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Circle(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">double</span> r0) : r(r0), BaseEllipse(x, y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> r * r * <span class="number">3.14</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Circle <span class="title">circle</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">circle</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 0 0 12.56</span></span><br><span class="line">    <span class="built_in">circle</span>.<span class="built_in">move</span>(<span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">circle</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// &gt;: 3 9 12.56</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，抽象出了 <code>BaseEllipse</code> 类，这个类中提供求面积的方法 <code>area()</code> ，但是由于不确定是</p>
<p>椭圆还是正圆，所以把这个方法的具体实现就交给了下面的派生类，派生类根据自己需要进行实现。</p>
<p>同上面所述，该抽象基类也提供了大家都用得到的 <code>move()</code> 方法并进行了实现。</p>
<p><strong>要让一个类成为抽象基类，必须提供至少一个纯虚函数！</strong></p>
<p>纯虚函数和虚函数主要在于 <code>=0</code> 的不同，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>= <span class="number">0</span>; 	<span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;		<span class="comment">// 虚函数</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-1-对于ABC的一些讨论"><a href="#3-2-1-对于ABC的一些讨论" class="headerlink" title="3.2.1 对于ABC的一些讨论"></a>3.2.1 对于ABC的一些讨论</h3><p>在使用 ABC 之前，需要首先设计一个良好的模型——指出问题所需的类以及它们之间的关系。一种比较好的方法是：</p>
<blockquote>
<p>  如果要设计类继承层次，那么只将那些不会被用作基类的类设计为具体的类。</p>
</blockquote>
<p>讨论完了😶</p>
<h1 id="4-多重继承（MI）"><a href="#4-多重继承（MI）" class="headerlink" title="4. 多重继承（MI）"></a>4. 多重继承（MI）</h1><p>在C++多重继承诞生之初，就产生了很多争论，有人强烈建议删除MI，因为它相比于单继承更容易出现问题，更困难，更迷茫。但是不可否认的是，在一些特殊场合，MI很有用，例如一只会飞会游泳会跑的大白鹅🙄呢。</p>
<p>话不多说，先来看下面例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Worker() : name(<span class="string">&quot;non-name&quot;</span>), id(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Worker(<span class="keyword">const</span> <span class="built_in">string</span> &amp;_name, <span class="keyword">int</span> _id) : name(_name), id(_id) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Worker &amp;worker) &#123;</span><br><span class="line">        os &lt;&lt; worker.id &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; worker.name;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> panache = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Waiter(<span class="keyword">int</span> p, <span class="keyword">int</span> id, <span class="keyword">const</span> <span class="built_in">string</span> &amp;name) : Worker(name, id), panache(p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> voice = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Singer(<span class="keyword">int</span> v, <span class="keyword">int</span> id, <span class="keyword">const</span> <span class="built_in">string</span> &amp;name) : Worker(name, id), voice(v) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Singer &amp;singer) &#123;</span><br><span class="line">        os &lt;&lt; (Worker) singer &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; singer.voice;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时候， SingerWaiter 对象内部，只有一个 Worker 实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingerWaiter</span> :</span> <span class="keyword">public</span> Waiter, Singer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SingerWaiter(<span class="keyword">int</span> c, <span class="keyword">int</span> v, <span class="keyword">int</span> p, <span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">int</span> id) :</span><br><span class="line">            Worker(name, id), Singer(v, id, name), Waiter(p, id, name), cost(c) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> SingerWaiter &amp;singerWaiter) &#123;</span><br><span class="line">        os &lt;&lt; (Singer) singerWaiter &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; singerWaiter.cost;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SingerWaiter <span class="title">singerWaiter</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;xiaoming&quot;</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; singerWaiter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，大概说的是，<code>Singer</code> 是一种 <code>Worker</code> ，<code>Waiter</code> 也是一种 <code>Waiter</code> ，<code>SingerWaiter</code> 是一种 <code>Singer</code> 同时也是一种 <code>Waiter</code> 。这样一来，就构成了一种封闭的继承关系，<code>SingerWaiter</code> 里面会有两个 <code>Worker</code> 对象，这样一来，就会对整个的多态产生很大影响，造成二义性混乱。</p>
<p>为了解决这个问题，C++引入了<strong>虚基类</strong>概念，这使得多重继承成为可能😯 。</p>
<p><strong>虚基类：</strong> </p>
<blockquote>
<p>  虚基类使得从多个类（它们的基类相同）派生出的对象，只继承一个基类对象。</p>
</blockquote>
<p>用法就如 <code>Singer</code> 和 <code>Waiter</code> 类声明一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，对 <code>SingerWaiter</code> 的声明可以是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingerWaiter</span> :</span> <span class="keyword">public</span> Waiter, <span class="keyword">public</span> Singer &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>那么此时 <code>SingerWaiter</code> 对象内部只会存在一个 <code>Worker</code> 对象。也就是说 <code>Singer</code> 和 <code>Waiter</code> 将会共享一个 <code>Worker</code> 对象，而不是各自携带一个。</p>
<p>现在解决了对象模型问题，那么该怎样使用构造函数呢？</p>
<p>在一般情况下，构造函数的参数会传递，直到构造完所有的基类，但是在虚基类中这个规则被打破了。</p>
<p><strong>显式调用基类的构造方法</strong> 是解决这个问题的方法，例如上面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Singer(<span class="keyword">int</span> v, <span class="keyword">int</span> id, <span class="keyword">const</span> <span class="built_in">string</span> &amp;name) : Worker(name, id), voice(v) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在一般情况下，传递给 <code>Singer</code> 的 <code>id</code> 也会传递给 <code>Worker</code> 的构造函数，但是现在不会了，因此如果这样声明 <code>SingerWaiter</code> 类的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SingerWaiter(<span class="keyword">int</span> c, <span class="keyword">int</span> v, <span class="keyword">int</span> p, <span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">int</span> id) :</span><br><span class="line">    Singer(v, id, name), Waiter(p, id, name), cost(c) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>那么打印出来 <code>SingerWaiter</code> 对象将会是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SingerWaiter <span class="title">singerWaiter</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;xiaoming&quot;</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; singerWaiter &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//&gt;: 0 - non-name 2 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见并没有使用 <code>&quot;xiaoming&quot;</code> 和 <code>4</code> 来构造 <code>Worker</code> 对象。如果改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SingerWaiter(<span class="keyword">int</span> c, <span class="keyword">int</span> v, <span class="keyword">int</span> p, <span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">int</span> id) :</span><br><span class="line">    Worker(name, id), Singer(v, id, name), Waiter(p, id, name), cost(c) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>那么结果将会大不同~这个时候打印出来是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SingerWaiter <span class="title">singerWaiter</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;xiaoming&quot;</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; singerWaiter &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//&gt; 4 - xiaoming 2 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可知参数成功传递到了 <code>Worker</code> 对象~😮😮😮</p>
<p>我想，它之所以这样做，是为了防止在原有的参数传递过程中产生<strong>值的覆盖</strong>问题吧。</p>
<blockquote>
<p>  如果类有间接虚基类，一般需要显式调用该虚基类的某个构造函数。</p>
</blockquote>
<h2 id="4-1-多态使用哪一个方法？"><a href="#4-1-多态使用哪一个方法？" class="headerlink" title="4.1 多态使用哪一个方法？"></a>4.1 多态使用哪一个方法？</h2><p>麻烦结束了嘛🥱？还早着呢😮😥😣，还是上面的例子，不过多了一个 <code>show()</code> 方法，忽略掉其他不重要的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;worker &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; show&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Waiter &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Singer &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingerWaiter</span> :</span> <span class="keyword">public</span> Waiter, <span class="keyword">public</span> Singer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;SingerWaiter &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SingerWaiter <span class="title">singerWaiter</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;xiaoming&quot;</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; singerWaiter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    singerWaiter.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于单继承，如果派生类里面没有定义 <code>show()</code> 方法，会自动向上去使用最近祖先的 <code>show()</code> 方法，但是在这里由于多继承的原因，<code>singerWaiter</code> 同时找到了两个 <code>show()</code> 方法，那这个时候，就会产生二义性错误，编译是通不过滴~会产生以下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error: no unique final overrider <span class="keyword">for</span> <span class="string">&#x27;virtual void Worker::show() const&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;SingerWaiter&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这个问题可以直接使用 <code>Singer::show();</code> 这样的方法去解决，简而言之就是：指定一个“基类”，我就要使用它的方法，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Singer::show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SingerWaiter <span class="title">singerWaiter</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;xiaoming&quot;</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    singerWaiter.show(); <span class="comment">// &gt;: Singer 4 - xiaoming 2 show</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然这个仅仅是在派生类中没有重写实现的时候这样做，如果重写了实现，那么就没必要大费周章了，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;SingerWaiter &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; show&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SingerWaiter <span class="title">singerWaiter</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;xiaoming&quot;</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    singerWaiter.show(); <span class="comment">// &gt;: SingerWaiter 4 - xiaoming 2 1 show</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>正如所见，C++还是有点东西的😫。希望某一天早晨起来意外之喜，得到一目十行过目不忘的技能吧🥺</p>
<p>好啦~正好写完~正好到了吃饭的点！</p>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>软考（软件设计师）部分知识点总结</title>
    <url>/2020/11/04/%E8%BD%AF%E8%80%83%EF%BC%88%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%EF%BC%89%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>该文档总结了软考前的一些重要知识点。</p>
<a id="more"></a>
<h2 id="文件系统多级索引怎么算文件最大长度？"><a href="#文件系统多级索引怎么算文件最大长度？" class="headerlink" title="文件系统多级索引怎么算文件最大长度？"></a>文件系统多级索引怎么算文件最大长度？</h2><p>首先计算每一个磁盘块可以有表示多少个块，假设可以保存 <code>n</code> 个，那么就好办了，二级索引可以保存：<code>n * n * 单个磁盘块大小</code>。</p>
<h2 id="入侵检测技术有哪些？"><a href="#入侵检测技术有哪些？" class="headerlink" title="入侵检测技术有哪些？"></a>入侵检测技术有哪些？</h2><p>专家系统，模型检测，简单匹配。</p>
<h2 id="被动攻击的形式？"><a href="#被动攻击的形式？" class="headerlink" title="被动攻击的形式？"></a>被动攻击的形式？</h2><p>信息搜集，例如：系统干涉，流量分析。</p>
<h2 id="那么主动攻击的形式？"><a href="#那么主动攻击的形式？" class="headerlink" title="那么主动攻击的形式？"></a>那么主动攻击的形式？</h2><p>主动攻击是指通过一系列的方法，主动向被攻击对象实施破坏的一种攻击方式，例如重放攻击、IP地址欺骗、拒绝服务攻击等均属于攻击者主动向攻击对象发起破坏性攻击的方式。</p>
<h2 id="采用什么控制技术可以让CPU可以与外设并行工作？"><a href="#采用什么控制技术可以让CPU可以与外设并行工作？" class="headerlink" title="采用什么控制技术可以让CPU可以与外设并行工作？"></a>采用什么控制技术可以让CPU可以与外设并行工作？</h2><p>中断方式和DMA方式，而且DMA方式不需要CPU执行程序指令来传送数据。</p>
<h2 id="配置管理的内容？"><a href="#配置管理的内容？" class="headerlink" title="配置管理的内容？"></a>配置管理的内容？</h2><p>版本控制，变更控制，配置控制，配置审计，状态报告。</p>
<h2 id="极限编程XP的一些内容？"><a href="#极限编程XP的一些内容？" class="headerlink" title="极限编程XP的一些内容？"></a>极限编程XP的一些内容？</h2><ul>
<li>四大价值观：沟通，简单，反馈，勇气。</li>
<li>五大原则：快速反馈，简单性假设，逐步修改，提倡更改，优质工作。</li>
<li>十二个最佳实践：计划游戏，小型发布，隐喻，简单设计，测试先行，重构，结对编程，集体代码所有制，持续集成，每周工作40小时，现场客户，编码标准。</li>
</ul>
<h2 id="敏捷方法？"><a href="#敏捷方法？" class="headerlink" title="敏捷方法？"></a>敏捷方法？</h2><p>极限编程（轻量高效低风险柔性可预测），水晶法（每一个项目需要一个不同的策略约定和方法），并列争球法（Scrum，30天一个小冲刺），自适应软件开发（ASD，6个基本原则），敏捷统一过程（AUP，大型上连续，小型上迭代）。</p>
<h2 id="怎样判断达到了哪一个规范化程度？"><a href="#怎样判断达到了哪一个规范化程度？" class="headerlink" title="怎样判断达到了哪一个规范化程度？"></a>怎样判断达到了哪一个规范化程度？</h2><ul>
<li>第一范式：元组中每一个元素均不可再分。</li>
<li>第二范式：元组中每一个元素都依赖于主属性。</li>
<li>第三范式：没有传递依赖。</li>
</ul>
<h2 id="各种排序算法比较，以及适用场合？"><a href="#各种排序算法比较，以及适用场合？" class="headerlink" title="各种排序算法比较，以及适用场合？"></a>各种排序算法比较，以及适用场合？</h2><p><img data-src="https://s1.ax1x.com/2020/11/06/BhsNh6.jpg" alt="排序算法"></p>
<ul>
<li><p>如果数据规模小，那么使用插入排序或者选择排序。</p>
</li>
<li><p>如果数据基本有序，那么插入、冒泡都很好。</p>
</li>
<li>如果数据规模大，那么使用快速排序、堆排序、归并排序都很好。</li>
</ul>
<h2 id="内聚从高到低？"><a href="#内聚从高到低？" class="headerlink" title="内聚从高到低？"></a>内聚从高到低？</h2><p>功能、顺序、通信、过程、时间、逻辑、偶然。</p>
<h2 id="耦合从低到高？"><a href="#耦合从低到高？" class="headerlink" title="耦合从低到高？"></a>耦合从低到高？</h2><p>无直接、数据、标记、控制、外部、公共、内容。</p>
<h2 id="关联，聚集，组合，依赖？"><a href="#关联，聚集，组合，依赖？" class="headerlink" title="关联，聚集，组合，依赖？"></a>关联，聚集，组合，依赖？</h2><ul>
<li>关联：实线。</li>
<li>聚集：实线+空心棱形，成员可以脱离整体存在。</li>
<li>组合：实线+实心棱形，生死与共的关系。</li>
<li>依赖：虚线，一个变化会影响另一个。</li>
<li>泛化：实线+空心箭头。</li>
<li>实线：虚线+空心箭头。</li>
</ul>
<h2 id="设计模式分类？"><a href="#设计模式分类？" class="headerlink" title="设计模式分类？"></a>设计模式分类？</h2><p>创建型：抽象工厂，工厂方法，建造器，单例，原型</p>
<p>结构型：适配器，组合，装饰器，享元，桥接，外观，代理</p>
<p>行为型：访问者，责任链，命令，解释器，迭代器，中介者，备忘录，观察者，状态，策略，模板方法</p>
<h2 id="网络各层设备及协议？"><a href="#网络各层设备及协议？" class="headerlink" title="网络各层设备及协议？"></a>网络各层设备及协议？</h2><p><img data-src="https://s1.ax1x.com/2020/11/04/BgRcL9.jpg" alt=""></p>
<h2 id="各种服务占用的端口号？"><a href="#各种服务占用的端口号？" class="headerlink" title="各种服务占用的端口号？"></a>各种服务占用的端口号？</h2><ul>
<li>FTP：21</li>
<li>Telnet：23</li>
<li>SSH：22</li>
<li>POP3：110，SMTP：25</li>
<li>MySQL：3306</li>
<li>HTTP：80，HTTPS：443</li>
<li>DNS：53</li>
<li>SNMP：161</li>
</ul>
<h2 id="结构化分析与设计-amp-面向对象分析与设计？"><a href="#结构化分析与设计-amp-面向对象分析与设计？" class="headerlink" title="结构化分析与设计&amp;面向对象分析与设计？"></a>结构化分析与设计&amp;面向对象分析与设计？</h2><ul>
<li>结构化分析与设计：<ul>
<li>数据流图，数据字典，加工逻辑说明，补充材料。</li>
</ul>
</li>
<li>面向对象分析与设计：<ul>
<li>对象+分类+继承+通过消息的通信。</li>
<li>认定对象，组织对象，描述对象之间的作用，确定对象的操作，定义对象内部信息。</li>
<li>原则：里氏替换，单一责任，开放封闭，依赖倒置，接口分离。</li>
</ul>
</li>
</ul>
<h2 id="概要设计和详细设计？"><a href="#概要设计和详细设计？" class="headerlink" title="概要设计和详细设计？"></a>概要设计和详细设计？</h2><ul>
<li>概要设计：软件总体结构，数据结构和数据库设计，编写文档，评审。</li>
<li>详细设计：算法设计，对模块内的数据结构设计，数据库物理设计，说明书，评审。</li>
</ul>
<h2 id="结构化分析方法中的一些细节？"><a href="#结构化分析方法中的一些细节？" class="headerlink" title="结构化分析方法中的一些细节？"></a>结构化分析方法中的一些细节？</h2><ul>
<li>数据设计：数据库设计。</li>
<li>接口设计：模块内交互和调用。</li>
<li>过程设计：数据结构和算法设计。</li>
</ul>
<h2 id="如果路由器收到了多个路由协议转发的关于某个目标的多条路由，那么决定采用哪条路由的策略是？"><a href="#如果路由器收到了多个路由协议转发的关于某个目标的多条路由，那么决定采用哪条路由的策略是？" class="headerlink" title="如果路由器收到了多个路由协议转发的关于某个目标的多条路由，那么决定采用哪条路由的策略是？"></a>如果路由器收到了多个路由协议转发的关于某个目标的多条路由，那么决定采用哪条路由的策略是？</h2><p>比较各个路由的管理距离。</p>
<h2 id="IP地址划分？"><a href="#IP地址划分？" class="headerlink" title="IP地址划分？"></a>IP地址划分？</h2><p>全0代表网络地址，全1代表组播地址。</p>
<h2 id="在程序运行过程中，CPU需要将指令从内存中取出来并加以分析和执行，CPU依据（什么）来区分在内存中以二进制编码形式存放的指令和数据？"><a href="#在程序运行过程中，CPU需要将指令从内存中取出来并加以分析和执行，CPU依据（什么）来区分在内存中以二进制编码形式存放的指令和数据？" class="headerlink" title="在程序运行过程中，CPU需要将指令从内存中取出来并加以分析和执行，CPU依据（什么）来区分在内存中以二进制编码形式存放的指令和数据？"></a>在程序运行过程中，CPU需要将指令从内存中取出来并加以分析和执行，CPU依据（什么）来区分在内存中以二进制编码形式存放的指令和数据？</h2><p>指令周期的不同阶段。</p>
<h2 id="人耳能听到的声音频率范围？人声音的频率范围？"><a href="#人耳能听到的声音频率范围？人声音的频率范围？" class="headerlink" title="人耳能听到的声音频率范围？人声音的频率范围？"></a>人耳能听到的声音频率范围？人声音的频率范围？</h2><p>人耳：20HZ - 20KHZ</p>
<p>人声：300HZ - 3400KHZ</p>
<h2 id="不是每个编译器必须要做的工作是？"><a href="#不是每个编译器必须要做的工作是？" class="headerlink" title="不是每个编译器必须要做的工作是？"></a>不是每个编译器必须要做的工作是？</h2><p>中间代码生成和代码优化。</p>
<h2 id="同一个进程中的线程什么可以共享，什么不可以？"><a href="#同一个进程中的线程什么可以共享，什么不可以？" class="headerlink" title="同一个进程中的线程什么可以共享，什么不可以？"></a>同一个进程中的线程什么可以共享，什么不可以？</h2><p>在同一进程中的各个线程都可以共享该进程所拥有的资源，如访问进程地址空间中的每一个虚地址；访问进程所拥有的已打开文件、定时器、信号量机构等，但是不能共享进程中某线程的栈指针。</p>
<h2 id="重载，重置，继承？"><a href="#重载，重置，继承？" class="headerlink" title="重载，重置，继承？"></a>重载，重置，继承？</h2><ul>
<li><p>重载：使用同一个函数名，提供不同的参数列表。</p>
</li>
<li><p>重置：对基类中的函数进行重新实现。</p>
</li>
<li>继承：父类中出现的函数，在子类中没有再次出现。</li>
</ul>
<h2 id="分片透明，逻辑透明，位置透明，复制透明？"><a href="#分片透明，逻辑透明，位置透明，复制透明？" class="headerlink" title="分片透明，逻辑透明，位置透明，复制透明？"></a>分片透明，逻辑透明，位置透明，复制透明？</h2><ul>
<li>分片透明是指用户或应用程序不需要知道逻辑上访问的表具体是怎么分块存储的。</li>
<li>复制透明是指采用复制技术的分布方法，用户不需要知道数据是复制到哪些节点，如何复制的。</li>
<li>位置透明是指用户无须知道数据存放的物理位置。</li>
<li>逻辑透明，即局部数据模型透明，是指用户或应用程序无须知道局部场地使用的是哪种数据模型。</li>
</ul>
<h2 id="TCP使用的流量控制协议是？"><a href="#TCP使用的流量控制协议是？" class="headerlink" title="TCP使用的流量控制协议是？"></a>TCP使用的流量控制协议是？</h2><p>可变大小的滑动窗口协议。</p>
<h2 id="主机路由的默认子网掩码是？"><a href="#主机路由的默认子网掩码是？" class="headerlink" title="主机路由的默认子网掩码是？"></a>主机路由的默认子网掩码是？</h2><p>255.255.255.255</p>
<p>那么默认路由（静态路由）的子网掩码默认是0.0.0.0</p>
<h2 id="在一段时间内，只允许一个进程访问的资源称为？"><a href="#在一段时间内，只允许一个进程访问的资源称为？" class="headerlink" title="在一段时间内，只允许一个进程访问的资源称为？"></a>在一段时间内，只允许一个进程访问的资源称为？</h2><p>临界资源。</p>
<h2 id="CPU繁忙型作业用什么调度算法比较好？"><a href="#CPU繁忙型作业用什么调度算法比较好？" class="headerlink" title="CPU繁忙型作业用什么调度算法比较好？"></a>CPU繁忙型作业用什么调度算法比较好？</h2><p>CPU繁忙型作业使用FCFS。</p>
<h2 id="进程间同步是指进程间在逻辑上的什么作用？"><a href="#进程间同步是指进程间在逻辑上的什么作用？" class="headerlink" title="进程间同步是指进程间在逻辑上的什么作用？"></a>进程间同步是指进程间在逻辑上的什么作用？</h2><p>相互制约作用。</p>
<h2 id="设备与CPU之间数据传送控制有四种，分别是？"><a href="#设备与CPU之间数据传送控制有四种，分别是？" class="headerlink" title="设备与CPU之间数据传送控制有四种，分别是？"></a>设备与CPU之间数据传送控制有四种，分别是？</h2><p>直接内存访问（DMA），程序直接控制，中断控制，通道控制。</p>
<h2 id="进程的基本特性？"><a href="#进程的基本特性？" class="headerlink" title="进程的基本特性？"></a>进程的基本特性？</h2><p>动态性，并发性，独立性，异步性，结构特征。</p>
<h2 id="各种开发模式适用的场合？"><a href="#各种开发模式适用的场合？" class="headerlink" title="各种开发模式适用的场合？"></a>各种开发模式适用的场合？</h2><ul>
<li>瀑布模型：非常明确的需求，严格的文档，评审。</li>
<li>喷泉模型：面向对象。</li>
<li>快速原型：需求不够明确，项目不是很大，“抛弃”式开发。</li>
<li>演化模型：渐进式开发。</li>
<li>螺旋模型：引入风险评估，大中型开发，融合了瀑布模型和演化模型。</li>
<li>统一过程：用例驱动，架构为中心和受控的迭代式增量开发。<ul>
<li>四个阶段：初始阶段，精化阶段，构建阶段，提交阶段。</li>
</ul>
</li>
</ul>
<h2 id="常见寻址方式？"><a href="#常见寻址方式？" class="headerlink" title="常见寻址方式？"></a>常见寻址方式？</h2><p>立即寻址，直接寻址，间接寻址，寄存器寻址，寄存器间接寻址，相对寻址，基址寻址，变址寻址。</p>
<h2 id="关系代数运算的符号和含义？"><a href="#关系代数运算的符号和含义？" class="headerlink" title="关系代数运算的符号和含义？"></a>关系代数运算的符号和含义？</h2><p><img data-src="https://s1.ax1x.com/2020/11/06/Bhcjv8.jpg" alt=""></p>
<h2 id="（数据库）事务所具有的特性？"><a href="#（数据库）事务所具有的特性？" class="headerlink" title="（数据库）事务所具有的特性？"></a>（数据库）事务所具有的特性？</h2><ul>
<li>原子性：数据库的逻辑工作单位。</li>
<li>一致性：使数据库从一个一致性状态变到另一个一致性状态。</li>
<li>隔离性：不能被其他事务干扰。</li>
<li>持久性：一旦提交，改变就是永久的。</li>
</ul>
<h2 id="网络管理五大功能？"><a href="#网络管理五大功能？" class="headerlink" title="网络管理五大功能？"></a>网络管理五大功能？</h2><p>配置管理，故障管理，计费管理，性能管理，安全管理。</p>
<h2 id="常见的交换机交换模式有？"><a href="#常见的交换机交换模式有？" class="headerlink" title="常见的交换机交换模式有？"></a>常见的交换机交换模式有？</h2><p>存储转发，快速转发，碎片丢弃。</p>
<hr>
<p>好运🥰🤩😘~</p>
]]></content>
      <categories>
        <category>初出茅庐</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>开发规范</tag>
        <tag>C/C++</tag>
        <tag>操作系统</tag>
        <tag>算法</tag>
        <tag>信息安全</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>【STL容器探索】vector</title>
    <url>/2020/11/14/STL%E5%AE%B9%E5%99%A8%E6%8E%A2%E7%B4%A2-vector/</url>
    <content><![CDATA[<p>用了这么久的 <code>vector</code> ，今天终于有时间来看下STL的实现源码了，开心😉~</p>
<a id="more"></a>
<p>最近几个月在刷 <code>leetcode</code> ，用的较多的数据结构就是STL里面的 <code>vector</code> 了，相比较于直接的 <code>array</code> 数组，它具备了灵活地根据需求去分配管理内存，用户只管往里面扔东西，拿东西，而不用费心费力去解决C++里面的动态内存问题。</p>
<p>那么大致猜想一下，要实现一个这样的容器，不难想出在 <code>vector</code> 中至少存在这样三个私有成员：<code>head（指向列表第一个元素位置）, tail（指向列表最后一个元素位置）, size（容器大小）</code> ，</p>
<p>打开源码看看，得到验证：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Vector_base</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Vector_impl_data</span> &#123;</span></span><br><span class="line">        pointer _M_start; 	<span class="comment">// 指向容器中的第一个元素，是一个指针，指针类型为 Tp 所示类型</span></span><br><span class="line">        pointer _M_finish;	<span class="comment">// 指向容器最后一个元素，也是一个指针</span></span><br><span class="line">        pointer _M_end_of_storage; <span class="comment">// 指向容器最后的位置</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">class <span class="built_in">vector</span> : <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Vector_base&lt;_Tp, _Alloc&gt; _Base; <span class="comment">// 如上 _Vector_base 所示，是一个基础实现</span></span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type; 	<span class="comment">// 数据类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::pointer pointer; <span class="comment">// 全局数据指针</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之就是一层套一层，封装了一个又一个，来完成对数据的抽象。但是最后的接口是放在 <code>vector</code> 上放开的。</p>
<p><code>vector</code> 支持动态内存分配，支持随机存取访问，因此在数据访问上具备了指针有的特性。那么它在源码上是怎么实现的呢？首先来看它的接口（一部分常用接口）都有哪些：</p>
<p><strong>注：</strong>虽然包含 <code>&lt;vector&gt;</code> 头文件就可以用 <code>vector</code> ，但是它的实现源码其实是在 <code>bits/stl_vector.h</code> 下的，而且下面的程序删掉了一些注释类、系统判断类函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">class <span class="built_in">vector</span> : <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取指向第一个元素的指针</span></span><br><span class="line">    iterator <span class="built_in">begin</span>() &#123; <span class="keyword">return</span> iterator(<span class="keyword">this</span>-&gt;_M_impl._M_start); &#125;</span><br><span class="line">    <span class="comment">// 获取指向容器最后一个可存放位置的下一个位置</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> iterator(<span class="keyword">this</span>-&gt;_M_impl._M_finish); &#125;</span><br><span class="line">    <span class="comment">// 获取容器当前存放了多少元素</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> size_type(<span class="keyword">this</span>-&gt;_M_impl._M_finish - <span class="keyword">this</span>-&gt;_M_impl._M_start); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对容器进行重新分配大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type __new_size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (__new_size &gt; <span class="built_in">size</span>())</span><br><span class="line">            _M_default_append(__new_size - <span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__new_size &lt; <span class="built_in">size</span>())</span><br><span class="line">            _M_erase_at_end(<span class="keyword">this</span>-&gt;_M_impl._M_start + __new_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取容器自身大小</span></span><br><span class="line">    <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size_type(<span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage</span><br><span class="line">                         - <span class="keyword">this</span>-&gt;_M_impl._M_start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看看容器当前是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line">    <span class="comment">// 获取一个能够对返回对象读写操作的引用类型，其实就是指针</span></span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type __n)  &#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 检查访问是否合法</span></span><br><span class="line">    <span class="keyword">void</span> _M_range_check(size_type __n) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (__n &gt;= <span class="keyword">this</span>-&gt;<span class="built_in">size</span>())</span><br><span class="line">            __throw_out_of_range_fmt(__N(<span class="string">&quot;vector::_M_range_check: __n &quot;</span></span><br><span class="line">                                         <span class="string">&quot;(which is %zu) &gt;= this-&gt;size() &quot;</span></span><br><span class="line">                                         <span class="string">&quot;(which is %zu)&quot;</span>),</span><br><span class="line">                                     __n, <span class="keyword">this</span>-&gt;<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 跟 [] 操作符差不多，只不过多了一层范围检查</span></span><br><span class="line">    <span class="function">reference <span class="title">at</span><span class="params">(size_type __n)</span> </span>&#123;</span><br><span class="line">        _M_range_check(__n);</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">this</span>)[__n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取能够对头部元素读写的指针</span></span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="comment">// 获取最后一个元素</span></span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">// 向容器末尾追加一个元素进来</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(value_type &amp;&amp;__x)</span> </span>&#123; emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(__x)); &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt; 201402L</span></span><br><span class="line">    reference</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">void</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    emplace_back(_Args &amp;&amp;... __args);</span><br><span class="line">    <span class="comment">// 将最后一个元素从容器中删掉</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        --<span class="keyword">this</span>-&gt;_M_impl._M_finish;</span><br><span class="line">        _Alloc_traits::destroy(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在指定位置插入 n 个 __x</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator __position, size_type __n, <span class="keyword">const</span> value_type &amp;__x)</span> </span>&#123;</span><br><span class="line">        difference_type __offset = __position - cbegin();</span><br><span class="line">        _M_fill_insert(<span class="built_in">begin</span>() + __offset, __n, __x);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() + __offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 擦除掉某一个位置上的元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator __position)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> _M_erase(<span class="built_in">begin</span>() + (__position - cbegin())); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换两个容器中的东西</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span> &amp;__x)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_M_impl._M_swap_data(__x._M_impl);</span><br><span class="line">        _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),</span><br><span class="line">                                  __x._M_get_Tp_allocator());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将容器内所有元素清空</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>  </span>&#123; _M_erase_at_end(<span class="keyword">this</span>-&gt;_M_impl._M_start); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>程序中大量出现的 <code>allocator</code> ，是来自SGI STL的空间分配器，说白了就是用来分配空间内存的。在拿到这部分源码后，<code>vector</code> 的实现原理也就可以大致有所掌握了（毕竟每个接口也不过几行🤗，这可能就是优秀设计的结果？😉）。而在调用过程中无非就是 <code>vector</code> 调用 <code>vector_base</code> 再调用 <code>allocator</code> 再对 <code>_Vector_impl_data</code> 进行操作。</p>
<p>还有一个问题：在添加元素过程中，如果容器满了，那么容器的容量是按照怎样的规则递增呢？参考了《STL源码刨析》之后，得到这样的结论：</p>
<blockquote>
<p>  如果超过当前容器容量，那么容量会扩增至两倍，如果两倍容量仍不够，那么就扩张至足够大的容量。</p>
<p>  在容量的扩张过程中，必须经历“重新分配内存，元素移动，释放原有空间”三个操作，这是因为原有的空间之后不一定能够满足需求，所以统一进行这三个操作来完成。</p>
</blockquote>
<p>如何知道是扩增两倍的呢？最直观直接的方法就是执行一下这个过程看看，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// &gt;: 1 1</span></span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// &gt;: 2 2</span></span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// &gt;: 3 4</span></span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// &gt;: 4 4</span></span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// &gt;: 5 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的容量扩张过程，也带来另一个问题：当容量为 <code>2</code> 时获取到的 <code>iterator</code> ，那么在容量为 <code>8</code> 时，还可以用嘛？答案是<strong>不一定行</strong>，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">auto</span> iter = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 1</span></span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 1</span></span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 310076128[具体运行结果视内存情况而定]</span></span><br><span class="line">    iter = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &gt;: 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>由此可知，如果当时的内存环境允许，会直接拼到原有容器后面去，如果不允许，那么就需要把当前容器的内容移动到其他地方去了，这时候原来的</strong> <code>iterator</code> <strong>就不能用了。务必小心！</strong></p>
<p>从这一方面也可以体会到，其实 <code>iterator</code> 就是一个类型为传入 <code>vector&lt;T&gt;</code> 中 <code>T</code> 类型的指针。</p>
<p>在所有的接口中，觉得最有意思的就是 <code>insert</code> 接口了😍，它的实现过程比较好玩。</p>
<p>首先，假设调用函数为：<code>insert(position, n, x)</code> ，而且剩余空间够用，那么它需要分成两种情况：</p>
<ol>
<li>插入元素个数 <strong>n &lt; 插入点之后的元素个数</strong> 。</li>
<li>插入元素个数 <strong>n &gt; 插入点之后的元素个数</strong> 。</li>
</ol>
<p>上面两种情况分别对应下面图中的左右两边：</p>
<p><img data-src="https://s3.ax1x.com/2020/11/14/DPVQnU.jpg" alt="内存操作示意图（参考自《STL源码刨析》）"></p>
<p>在有限的过程和空间里实现最高效的操作，不愧是STL🙂🙂🙂。</p>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>源码分析</tag>
        <tag>STL</tag>
        <tag>容器</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>堆数据结构</title>
    <url>/2020/11/21/%E5%A0%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>印象中总是觉得 <code>heap</code> 数据结构是在STL中的一个标准组件🤔，想了解学习一下STL又是以怎样一种巧妙充满设计感的方法😲来完成的，但迟迟没有找到它到底在哪里放着🤔，随着时间推移也就对其不了了之😌🥱😴。今天才发现它并不是😮，它没有以模板类的方式提供接口，但是却以另外一种更加通用和便携的方式展现其算法精髓。</p>
<hr>
<p>今天吃的鱼摆摆针不戳~🐟🦈🐬🐳🐋。</p>
<hr>
<a id="more"></a>
<p><strong>以下正文：</strong></p>
<p>其实在<a href="https://mp.weixin.qq.com/s/ZshY9tIUchV-1mabYOcgZQ">优先级队列</a>（ <code>priority_queue</code> ）中已经用到它了，这个容器允许用户以任意顺序放入容器内，但是取出来的时候，一定会把最高优先级的元素先取出来。这里它用到的是 <code>binary-max-heap</code> 作为 <code>priority_queue</code> 的底层特性。</p>
<p>在底层表示上，<code>binary-max-heap</code> 就是一个完全二叉树，而且使用一个一维数组来来表示。除此之外，它将第一个位置保留下来不使用，这样就可以保证之后的子节点和父节点有这样的关系：</p>
<ul>
<li>子节点 $i$ 的父节点一定是 $2 * i$</li>
<li>父节点 $i$ 的左子节点一定是 $i / 2$，右子节点一定是 $i / 2 + 1$</li>
</ul>
<p>这么一来，就方便多了😉。</p>
<p>解决了节点索引问题，还有一个问题是存储问题，由于 <code>heap</code> 是支持动态插入删除元素的，所以最好是用 <code>vector</code> 来作为底层数据结构。</p>
<p>除此之外，<code>heap</code> 是有两种格式的，一种是大根堆（max-heap），另一种是小根堆（min-heap），前者意味着堆中最大元素在根节点上，每一棵子树的根节点是要大于它的左右子节点的，后者恰恰相反。在STL中默认提供的是大根堆，也就是优先级（或者代表优先级最高的键值）最大的在根节点上。</p>
<h1 id="1-heap-算法"><a href="#1-heap-算法" class="headerlink" title="1. heap 算法"></a>1. heap 算法</h1><p>以下均假设 <code>heap</code> 使用 <code>vector</code> 来存储元素，而且第一个位置不用。</p>
<h2 id="1-1-push-heap-算法"><a href="#1-1-push-heap-算法" class="headerlink" title="1.1 push-heap 算法"></a>1.1 <code>push-heap</code> 算法</h2><p>简而言之：先把元素放到 <code>vector</code> 末尾 <code>v.end()</code>，然后向上调整，执行<strong>上溯程序</strong>：</p>
<blockquote>
<p>  将新节点拿来与其父节点比较，如果其优先级比父元素大，那么就调换两者位置，如此反复直到根节点或者不用再调。</p>
</blockquote>
<p>具体源码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个实现中，不支持自定义比较函数，直接使用预定义的比较函数 cmp</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type</span><br><span class="line">            _ValueType;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::difference_type</span><br><span class="line">            _DistanceType;</span><br><span class="line">    <span class="comment">// 比较函数，见下文</span></span><br><span class="line">    __gnu_cxx::__ops::_Iter_less_val __comp;</span><br><span class="line">    _ValueType __value = _GLIBCXX_MOVE(*(__last - <span class="number">1</span>)); <span class="comment">// 先取出来最后一个元素</span></span><br><span class="line">    <span class="built_in">std</span>::__push_heap(__first, _DistanceType((__last - __first) - <span class="number">1</span>),</span><br><span class="line">                     _DistanceType(<span class="number">0</span>), _GLIBCXX_MOVE(__value), __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个实现中，支持了自定义比较函数 cmp</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">          _Compare __comp) &#123;</span><br><span class="line">    <span class="comment">// 定义了一堆有的没的，忽略并不妨碍理解下文</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type _ValueType;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::difference_type _DistanceType;</span><br><span class="line">    <span class="comment">// 找到比较函数并引入进来</span></span><br><span class="line">    __decltype(__gnu_cxx::__ops::__iter_comp_val(_GLIBCXX_MOVE(__comp)))</span><br><span class="line">    __cmp(_GLIBCXX_MOVE(__comp));</span><br><span class="line">    <span class="comment">// 获取最后的那个值</span></span><br><span class="line">    _ValueType __value = _GLIBCXX_MOVE(*(__last - <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::__push_heap(__first, _DistanceType((__last - __first) - <span class="number">1</span>),</span><br><span class="line">                     _DistanceType(<span class="number">0</span>), _GLIBCXX_MOVE(__value), __cmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在阅读过程中，可以看到有好多个 <code>cmp</code> ，从字面上不难理解是一个用来比较的函数 <code>compare</code> ，它的定义在 <code>predefined_ops.h</code> 中，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Iter_less_iter</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iterator1, <span class="keyword">typename</span> _Iterator2&gt;</span><br><span class="line">    <span class="comment">// 比较函数，因为是 &lt; 所以最终排序结果会是从大到小</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Iterator1 __it1, _Iterator2 __it2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *__it1 &lt; *__it2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再回到上面的具体实现中去，它们在最后都调用了一个 <code>__push_heap()</code> 的函数，这个函数是真正完成入堆操作的函数，之所以写成这样就是为了隐藏接口，它的具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真正完成操作的函数，提供给下面两个 push_heap 来调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Distance, <span class="keyword">typename</span> _Tp,</span><br><span class="line">        <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__push_heap(_RandomAccessIterator __first,</span><br><span class="line">            _Distance __holeIndex, _Distance __topIndex, _Tp __value,</span><br><span class="line">            _Compare &amp;__comp) &#123;</span><br><span class="line">    <span class="comment">// 找到父节点位置</span></span><br><span class="line">    _Distance __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 如果当前节点还没到顶点处，而且元素比较结果仍不符合要求（优先级大的在下面）</span></span><br><span class="line">    <span class="keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; __comp(__first + __parent, __value)) &#123;</span><br><span class="line">        <span class="comment">// 调整父节点和当前子节点的元素内容</span></span><br><span class="line">        *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __parent));</span><br><span class="line">        __holeIndex = __parent;</span><br><span class="line">        __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了元素的位置，然后放下来</span></span><br><span class="line">    *(__first + __holeIndex) = _GLIBCXX_MOVE(__value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-pop-heap-算法"><a href="#1-2-pop-heap-算法" class="headerlink" title="1.2 pop_heap 算法"></a>1.2 <code>pop_heap</code> 算法</h2><p>这个过程可就没有 <code>push_heap</code> 过程简单了。它先把根节点，也就是<code>vector</code> 中的第一个元素取走（其实是放到了末端），同时把最后一个元素取出来。然后执行<strong>下溯程序</strong>：</p>
<blockquote>
<p>  将空间节点和其较大子节点对调，并持续下放，直到叶子节点。</p>
</blockquote>
<p>这个过程完成的是把空出来的第一个位置填充上合适的根节点。</p>
<p>执行完之后，再执行<strong>上溯程序</strong>，这个过程完成的是把之前取出来的最后一个元素放回到合适的位置去。</p>
<p>下面是它的实现细节：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) &#123;</span><br><span class="line">    <span class="comment">// 删掉了一些并不影响阅读的程序</span></span><br><span class="line">    <span class="keyword">if</span> (__last - __first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 首先，缩减空间指示器</span></span><br><span class="line">        --__last;</span><br><span class="line">        <span class="comment">// 然后，导入默认的比较函数，见上文</span></span><br><span class="line">        __gnu_cxx::__ops::_Iter_less_iter __comp;</span><br><span class="line">        <span class="comment">// 调用真正的入堆函数</span></span><br><span class="line">        <span class="built_in">std</span>::__pop_heap(__first, __last, __last, __comp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">pop_heap(_RandomAccessIterator __first,</span><br><span class="line">         _RandomAccessIterator __last, _Compare __comp) &#123;</span><br><span class="line">    <span class="comment">// 还是删掉了一些并不影响阅读的程序</span></span><br><span class="line">    <span class="keyword">if</span> (__last - __first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 引入进来比较函数，用户自定义的噢~</span></span><br><span class="line">        <span class="keyword">typedef</span> __decltype(__comp)</span><br><span class="line">        _Cmp;</span><br><span class="line">        __gnu_cxx::__ops::_Iter_comp_iter&lt;_Cmp&gt; __cmp(_GLIBCXX_MOVE(__comp));</span><br><span class="line">        <span class="comment">// 缩减空间指示器</span></span><br><span class="line">        --__last;</span><br><span class="line">        <span class="comment">// 放到堆里</span></span><br><span class="line">        <span class="built_in">std</span>::__pop_heap(__first, __last, __last, __cmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实看到 <code>__pop_heap()</code> ，不难猜测和 <code>push_heap()</code> 一样的操作：定义了一个“秘密”但“真正”完成把元素放到堆里面的操作。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">           _RandomAccessIterator __result, _Compare &amp;__comp) &#123;</span><br><span class="line">    <span class="comment">// 定义了一些无关紧要的程序，不看并不影响阅读</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type _ValueType;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::difference_type _DistanceType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出来末尾值（__last == __result）</span></span><br><span class="line">    _ValueType __value = _GLIBCXX_MOVE(*__result);</span><br><span class="line">    <span class="comment">// 然后把末尾值置成首部值</span></span><br><span class="line">    *__result = _GLIBCXX_MOVE(*__first);</span><br><span class="line">    <span class="comment">// 此时堆头已经不再是最小值了，而是最初的末尾值，所以需要调整整个堆</span></span><br><span class="line">    <span class="built_in">std</span>::__adjust_heap(__first, _DistanceType(<span class="number">0</span>),</span><br><span class="line">                       _DistanceType(__last - __first),</span><br><span class="line">                       _GLIBCXX_MOVE(__value), __comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，就又犯愁了😣，这个 <code>__adjust_heap()</code> 函数是个什么东东？这个 <code>__adjust_heap()</code> 函数就是用来调整整个堆的函数，完成了<strong>上溯</strong>和<strong>下溯</strong>操作，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Distance,</span><br><span class="line">        <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,</span><br><span class="line">              _Distance __len, _Tp __value, _Compare __comp) &#123;</span><br><span class="line">    <span class="keyword">const</span> _Distance __topIndex = __holeIndex;   <span class="comment">// 记下来洞节点所指向的节点</span></span><br><span class="line">    _Distance __secondChild = __holeIndex;      <span class="comment">// 用来指向洞节点右边的节点</span></span><br><span class="line">    <span class="keyword">while</span> (__secondChild &lt; (__len - <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 找出新洞节点的右节点</span></span><br><span class="line">        __secondChild = <span class="number">2</span> * (__secondChild + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 比较一下洞节点左右两边的值，然后用 __secondChild 指向较大的值</span></span><br><span class="line">        <span class="keyword">if</span> (__comp(__first + __secondChild, __first + (__secondChild - <span class="number">1</span>))) __secondChild--;</span><br><span class="line">        <span class="comment">// 下溯过程，更新洞节点的值，使之成为较大值</span></span><br><span class="line">        *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __secondChild));</span><br><span class="line">        <span class="comment">// 然后再把洞号下移到较大节点处</span></span><br><span class="line">        __holeIndex = __secondChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有右子节点，只有左子节点</span></span><br><span class="line">    <span class="keyword">if</span> ((__len &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; __secondChild == (__len - <span class="number">2</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        __secondChild = <span class="number">2</span> * (__secondChild + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 让左子节点位洞值，然后再让洞号下移到左子节点处</span></span><br><span class="line">        *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + (__secondChild - <span class="number">1</span>)));</span><br><span class="line">        __holeIndex = __secondChild - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 导入比较函数之类的杂七杂八</span></span><br><span class="line">    __decltype(__gnu_cxx::__ops::__iter_comp_val(_GLIBCXX_MOVE(__comp)))</span><br><span class="line">    __cmp(_GLIBCXX_MOVE(__comp));</span><br><span class="line">    <span class="comment">// 再进行一次上溯操作</span></span><br><span class="line">    <span class="built_in">std</span>::__push_heap(__first, __holeIndex, __topIndex, _GLIBCXX_MOVE(__value), __cmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实整个删除堆顶元素的操作到此就结束了，但是！回过头来看看，其实该元素并没有真正被删除掉，而是放在堆的末尾继续存在着，需要人为进行删除，验证如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    make_heap(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iv &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 9 5 8 3 4 0 2 3 1</span></span><br><span class="line">    pop_heap(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iv.back() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 9</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iv &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8 7 4 3 5 0 2 3 1 【9】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么这样？为什么不直接删除掉释放空间？请继续看下面的 <code>sort_heap</code> 算法。</p>
<h2 id="1-3-sort-heap-算法"><a href="#1-3-sort-heap-算法" class="headerlink" title="1.3 sort_heap 算法"></a>1.3 <code>sort_heap</code> 算法</h2><p>结合 <code>pop_heap</code> 算法不难看出，每一次的 <code>pop_heap</code> 操作都会把当前堆的最大值扔到 <code>vector</code> 容器尾部去，那么可以这样考虑：持续对整个 <code>heap</code> 进行 <code>pop_heap</code> 操作，那么每次将操作范围从后向前可以缩减一个元素，当该过程执行完后，就可以得到一个有序序列，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    make_heap(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>());</span><br><span class="line">    sort_heap(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iv &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0 1 2 3 3 4 5 7 8 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看是怎样实现的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &amp;__comp) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__last - __first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 不停地去 pop_heap ，同时要把末尾指针不断前移</span></span><br><span class="line">        --__last;</span><br><span class="line">        <span class="built_in">std</span>::__pop_heap(__first, __last, __last, __comp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) &#123;</span><br><span class="line">    <span class="comment">// 删掉了一些对理解整个程序无关紧要的检查程序</span></span><br><span class="line">    __gnu_cxx::__ops::_Iter_less_iter __comp;</span><br><span class="line">    <span class="built_in">std</span>::__sort_heap(__first, __last, __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) &#123;</span><br><span class="line">    <span class="comment">// 我又删掉了一些对理解整个程序无关紧要的检查程序</span></span><br><span class="line">    <span class="keyword">typedef</span> __decltype(__comp)    _Cmp;</span><br><span class="line">    __gnu_cxx::__ops::_Iter_comp_iter&lt;_Cmp&gt; __cmp(_GLIBCXX_MOVE(__comp));</span><br><span class="line">    <span class="built_in">std</span>::__sort_heap(__first, __last, __cmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单明了，就是 “不停地去 pop_heap ，同时要把末尾指针不断前移”😝。</p>
<h2 id="1-4-make-heap-算法"><a href="#1-4-make-heap-算法" class="headerlink" title="1.4 make_heap 算法"></a>1.4 <code>make_heap</code> 算法</h2><p>将一个现有数据转换成一个 <code>heap</code> ，其主要依据就是完全二叉树的隐式表述。具体算法实现细节如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line"><span class="keyword">void</span> __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &amp;__comp) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type _ValueType;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::difference_type _DistanceType;</span><br><span class="line">    <span class="comment">// 如果整个序列大小都不足 2，那排它干啥？😐</span></span><br><span class="line">    <span class="keyword">if</span> (__last - __first &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 记录下来需要操作的范围</span></span><br><span class="line">    <span class="keyword">const</span> _DistanceType __len = __last - __first;</span><br><span class="line">    <span class="comment">// 找到末尾元素的父节点</span></span><br><span class="line">    _DistanceType __parent = (__len - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 重新排布以 parent 为首的子树，</span></span><br><span class="line">        _ValueType __value = _GLIBCXX_MOVE(*(__first + __parent));</span><br><span class="line">        <span class="built_in">std</span>::__adjust_heap(__first, __parent, __len, _GLIBCXX_MOVE(__value), __comp</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 如果走完了根节点，那么就结束返回</span></span><br><span class="line">        <span class="keyword">if</span> (__parent == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 已经拍好序的子树头向前移动一个指针</span></span><br><span class="line">        __parent--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-一些例子"><a href="#2-一些例子" class="headerlink" title="2. 一些例子"></a>2. 一些例子</h1><p>简单明了，看看就好😉</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/11/21.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/11/21 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) os &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    make_heap(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iv &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 9 5 8 3 4 0 2 3 1</span></span><br><span class="line"></span><br><span class="line">    iv.push_back(<span class="number">7</span>);</span><br><span class="line">    push_heap(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iv &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 9 7 8 3 5 0 2 3 1 4</span></span><br><span class="line"></span><br><span class="line">    pop_heap(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iv.back() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 9</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iv &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8 7 4 3 5 0 2 3 1 【9】</span></span><br><span class="line">    iv.pop_back();</span><br><span class="line"></span><br><span class="line">    sort_heap(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iv &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0 1 2 3 3 4 5 7 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>源码分析</tag>
        <tag>STL</tag>
        <tag>容器</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机内存及内存溢出异常</title>
    <url>/2020/11/27/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%8F%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<blockquote>
<p>  Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进来，墙里面的人却想出来。</p>
</blockquote>
<p>不知道其他人想出来没，反正我是没想出来，为什么这个JVM的运行时内存要这样设计🤣。</p>
<p>以下内容中，Java虚拟机（JVM）特指HotSpot虚拟机。</p>
<a id="more"></a>
<p>JVM启动后，整体来看，会把向操作系统申请到的内存空间分成这样几个部分：</p>
<ol>
<li>程序计数器区</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区</li>
</ol>
<p>它们在《Java虚拟机规范》中都有相关规定和说明，只是有的区域具体实现细节根据Java虚拟机实现者来决定，《Java虚拟机规范》不做强行要求，例如<strong>方法区</strong>。下面对这几个部分进行详细叙述，在叙述过程中，需要不断参考下面这个示意图来帮助理解。</p>
<p><img data-src="https://s3.ax1x.com/2020/11/28/Dy57a8.jpg" alt="Java运行时内存布局"></p>
<h1 id="1-程序计数器区（Program-Counter-Register）"><a href="#1-程序计数器区（Program-Counter-Register）" class="headerlink" title="1. 程序计数器区（Program Counter Register）"></a>1. 程序计数器区（Program Counter Register）</h1><p>这个区域内容指向当前线程所执行字节码行号，是线程私有区域。和操作系统里面的PC指针类似，只不过这个PC指针指向当前执行的字节码行号，操作系统的指针指向下一条执行的指令地址。</p>
<p>需要额外注意的是，如果当前线程在执行Java程序，那么如上所述指向字节码行号，如果执行的是Native方法，那么这个区域是空（Undefined）的。</p>
<p>该区域也是唯一一个《Java虚拟机规范》里面没有 <code>OutOfMemoryError</code> 错误的定义的区域。</p>
<h1 id="2-Java虚拟机栈（VM-Stack）"><a href="#2-Java虚拟机栈（VM-Stack）" class="headerlink" title="2. Java虚拟机栈（VM Stack）"></a>2. Java虚拟机栈（VM Stack）</h1><p>该区域的内容是Java方法执行的线程内存模型，具体来说，存放的是<strong>栈帧</strong>，在栈帧中，存放了局部变量表、操作数栈等信息，当一个方法被调用时，就会创建一个<strong>栈帧</strong>来记录信息，方法从被调用到返回的过程，也就对应了栈帧从入栈（虚拟机栈）到出栈的过程。显而易见，这个区域必须是线程私有的，否则就混乱了呀😑。</p>
<p>这个区域在《Java虚拟机规范》中，详细定义了以下内容：</p>
<ol>
<li>如果线程所创建的栈帧个数大于虚拟机所允许的个数，那么抛出 <code>StackOverflowError</code> 异常。</li>
<li>如果在创建栈帧的过程中，因为内存不足所失败了，则会抛出 <code>OutOfMemoryError</code> 异常。</li>
</ol>
<h2 id="2-1-虚拟机栈异常示例程序"><a href="#2-1-虚拟机栈异常示例程序" class="headerlink" title="2.1 虚拟机栈异常示例程序"></a>2.1 虚拟机栈异常示例程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args: -Xss128k</span></span><br><span class="line"><span class="comment"> * -Xss: 减小栈内存容量</span></span><br><span class="line"><span class="comment"> * 虚拟机栈和本地方法栈测试，抛出 StackOverflow 异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Stack length: &quot;</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>OutOfMemoryError</code> 就需要格外小心了，程序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ！！ 需要先保存当前系统的工作，因为这个程序比较危险。</span></span><br><span class="line"><span class="comment"> * 可能会造成系统假死或者其他异常（甚至强制重启才可以使用）。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * VM Args: -Xss2m</span></span><br><span class="line"><span class="comment"> * -Xss: 减少栈内存容量</span></span><br><span class="line"><span class="comment"> * 使用线程来制造内存溢出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; dontStop(); &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-本地方法栈（Native-Method-Stack）"><a href="#3-本地方法栈（Native-Method-Stack）" class="headerlink" title="3. 本地方法栈（Native Method Stack）"></a>3. 本地方法栈（Native Method Stack）</h1><p>本地方法栈“雷同”虚拟机栈的功能，唯一的区别在于前者记录的是本地方法的执行记录，后者是Java程序的执行记录。</p>
<p>因为这个区域在《Java虚拟机规范》中并没有详细规定本地方法的实现语言和数据结构，所以虚拟机可以根据自己需要来进行扩展。只不过，在HotSpot虚拟机中，是把虚拟机栈和本地方法栈统一放到一起了的。</p>
<p>在可能抛出的异常类型上，和虚拟机栈一样样：</p>
<ol>
<li>如果线程所创建的栈帧个数大于虚拟机所允许的个数，那么抛出 <code>StackOverflowError</code> 异常。</li>
<li>如果在创建栈帧的过程中，因为内存不足所失败了，则会抛出 <code>OutOfMemoryError</code> 异常。</li>
</ol>
<h1 id="4-堆（Heap）"><a href="#4-堆（Heap）" class="headerlink" title="4. 堆（Heap）"></a>4. 堆（Heap）</h1><p>此堆非彼堆，不是同一堆🤪。上篇文章说到的<a href="https://mp.weixin.qq.com/s/kR70YJCAmD7Ym6zd1l4w7w">《探索STL：堆数据结构及算法》</a>，和这里的堆完全不是同一个概念。更何况，这个堆是Java虚拟机的东西，那个是C++的东西，两个混淆了不大好吧😐。</p>
<p>Java堆可以说是整个Java虚拟机中最灵活的地方了，也是最值得研究的地方了，目前好多研究都是围绕这个区域的垃圾收集（Garbage Collection, GC）展开的。这个区域在Java虚拟机启动之初就创建好了，给所有线程共享使用，这里存放的唯一内容就是对象实例，拿《Java虚拟机规范》中的描述来说就是：</p>
<blockquote>
<p>  The heap is the runtime data area from which memory for all class instances and arrays is allocated.</p>
</blockquote>
<p>这一块内存是设计成可扩展的，使用参数 <code>-Xmx</code> 和 <code>-Xms</code> 来设定允许的最大内存和允许的最小内存。当内存不够完成实例的创建也不能完成内存扩展时，将会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h2 id="4-1-堆内存溢出程序示例"><a href="#4-1-堆内存溢出程序示例" class="headerlink" title="4.1 堆内存溢出程序示例"></a>4.1 堆内存溢出程序示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms 设置最小值</span></span><br><span class="line"><span class="comment"> * -Xmx 设置最大值</span></span><br><span class="line"><span class="comment"> * -XX:+HeapDumpOnOutOfMemoryError  当出现内存溢出异常时，Dump出当前的内存转储快照</span></span><br><span class="line"><span class="comment"> * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 堆内存溢出异常测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-方法区（Method-Area）"><a href="#5-方法区（Method-Area）" class="headerlink" title="5. 方法区（Method Area）"></a>5. 方法区（Method Area）</h1><p>这个区域也是线程共享区域，里面存放了被虚拟机加载进来的：</p>
<ul>
<li>类信息</li>
<li>常量、静态变量</li>
<li>即时编译后的程序</li>
</ul>
<p>需要注意的是在这里有一个版本分歧，JDK6及以前的版本，方法区使用分代设计来实现该区域，但是JDK7就开始不一样了，首先是在JDK7吧放在永久代的字符串常量池、静态变量移出到了本地内存中，到了JDK8，彻底将方法区的分代设计抛弃了，换成了使用本地内存实现的“元空间”代替。</p>
<p>这个空间在不能满足新的内存分配需求时，抛出 <code>OutOfMemoryError</code> 异常。</p>
<h2 id="4-1-方法区内存溢出示例程序"><a href="#4-1-方法区内存溢出示例程序" class="headerlink" title="4.1 方法区内存溢出示例程序"></a>4.1 方法区内存溢出示例程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:PermSize=10m -XX:MaxPermSize=10m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> * 上面这个设置是没用的，因为从JDK8开始，HotSpot虚拟机就没有了永久代这么一说，变成了元空间可通过这样设置来实现：</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> * -XX:MaxMetaspaceSize=10m 设置最大元空间，默认是-1，即不设置大小（受限于本地）</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m    设置元空间的初始空间大小，以字节为单位，如果达到了该值，就会触发垃圾收集，并且会调整元空间的大小</span></span><br><span class="line"><span class="comment"> * -XX:MinMetaspaceFreeRatio</span></span><br><span class="line"><span class="comment"> * 报错为：Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMMethodAreaOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-1-运行时常量池（Runtime-Constant-Pool）"><a href="#5-1-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="5.1 运行时常量池（Runtime Constant Pool）"></a>5.1 运行时常量池（Runtime Constant Pool）</h2><p>这是一个神奇的区域😉</p>
<p>首先它是方法区的一个部分，在类文件中有一部分内容是<strong>常量池表</strong>，这部分内容存放了在编译器生成的字面量和符号引用，在类加载后放到方法区的运行时常量中。</p>
<p>运行时常量池具备动态特性，也就是说可以将运行期产生的常量放到池子中，例如 <code>String.intern()</code> 方法。</p>
<p>同方法区异常一样，在内存申请不足的时候，会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h3 id="5-1-1-运行时常量池异常示例程序"><a href="#5-1-1-运行时常量池异常示例程序" class="headerlink" title="5.1.1 运行时常量池异常示例程序"></a>5.1.1 运行时常量池异常示例程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args: -Xmx2m</span></span><br><span class="line"><span class="comment"> * 因为JDK8已经把原本放在永久代的字符串常量池移到了 Java堆 中，</span></span><br><span class="line"><span class="comment"> * 所以限制了堆大小之后，会模拟出来堆内存溢出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-直接内存（Direct-Memory）"><a href="#6-直接内存（Direct-Memory）" class="headerlink" title="6. 直接内存（Direct Memory）"></a>6. 直接内存（Direct Memory）</h1><p>如果查《Java虚拟机规范》，并不能够找到这部分内容，也就是说它并不是虚拟机的一部分，但是这部分内容经常被使用到，举个例子：JDK1.4之后出现的NIO（New Input/Output），记起来了吧？😯这个基于缓冲区（Buffer）和通道（Channel）的I/O模型。使用本地函数直接分配堆外内存，然后通过 <code>DirectByteBuffer</code> 对象作为申请到的堆外内存引用，可以省去在Java堆和本地内存中来回复制数据。</p>
<p>很明显，既然不属于Java虚拟机的范畴，自然也就不会被Java虚拟机大小所限制，不过，仍然要受到本机内存的限制。当内存申请失败时，会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h2 id="6-1-直接内存异常示例程序"><a href="#6-1-直接内存异常示例程序" class="headerlink" title="6.1 直接内存异常示例程序"></a>6.1 直接内存异常示例程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args: -Xmx20m -XX:MaxDirectMemorySize=10m</span></span><br><span class="line"><span class="comment"> * -XX:MaxDirectMemorySize  设置最大直接内存，默认是和Java堆保持一致</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>好了，图里面出现的各个区域所能出现的问题，已经差不多都遇到了（这种主动犯错的机会可不多🤔），也该休息休息然后去复习考试了呜呜呜呜呜😖……</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>JVM性能调优</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux编译OpenJDK12</title>
    <url>/2020/11/28/Linux%E7%BC%96%E8%AF%91OpenJDK12/</url>
    <content><![CDATA[<p>Java虚拟机是自学习Java以来一直保留的一个知识盲区，虽说用一件东西不一定要知道怎么做出来这件东西，例如用电脑不一定要会造电脑（甚至修电脑=￣ω￣=），但是想要把这个工具用到游刃有余还是有必要了解一下它的内部原理的，如今是时候来补一下了(ง •_•)ง。</p>
<a id="more"></a>
<p>下文就一步一步来说明怎样在 <code>ubuntu-20.04 LTS</code> 上编译得到自己的Java虚拟机。</p>
<h1 id="1-准备JDK12源码"><a href="#1-准备JDK12源码" class="headerlink" title="1. 准备JDK12源码"></a>1. 准备JDK12源码</h1><p>首先准备要编译的JDK源码，这里使用JDK12来作为目标虚拟机，源码获取地址及下载方式：</p>
<ul>
<li><a href="https://hg.openjdk.java.net/jdk/jdk12/">https://hg.openjdk.java.net/jdk/jdk12/</a></li>
<li>上面地址打开后，从左边找到 <code>zip</code> 压缩下载，为什么呢？因为 <code>hg</code> 工具在我的环境下并不是常用软件，而且JDK源码有成百上千个大大小小的文件，用 <code>hg</code> 挨个下下来并不是很明智的选择。这种情况下，使用压缩后的 <code>zip</code> 文件更适合我。</li>
<li>下载完后，解压到工作目录下 <code>~/source/</code></li>
</ul>
<h1 id="2-准备JDK11作为-boot-jdk"><a href="#2-准备JDK11作为-boot-jdk" class="headerlink" title="2. 准备JDK11作为 boot jdk"></a>2. 准备JDK11作为 <code>boot jdk</code></h1><p>用JDK去编译JDK，这是一个很好玩的事情😉，就好比想要小鸡先得有一只鸡去下蛋孵蛋一样逻辑正确。</p>
<p>在 <code>ubuntu</code> 下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装JDK11</span></span><br><span class="line">sudo apt-get install openjdk-11-jdk</span><br><span class="line"><span class="comment"># 检查版本号</span></span><br><span class="line">java --version</span><br><span class="line"><span class="comment"># 得到如下类似输出就对了</span></span><br><span class="line"><span class="comment"># openjdk 11 2018-09-25</span></span><br><span class="line"><span class="comment"># OpenJDK Runtime Environment 18.9 (build 11+28)</span></span><br><span class="line"><span class="comment"># OpenJDK 64-Bit Server VM 18.9 (build 11+28, mixed mode)</span></span><br></pre></td></tr></table></figure>
<p>这里有另外一个问题，如果系统之前已经安装了JDK12，或者其他版本该怎么办啊？</p>
<p>很直接的方法是删掉其他版本，只安装 <code>openjdk-11</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除其他所有版本的 JDK</span></span><br><span class="line">sudo apt-get remove openjdk*</span><br><span class="line"><span class="comment"># 再安装 openjdk11</span></span><br><span class="line">sudo apt-get install openjdk-11-jdk</span><br></pre></td></tr></table></figure>
<p>不过，现实往往不允许这么莽撞，万一其他软件依赖当前版本的JDK呢？😥，细思极恐。</p>
<p>那么比较好的办法是什么呢？直接安装其他版本，然后修改软连接到指定版本号就可以了，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加软连接映射</span></span><br><span class="line">sudo update-alternatives --install /usr/lib/java java /jdk存放路径/bin/java 2 </span><br><span class="line">sudo update-alternatives --install /usr/lib/javac javac /jdk存放路径/bin/javac 2</span><br></pre></td></tr></table></figure>
<p>最后的那个命令，是标记当前的软连接号的，在完成这一步之后，可以使用如下命令来完成切换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新软连接映射规则</span></span><br><span class="line">sudo update-alternatives --config java</span><br></pre></td></tr></table></figure>
<p>在配置表中，选择最前面的序号就可以了，记得把所有工具都切换过来，例如 <code>javac</code>。</p>
<h1 id="3-安装必要的库"><a href="#3-安装必要的库" class="headerlink" title="3. 安装必要的库"></a>3. 安装必要的库</h1><p>本人所用的操作系统是 <code>ubuntu-20.04.1 LTS</code> ，同时使用的 <code>gcc</code> 和 <code>g++</code> 工具版本为 <code>7.5.0</code>，这里需要注意一下，不要用太高版本的，例如 <code>9.x</code>，在编译过程中会出现问题。</p>
<p>同样的，如果需要修改 <code>gcc g++</code> 版本，可以用如下命令进行切换（前提是已经安装了 <code>gcc-7</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 7</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 7</span><br></pre></td></tr></table></figure>
<p>那么完成上面的步骤之后，接下来就是安装必要的库了，挨个执行如下命令就好：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先更新软件</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># 然后逐个安装</span></span><br><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libfreetype6-dev</span><br><span class="line">sudo apt-get install libcups2-dev</span><br><span class="line">sudo apt-get install libx11-dev libxext-dev libxrender-dev libxrandr-dev libxtst-dev libxt-dev</span><br><span class="line">sudo apt-get install libasound2-dev</span><br><span class="line">sudo apt-get install libffi-dev</span><br><span class="line">sudo apt-get install autoconf</span><br></pre></td></tr></table></figure>
<p>总之，哪个安装出问题了就重新安装哪一个，缺一不可。</p>
<h1 id="4-JDK依赖项检查及参数配置"><a href="#4-JDK依赖项检查及参数配置" class="headerlink" title="4. JDK依赖项检查及参数配置"></a>4. JDK依赖项检查及参数配置</h1><p>使用 <code>bash configure [options]</code> 来完成，具体的参数列表使用如下命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 会得到一个长长的列表，巨长😦😧😨😱</span></span><br><span class="line">bash configure --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>其实忽略这个细节，直接使用这条命令来完成就可以了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash configure --<span class="built_in">enable</span>-debug --with-target-bits=64 --with-conf-name=cherry-jvm-x86-64-linux-conf --with-jvm-variants=server</span><br><span class="line"><span class="comment"># 从前往后依次是：启动 打开调试功能 编译64位的虚拟机 配置名称 HotSpot 的编译模式</span></span><br></pre></td></tr></table></figure>
<p>完成该命令后，可以得到如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A new configuration has been successfully created <span class="keyword">in</span></span><br><span class="line">/home/cherry/<span class="built_in">source</span>/jdk12/build/cherry-jvm-x86-64-linux-conf</span><br><span class="line">using configure arguments <span class="string">&#x27;--enable-debug --with-target-bits=64 --with-conf-name=cherry-jvm-x86-64-linux-conf --with-jvm-variants=server&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Configuration summary:</span><br><span class="line">* Debug level:    fastdebug</span><br><span class="line">* HS debug level: fastdebug</span><br><span class="line">* JVM variants:   server</span><br><span class="line">* JVM features:   server: <span class="string">&#x27;aot cds cmsgc compiler1 compiler2 epsilongc g1gc graal jfr jni-check jvmci jvmti management nmt parallelgc serialgc services shenandoahgc vm-structs zgc&#x27;</span></span><br><span class="line">* OpenJDK target: OS: linux, CPU architecture: x86, address length: 64</span><br><span class="line">* Version string: 12-internal+0-adhoc.cherry.jdk12 (12-internal)</span><br><span class="line"></span><br><span class="line">Tools summary:</span><br><span class="line">* Boot JDK:       openjdk version <span class="string">&quot;11&quot;</span> 2018-09-25 OpenJDK Runtime Environment 18.9 (build 11+28) OpenJDK 64-Bit Server VM 18.9 (build 11+28, mixed mode)  (at /home/cherry/Application/jdk-11)</span><br><span class="line">* Toolchain:      gcc (GNU Compiler Collection)</span><br><span class="line">* C Compiler:     Version 7.5.0 (at /usr/bin/gcc)</span><br><span class="line">* C++ Compiler:   Version 7.5.0 (at /usr/bin/g++)</span><br><span class="line"></span><br><span class="line">Build performance summary:</span><br><span class="line">* Cores to use:   8</span><br><span class="line">* Memory <span class="built_in">limit</span>:   15883 MB</span><br></pre></td></tr></table></figure>
<p>这就说明我们通过了依赖项检查、参数配置、构建输出目录等过程，接下来就是编译了。</p>
<h1 id="5-编译JDK12"><a href="#5-编译JDK12" class="headerlink" title="5. 编译JDK12"></a>5. 编译JDK12</h1><p>输入 <code>make images</code> 开始进行编译，这个过程比较漫长，视个人机器而定，我在这里等了差不多5分钟吧。可以去喝杯牛奶🥛😉。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@:~/<span class="built_in">source</span>/jdk12$ make images</span><br><span class="line"><span class="comment"># 得到以下输出</span></span><br><span class="line">Building target <span class="string">&#x27;images&#x27;</span> <span class="keyword">in</span> configuration <span class="string">&#x27;cherry-jvm-x86-64-linux-conf&#x27;</span></span><br><span class="line">Compiling 8 files <span class="keyword">for</span> BUILD_TOOLS_LANGTOOLS</span><br><span class="line">Warning: No SCM configuration present and no .src-rev</span><br><span class="line">Creating hotspot/variant-server/tools/adlc/adlc from 13 file(s)</span><br><span class="line">Compiling 2 files <span class="keyword">for</span> BUILD_JVMTI_TOOLS</span><br><span class="line">Compiling 1 files <span class="keyword">for</span> BUILD_JFR_TOOLS</span><br><span class="line">……</span><br><span class="line">Creating jdk image</span><br><span class="line">Creating CDS archive <span class="keyword">for</span> jdk image</span><br><span class="line">Stopping sjavac server</span><br><span class="line">Finished building target <span class="string">&#x27;images&#x27;</span> <span class="keyword">in</span> configuration <span class="string">&#x27;cherry-jvm-x86-64-linux-conf&#x27;</span></span><br></pre></td></tr></table></figure>
<p>看到上面输出后，说明编译结束了，接下来验证是否正常：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@:~/<span class="built_in">source</span>/jdk12/build/cherry-jvm-x86-64-linux-conf/images/jdk/bin$ ./java --version</span><br><span class="line">openjdk 12-internal 2019-03-19</span><br><span class="line">OpenJDK Runtime Environment (fastdebug build 12-internal+0-adhoc.cherry.jdk12)</span><br><span class="line">OpenJDK 64-Bit Server VM (fastdebug build 12-internal+0-adhoc.cherry.jdk12, mixed mode, sharing)</span><br></pre></td></tr></table></figure>
<p>得到编译号为 <code>fastdebug build 12-internal+0-adhoc.cherry.jdk12</code> 的JVM~</p>
<p>如果到此，没有出现不可解决的问题，那么就得到了自己编译的Java虚拟机，恭喜~☺☺☺🤩🤗🤗</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM性能监控故障处理工具</title>
    <url>/2020/12/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>在搞清楚Java虚拟机在运行时的内存分布状况，以及运行时可能出现的异常类型之后，趁热打铁马不停蹄就算冒着期末挂科的风险也要接着继续学习Java虚拟机🤪（😕要是研究生的课都不考试该多好）。<br>下文使用到的虚拟机版本及操作系统信息为：</p>
<ul>
<li>Java 11.0.9 2020-10-20 LTS</li>
<li>Windows10, 8.00 GB RAM space</li>
</ul>
<a id="more"></a>
<p>在前面的文章<a href="https://mp.weixin.qq.com/s/I0lXhTOy5LzJ6q6WeUatGQ">《Java虚拟机内存及内存溢出异常》</a>中，对Java虚拟机运行时内存分布状况有了了解，也试探了一下<strong>堆内存、虚拟机方法栈、本地方法栈、方法区、直接内存</strong>可能遇到的异常。那么下面要从如何去监控、分析这些可能出现的错误，该使用什么样的工具来对这些问题进行处理进行捣腾。</p>
<p>开篇之前，先拿出来《深入理解Java虚拟机》里面的一句话，感受还是挺深刻的，这句话是这么说的：</p>
<blockquote>
<p>  给一个系统定位问题时，经验，知识是基础，数据是依据，工具是运用知识和经验处理数据的手段。</p>
</blockquote>
<p>在Java虚拟机这里可用到的数据有堆转储快照（heapdump/hprof），线程快照（threaddump/javacore），虚拟机运行日志、垃圾收集日志等。</p>
<p>这些工具在JDK中已有提供，具体在 <code>&#123;JDK安装目录&#125;/bin/</code> 目录下，这些工具并不是完全免费使用的，只不过对于我们研究学习个人使用来说，是免费的😝，说到这里不得不提一下JetBrains软件包的学生优惠真的太棒了！😉。</p>
<p>那么接着将会把 <code>jps, jstat, jinfo, jmap, jhat, jstack, JHSDB, JConsole, VisualVM, Java Mission Control</code> 这几个老哥挨个溜一遍，混个脸熟，如果能一不小心就造成了永久记忆，也是不错的结果😜。就算没记住，日后有需要时直接来查也是可以的，毕竟工具千变万变，原理也是难得一变。</p>
<blockquote>
<p>  命令举例参考自《深入理解Java虚拟机》。</p>
<p>  下面所称“虚拟机”特指“Java虚拟机”或“HotSpot”虚拟机。</p>
</blockquote>
<h1 id="1-jps-虚拟机进程工具"><a href="#1-jps-虚拟机进程工具" class="headerlink" title="1. jps 虚拟机进程工具"></a>1. <code>jps</code> 虚拟机进程工具</h1><p>每个Java虚拟机启动后，都会有一个系统线程，那么这个 <code>jps</code> 就是干这件事的（与Linux下的 <code>ps</code> 命令差不多一样，只不过  <code>jps</code> 只检查Java虚拟机的相关进程。</p>
<p><code>jps</code> 命令会列出正在运行的Java虚拟机进程，并显示虚拟机的启动类，以及这些进程的<strong>本地虚拟机线程号</strong>（LVMID, Local Virtual Machine Identifier），这个<strong>本地虚拟机进程号</strong>对于后面的工具使用是非常重要的，先记住有这么个东西在这里放着。命令格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jps [-q] [-mlvV] [&lt;hostid&gt;]</span><br></pre></td></tr></table></figure>
<p>使用示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jps -l</span><br><span class="line">12032 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">2980 jdk.jcmd/sun.tools.jps.Jps</span><br><span class="line">8236</span><br></pre></td></tr></table></figure>
<p>可用选项包括：</p>
<ul>
<li><code>-m</code> ：列出传递给启动类的参数， <code>public static void main(String[] args)</code> ，就是这里的 <code>args</code> 。</li>
<li><code>-l</code> ：列出启动类全名。</li>
<li><code>-v</code> ：列出给虚拟机的参数。</li>
<li><code>-V</code> ：只列出启动类名称、本地进程号。</li>
</ul>
<h1 id="2-jstat-虚拟机统计信息监控工具"><a href="#2-jstat-虚拟机统计信息监控工具" class="headerlink" title="2. jstat 虚拟机统计信息监控工具"></a>2. <code>jstat</code> 虚拟机统计信息监控工具</h1><p><code>jstat</code> 全称 Java Statistics Monitoring Tool，说的是监控统计信息，也就是虚拟机进程中的<strong>类加载，内存，垃圾收集，即时编译</strong>等运行时数据。它的命令使用方法可使用 <code>--help</code> 选项来查询得到，命令格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure>
<p>对于可用的选项使用如下命令来查询：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jstat -options</span><br></pre></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每隔 250ms 查询进程号为 15144 的堆使用状况，一共查询20次</span></span><br><span class="line">jstat -gc 15144 250 20</span><br></pre></td></tr></table></figure>
<p>这个命令好就好在是一个纯文本状态下使用的，这也是因为服务器上往往不能使用图形界面，而不得不使用命令行纯文本的原因。</p>
<h1 id="3-jinfo-虚拟机配置信息工具"><a href="#3-jinfo-虚拟机配置信息工具" class="headerlink" title="3. jinfo 虚拟机配置信息工具"></a>3. <code>jinfo</code> 虚拟机配置信息工具</h1><p>这个工具可以用来<strong>实时查看和调整</strong>虚拟机参数，可以使用 <code>-flags</code> 或者 <code>-flag</code> 选项进行查询虚拟机的默认值，在JDK6及以上版本中，还可以使用 <code>java -XX:+PrintFlagsFinal</code> 来直接查询所有的虚拟机默认值。命令格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinfo &lt;option&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure>
<p>甚至！还可以使用如下命令来设置和取消一部分运行时可修改的参数，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinfo -flag [+|-]&lt;name&gt;</span><br><span class="line">jinfo -flag &lt;name&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h1 id="4-jmap-虚拟机内存映像工具"><a href="#4-jmap-虚拟机内存映像工具" class="headerlink" title="4. jmap 虚拟机内存映像工具"></a>4. <code>jmap</code> 虚拟机内存映像工具</h1><p>该命令用于生成<strong>堆转储</strong>快照，也就是 <code>heapdump</code> 文件或者 <code>dump</code> 文件，例如 <code>*.hprof</code> 文件。这个命令还可以查询 <code>finalize</code> 执行队列，方法区、堆空间的详细信息，例如空间使用率，使用的是哪种垃圾收集器等。</p>
<ul>
<li>除了生成堆转出快照 <code>-dump</code> 选项和用于查看类实例、空间使用率的 <code>-histo</code> 命令在所有操作系统中通用以外，其他选项只能在<strong>Linux/Solaris</strong>操作系统中用。</li>
</ul>
<p>可用参数表如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jmap -clstats &lt;pid&gt;</span><br><span class="line"><span class="comment"># 列出加载类统计信息</span></span><br><span class="line">jmap -finalizerinfo &lt;pid&gt;</span><br><span class="line"><span class="comment"># 列出 finalize 执行队列信息</span></span><br><span class="line">jmap -histo[:live] &lt;pid&gt;</span><br><span class="line"><span class="comment"># 列出堆信息，使用直方图表示，其中的 :live 是可选项，只统计存活的对象</span></span><br><span class="line">jmap -dump:&lt;dump-options&gt; &lt;pid&gt;</span><br><span class="line"><span class="comment"># 堆转储</span></span><br><span class="line">jmp -heap</span><br><span class="line"><span class="comment"># 查看Java堆详情，只能用在Linux和Solaris下</span></span><br><span class="line">jmp -permstat </span><br><span class="line"><span class="comment"># 查看堆中对象统计信息，包括类、实例数量、合计容量等，同样只能用在 Linux和Solaris下</span></span><br><span class="line"></span><br><span class="line">dump-options:</span><br><span class="line">live         dump only live objects; <span class="keyword">if</span> not specified,</span><br><span class="line">all objects <span class="keyword">in</span> the heap are dumped.</span><br><span class="line">format=b     binary format</span><br><span class="line">file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>一个活生生的例子如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=Desktop/log.bin 8236</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure>
<p>那么接下来就可以使用下文中的堆转储快照分析工具进行分析。</p>
<h1 id="5-jhat-虚拟机堆转储快照分析工具（很少用）"><a href="#5-jhat-虚拟机堆转储快照分析工具（很少用）" class="headerlink" title="5. jhat 虚拟机堆转储快照分析工具（很少用）"></a>5. <code>jhat</code> 虚拟机堆转储快照分析工具（很少用）</h1><p>除非没其他工具可用，否则不会用它，这个工具有点简陋有点丑😐😑🤨，让人感觉是上个世纪的软件。</p>
<p>噢，对了，这个工具是在JDK8的 <code>bin</code> 目录中找到的，JDK11愣是没找到😅，难不成是删掉了？🤔，不管怎样，找到了先拿来用用看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./jhat /Desktop/log.bin</span><br><span class="line">Reading from /Desktop/log.bin...</span><br><span class="line">Dump file created Fri Dec 04 16:32:39 CST 2020</span><br><span class="line">Snapshot <span class="built_in">read</span>, resolving...</span><br><span class="line">Resolving 31834 objects...</span><br><span class="line">Chasing references, expect 6 dots......</span><br><span class="line">Eliminating duplicate references......</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>
<p>然后打开本地浏览器以看，噫！真的不是很好看的软件界面🤣。</p>
<p><img data-src="https://s3.ax1x.com/2020/12/04/DbNaY8.png" alt="jhat软件界面图" style="zoom:50%;" /></p>
<p>不过，用的好还是可以用的，例如使用上图中的 <code>show heap histogram</code> 标签页快速查询堆情况。</p>
<h1 id="6-jstack-虚拟机堆栈跟踪工具"><a href="#6-jstack-虚拟机堆栈跟踪工具" class="headerlink" title="6. jstack 虚拟机堆栈跟踪工具"></a>6. <code>jstack</code> 虚拟机堆栈跟踪工具</h1><p>查询虚拟机当前时刻的线程快照，例如 <code>threaddump</code> 文件或者 <code>javacore</code> 文件。线程快照主要反映了虚拟机栈的信息，不过也有堆的信息。可以通过这个工具来分析到底没有响应的程序到底在后台干了些啥。命令格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jstack [-l][-e] &lt;pid&gt;</span><br></pre></td></tr></table></figure>
<p>其中的参数说明如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-l  需要查询关于锁的信息</span><br><span class="line">-e  打印关于线程的信息</span><br></pre></td></tr></table></figure>
<p>这个命令产生的输出真的太长太长，需要时候再挨个查询，总之先记住这个工具的存在和功能😋。</p>
<h1 id="7-可视化工具大家庭"><a href="#7-可视化工具大家庭" class="headerlink" title="7. 可视化工具大家庭"></a>7. 可视化工具大家庭</h1><p>在这部分，就很简单了。尤其在明白原理的情况下，这些可视化工具也就没那么神奇了，鼠标点点点，滑块拖拖拖，再不济输入点小指令也就完事了。但是一定要知道这些工具的存在。</p>
<ul>
<li>JHSDB：基于服务性代理的调试工具，需要在JDK9之上才可以用，附赠在JDK的 <code>bin</code> 目录下。</li>
<li>JConsole：Java监视与管理控制台，在JDK的 <code>bin</code> 目录下就可以直接使用。</li>
<li>VisualVM：多合一故障处理工具，在JDK8以下默认附带在JDK工具包中，但是之后例如JDK11需要单独下载，噢，对！这个软件还有一点很厉害，可以支持插件安装。</li>
<li>Java Mission Control：持续在线的监控工具，对服务器的吞吐量影响很小，而且该软件的启动停止是动态的，不需要重启应用，使用JMX通信协议实现。</li>
<li>HSDIS：JIT生成代码反汇编。</li>
</ul>
<hr>
<p>还是回到开头那句话，工具只是一种工具，只有明白了基本原理和底层设计细节，这些工具用起来才可以得心应手，在职业道路上才可以如虎添翼😉。</p>
<p>好啦~吃饭去🙂</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>JVM性能调优</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集算法</title>
    <url>/2020/12/13/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>并查集数据结构是之前在做算法题时落下的一块儿内容，现在想把它补上来。</p>
<a id="more"></a>
<h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h2><p>直奔主题，考虑这样一个图：</p>
<p><img data-src="https://s3.ax1x.com/2020/12/13/rexBbd.png" alt="图节点分布状况"></p>
<p>翻过来倒过去挠挠头🤔，其实这就是一个简单的<strong>无向图</strong>😅，上面图中所有节点，满足这样三个性质：</p>
<ul>
<li><strong>自反性：</strong> <code>0</code> 和 <code>0</code> 是连接的，同理，其他节点也是。</li>
<li><strong>对称性：</strong>如果 <code>0</code> 和 <code>1</code> 是连接的，那么 <code>1</code> 和 <code>0</code> 也是连接的。</li>
<li><strong>传递性：</strong>如果 <code>0</code> 和 <code>1</code> 相连，<code>1</code> 又和 <code>2</code> 相连，那么 <code>0</code> 和 <code>2</code> 也是相连的，同理， <code>0</code> 和 <code>7</code> 也是相连的。</li>
</ul>
<p>不难想到，在这样一个无向图中，有这样一种问题：</p>
<p><strong>从节点</strong> <code>1</code> <strong>出发，是否能到达目标节点</strong> <code>9</code>。</p>
<p>当然，也仅仅是检查是否能到，而不讨论具体可达路径上的点是什么。这样简化问题后，就和这样一个抽象问题相关联起来了：</p>
<p><strong>如何把一些元素分成两组不相交的集合</strong>。</p>
<p>这样一个元素分组问题也就是<strong>并查集</strong>的研究对象，<strong>并查集</strong>算法简洁优雅，易于分析，同时也应用广范，例如上面图的可达性问题研究中，就用到了这样的算法。当然，该算法在以下场景中都有应用：</p>
<ol>
<li>网络分析：看看你的社交圈和他的社交圈是否是相关联的🤭，看看网络上两条信道是否是相连通的等等等等</li>
<li>程序设计语言：看看两个变量在语法句法上是否是同一个变量。</li>
<li>数学集合：正如上面所述，看看怎样又快又好把一些元素分成多个不相交的分组。</li>
</ol>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h2><p>那么明确了要完成的事（如何判断图中两个节点是连通的），就要开始着手实现，一如既往分成两个部分（数据结构和算法），</p>
<ol>
<li>定义什么样的数据结构能够表示这样的连接关系。</li>
<li>如何去实现判断连接关系，如何添加新的连接。</li>
</ol>
<p>对于第一部分的实现，可以定义这样数据结构：<code>id[index] = identifier</code>，其中 <code>index</code> 表示图中第 <code>index</code> 个节点，<code>identifier</code> 表示这个图的标识符，根据这个标识符来判断该节点具体属于哪一类。</p>
<p>那么谈到第二部分的实现，不妨定义如下API接口列表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加 p 和 q 之间的连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计连通块的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 p 到 q 是否是可达的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第 p 个节点的 identifier</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当然还应该有图数据点的初始化部分，不过这部分与直接相关联的问题相连，本着具体问题具（就）体（是）讨（偷）论（懒）的原则😶，结合上面的图来看下面的示例程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFindAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">        QuickFind(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">            id = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">            count = sz;</span><br><span class="line">            <span class="comment">// 初始化，把所有节点的 identifier 标记为它们本身</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取第 p 个节点的 identifier</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加 p 和 q 之间的连接</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (connected(p, q)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> pid = id[p];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; ++i)</span><br><span class="line">                <span class="keyword">if</span> (id[i] == pid) id[i] = id[q];</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计连通块的个数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 p 到 q 是否是可达的</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickUnion</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">QuickUnion</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">            id = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">            count = sz;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">                id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 首先获取到两个节点的根节点，然后检查是否一样（连通）</span></span><br><span class="line">            <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">            <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">            <span class="keyword">if</span> (pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 如果不连通，那么就把它们的根修改为其中同一个</span></span><br><span class="line">            id[pRoot] = qRoot;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 回查根节点</span></span><br><span class="line">            <span class="keyword">while</span> (p != id[p]) p = id[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一看就明白，这是两种不同的算法，从名字上不难看出一个是 <code>union</code> 快速（<code>quick_union</code>）一个是查找 <code>identifier</code> 快速（<code>quick_find</code>）。</p>
<h3 id="2-1-快速查找（quick-find）"><a href="#2-1-快速查找（quick-find）" class="headerlink" title="2.1 快速查找（quick_find）"></a>2.1 快速查找（<code>quick_find</code>）</h3><p>对于添加的 <code>p</code> 和 <code>q</code> 之间的新连接，令 <code>id[p] = id[q]</code> 同时令所有与 <code>id[p]</code> 相同的 <code>id[i]</code> 更新为 <code>id[q]</code>，总而言之：把所有的连接与最后加入集合中的点的 <code>identifier</code> 保持一致就好了。</p>
<p>不难发现，在快速查找算法中，<code>find</code> 只需要访问数组 <code>id[]</code> 一次，但是进行一次 <code>union</code> 需要 <code>3</code> 次 <code>find</code> 操作和一次 检查 <code>n</code> 个元素的操作，即 <code>n + 3</code> 次访问数组。那么最坏的情况可就不容乐观了：假设所有节点最后都连通了，那么就需要进行 </p>
<p><code>(n - 1) * (n + 3) ≈ n ^ 2</code> 次，</p>
<p>这个时候算法复杂度就飙升到了 <code>n ^ 2</code>，这自然是不大合理的😔，于是就有了下面一种方法🤨😮。</p>
<h3 id="2-2-快速合并（quick-union）"><a href="#2-2-快速合并（quick-union）" class="headerlink" title="2.2 快速合并（quick_union）"></a>2.2 快速合并（<code>quick_union</code>）</h3><p>我们不再把所有的连通节点的 <code>identifier</code> 标记成一致的了😯！而是让原来的 <code>id[index] = neighbor</code>，表示 <code>index</code> 与 <code>neighbor</code> 相连接，也就是形成了类似于链表一样的结构。这样一来，调用 <code>find(p)</code> 方法时，可以从 <code>p</code> 一直相上查找到一个<strong>根节点</strong><code>root</code>，那么这个根节点下的所有节点都是连通的，在判断是否连通时，直接向上回查至这个 <code>root</code> 是否一样就好了。</p>
<p>这个算法实际上是 <code>find</code> 与 <code>union</code> 的平衡，没有过慢的问题也没有很快，不过对于大数据量而言提升还是很明显。</p>
<p>这两种算法适用于不同的场合。</p>
<ul>
<li>当数据较小而且需要不需要频繁添加新连接，那么就用 <code>quick_find</code>。</li>
<li>当数据大，而且需要频繁插入新的连接，那么就用 <code>quick_union</code>。</li>
</ul>
<h3 id="2-3-测试一下🤗"><a href="#2-3-测试一下🤗" class="headerlink" title="2.3 测试一下🤗"></a>2.3 测试一下🤗</h3><p>数据就是用上面图中所示数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFindAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickFind</span> </span>&#123; <span class="comment">// 如上所示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickUnion</span> </span>&#123; <span class="comment">// 如上所示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        QuickFind uf = new QuickFind(10);</span></span><br><span class="line">        QuickUnion uf = <span class="keyword">new</span> QuickUnion(<span class="number">10</span>);</span><br><span class="line">        uf.union(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">        uf.union(<span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">        uf.union(<span class="number">6</span>, <span class="number">5</span>);</span><br><span class="line">        uf.union(<span class="number">9</span>, <span class="number">4</span>);</span><br><span class="line">        uf.union(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        uf.union(<span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        uf.union(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">        uf.union(<span class="number">7</span>, <span class="number">2</span>);</span><br><span class="line">        uf.union(<span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">        uf.union(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        uf.union(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共计 &quot;</span> + uf.count() + <span class="string">&quot; 个连通块&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (uf.connected(<span class="number">7</span>, <span class="number">8</span>))</span><br><span class="line">            System.out.println(<span class="string">&quot;7 和 8 相连~&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;7 和 8 不相连~&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (uf.connected(<span class="number">7</span>, <span class="number">0</span>))</span><br><span class="line">            System.out.println(<span class="string">&quot;7 和 0 相连~&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;7 和 0 不相连~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个都能得到输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">共计 2 个连通块</span><br><span class="line">7 和 8 不相连~</span><br><span class="line">7 和 0 相连~</span><br></pre></td></tr></table></figure>
<p>满意😉。</p>
<h2 id="3-解决下算法题目"><a href="#3-解决下算法题目" class="headerlink" title="3. 解决下算法题目"></a>3. 解决下算法题目</h2><p>这道题来自<strong>LeetCode</strong>的第<strong>684</strong>题，题目难度 <code>medium</code> ，不过当时做起来还是挺不容易的，费了老大劲🤣。现在明白了并查集算法后觉得也就那样，有点拨云见日的感觉。</p>
<p>题目是这样说的：</p>
<p>在本问题中, 树指的是一个连通且无环的无向图。</p>
<p>输入一个图，该图由一个有着 <code>N</code> 个节点 (节点值不重复<code>1, 2, ..., N</code>) 的树及一条附加的边构成。附加的边的两个顶点包含在<code>1</code>到<code>N</code>中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组。每一个边的元素是一对<code>[u, v]</code>，满足 <code>u &lt; v</code>，表示连接顶点 <code>u</code> 和<code>v</code>的无向图的边。</p>
<p>返回一条可以删去的边，使得结果图是一个有着<code>N</code>个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 <code>[u, v]</code>应满足相同的格式 <code>u &lt; v</code>。</p>
<p><strong>例如：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>输入的二维数组大小在 3 到 1000。</li>
<li>二维数组中的整数在 <code>1</code> 到 <code>N</code> 之间，其中 <code>N</code> 是输入数组的大小。</li>
</ul>
<p><strong>问题分析：</strong></p>
<p>仔细读题其实不难发现，就是找最后一个连接，这个连接让图构成一个环。放到并查集中，也就是找<strong>最后一个已经连通</strong>的但<strong>再次尝试连通的</strong>节点对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">No684</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 准备返回值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 用来标记连通 identifier 的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">    <span class="comment">// 题目提供的接口，给我们一个 edges 数组，用来表示边。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="comment">// 为什么是 n + 1？还不是因为题目没有从 0 开始计数😑</span></span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[edges.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化各个边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; id.length; ++i) id[i] = i;</span><br><span class="line">        <span class="comment">// 把各个边都添加进连通分量中去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) union(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="comment">// p 和 q 并没有连通，那么就让他们连通</span></span><br><span class="line">        <span class="keyword">if</span> (pRoot != qRoot) id[pRoot] = qRoot;</span><br><span class="line">        <span class="comment">// 说明 p 和 q 已经连通了呀，那么就直接把它们记录下来</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = p;</span><br><span class="line">            ans[<span class="number">1</span>] = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向上回查根节点编号</span></span><br><span class="line">        <span class="keyword">while</span> (id[p] != p) p = id[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>这个教室有一点点冷🥶，怀念在本科学校第一年因为暖气被热成🐱的日子，不过后来因为号召节能减排也时常关闭暖气，想到这里，也就作罢了。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
