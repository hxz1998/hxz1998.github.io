<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++中的lambda表达式探究</title>
    <url>/2020/08/30/CPP%E4%B8%AD%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>在 <code>C++11</code> 及之后的版本中，<code>C++</code> 提供了 <code>lambda</code> 表达式，它是一种方便了参数传递和定义匿名函数的方法。该方法通常用于封装算法、执行异步方法 ，也就是说比较适用于少量的代码。以下原文：</p>
<blockquote>
<p>In C++11 and later, a lambda expression—often called a <em>lambda</em>—is a convenient way of defining an anonymous function object (a <em>closure</em>) right at the location where it is invoked or passed as an argument to a function. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous methods. This article defines what lambdas are, compares them to other programming techniques, describes their advantages, and provides a basic example. </p>
</blockquote>
<a id="more"></a>

<h1 id="1-Lambda-表达式的组成"><a href="#1-Lambda-表达式的组成" class="headerlink" title="1. Lambda 表达式的组成"></a>1. <code>Lambda</code> 表达式的组成</h1><p>先对 <code>lambda</code> 表达式有一个直观的认识，参考下面程序，该程序完成的是将输入的数组 <code>nums</code> 按照绝对值大小进行升序排列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) <span class="keyword">mutable</span> <span class="keyword">throw</span>() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="comment">// lambda 表达式函数体，在这里做到了将输入数组升序排列</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(b));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">// &gt;: 1 -1 2 3 4 5 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛开边边角角，单独拿出最重要的一部分来学习，<code>[](int a, int b) mutable throw() -&gt; bool&#123; // statement &#125;</code> 就是 <code>lambda</code> 表达式最原始的内容。在该表达式中，每一部分的含义如下叙述：</p>
<ol>
<li><code>[]</code> 捕获子句：用来捕获<strong>周围范围</strong>中出现的变量，也被称为<strong>引导</strong>子句，可以在其中声明获取的变量是按<strong>值</strong>访问还是<strong>引用</strong>来访问<del>，默认值为 <code>&amp;</code> ，上文中的例子和 <code>[&amp;]</code> 是一样的效果，</del>具体例子见下文。</li>
<li><code>()</code> 参数列表：用来获取参数，对于一个一般的 <code>lambda</code> 函数，使用起来和一般的指针函数没有区别，也是需要有参数列表的，具体例子见下文。</li>
<li><code>mutable</code> 可变类型（可选）：一般来说，在 <code>lambda</code> 体中调用运算符的变量，都是以 <code>const value</code> 来使用的，加上这个 <code>mutable</code> 之后，人家变成了变量来使用，具体栗子见下文。</li>
<li><code>throw()</code> 异常类型（可选）：和普通函数一样样，<code>lambda</code> 函数也可能引发异常，如果不会引发异常的话，直接声明 <code>noexcept</code> 就可以啦~</li>
<li><code>-&gt; bool</code> 返回类型（可选）：继续和普通函数一样</li>
<li><code>&#123;// statement &#125;</code> <code>lambda</code> 体：和一般的函数体一样。</li>
</ol>
<p>不难发现，<code>lambda</code> 函数和一般的函数没有太大区别，基本上只有在头部位置有特殊语法。</p>
<h1 id="2-捕获语句的使用-amp-可变规范-mutable"><a href="#2-捕获语句的使用-amp-可变规范-mutable" class="headerlink" title="2. 捕获语句的使用 &amp; 可变规范 mutable"></a>2. 捕获语句的使用 &amp; 可变规范 <code>mutable</code></h1><p>拿出栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>; <span class="comment">// 在上文中声明好变量 num</span></span><br><span class="line">    <span class="keyword">auto</span> f = [n = num]() &#123; <span class="comment">// 在下文中通过 捕获[] 来获取 num，并在 lambda 函数体中进行使用</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; ++num &lt;&lt; std::endl; // 错误的使用，因为 num 是不可变的常量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    f(); <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="keyword">auto</span> m = [num]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 将内部变量声明成 mutable 可变类型，此时可以修改内部变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    m(); <span class="comment">// &gt;: 2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del><code>mutable</code> 可变声明优势在于可以在内部直接改变外部变量，相当于使用了 <code>[&amp;num]</code> 引用方法。</del></p>
<p><strong>2020年9月1日 修正：</strong>在 <code>C++14</code> 及以后的版本中，可以通过 <code>capture</code> 语句从周围（Surrounding Scope）捕获变量，在 <code>[]</code> 子句中指定要捕获哪些变量，以及按照何种方式使用它们。和普通语法一样，带有 <code>＆</code> 前缀的变量可以通过<strong>引用</strong>进行访问，而没有前缀 <code>＆</code> 的变量可以通过值进行访问。<strong>而空的捕获子句[]表示 <code>lambda</code> 表达式的主体在闭包范围内不访问外部任何变量。</strong> 当然~，也可以使用默认的捕获模式来指示如何捕获 <code>lambda</code> 中引用的任何外部变量：<code>[＆]</code> 表示周围所有变量都是通过引用捕获的，而 <code>[=]</code> 意味着它们按值所捕获。</p>
<p>一般情况下，<code>lambda</code>的函数调用运算符是<strong>常量值</strong>，但是使用 <code>mutable</code> 关键字可以修改默认值，<code>mutable</code> 使 <code>lambda</code> 表达式的函数体可以修改按值捕获的变量。</p>
<h1 id="3-参数列表"><a href="#3-参数列表" class="headerlink" title="3. 参数列表"></a>3. 参数列表</h1><p>再拿出一个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> y = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; y(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// &gt;: 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里开始，也就是参数列表开始，后面的内容都是可选项，也就是如果为空，那么就直接<strong>省略</strong>不写即可。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> empty = [] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Wow!空的~&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 啥也没有只有个函数体&#125;;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    empty(); <span class="comment">// &gt;: Wow!空的~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-特殊用法"><a href="#4-特殊用法" class="headerlink" title="4. 特殊用法"></a>4. 特殊用法</h1><h2 id="4-1-花里胡哨的-lambda-嵌套"><a href="#4-1-花里胡哨的-lambda-嵌套" class="headerlink" title="4.1 花里胡哨的 lambda 嵌套"></a>4.1 花里胡哨的 <code>lambda</code> 嵌套</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两层 lambda 嵌套，看起来挺花里胡哨</span></span><br><span class="line">    <span class="keyword">auto</span> embed_embed_lambda = [](<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; - - &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> [](<span class="keyword">int</span> c) &#123; <span class="keyword">return</span> c / <span class="number">2</span>; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; embed_embed_lambda(<span class="number">2</span>)(<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2 - - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-高阶-lambda-函数"><a href="#4-2-高阶-lambda-函数" class="headerlink" title="4.2 高阶 lambda 函数"></a>4.2 高阶 <code>lambda</code> 函数</h2><p>高阶函数是指，采用另一个 <code>lambda</code> 表达式作为其参数或返回 <code>lambda</code> 表达式的 <code>lambda</code> 表达式（不知不觉想起了俄罗斯套娃🤔）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回 function 对象的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> get_function = [](<span class="keyword">int</span> x) -&gt; <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用 function 为对象作为其参数的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> param_function = [](<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &amp;f, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> f(n) * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> ans = param_function(get_function(<span class="number">2</span>), <span class="number">3</span>); <span class="comment">// x = 2, n = 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.  总结"></a>5.  总结</h1><p>写到此处，关于 <code>C++</code> 的 <code>lambda</code> 语法规范和用法已经学习了一小部分，它作为一种方便灵活的方法随用随学也是阔以的。</p>
<blockquote>
<p>因为参数类型和函数模板参数一样可以被推导而无需和具体参数类型耦合，有利于重构代码；和使用auto声明变量的作用类似，它也允许避免书写过于复杂的参数类型。特别地，不需要显式指出参数类型使得使用高阶函数变得更加容易。</p>
</blockquote>
<p>以下程序源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/8/30.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/8/30 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b) <span class="keyword">mutable</span> <span class="keyword">throw</span>() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="comment">// lambda 表达式函数体，在这里做到了将输入数组升序排列</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(b));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">// &gt;: 1 -1 2 3 4 5 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>; <span class="comment">// 在上文中声明好变量 num</span></span><br><span class="line">    <span class="keyword">auto</span> f = [n = num]() &#123; <span class="comment">// 在下文中通过 捕获[] 来获取 num，并在 lambda 函数体中进行使用</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; ++num &lt;&lt; std::endl; // 错误的使用，因为 num 是不可变的常量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    f(); <span class="comment">// &gt;: 1</span></span><br><span class="line">    <span class="keyword">auto</span> m = [num]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 将内部变量声明成 mutable 可变类型，此时可以修改内部变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    m(); <span class="comment">// &gt;: 2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> y = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; y(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// &gt;: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> empty = [] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Wow!空的~&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 啥也没有只有个函数体&#125;;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    empty(); <span class="comment">// &gt;: Wow!空的~</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个函数，然后直接使用 (5, 3)</span></span><br><span class="line">    <span class="keyword">int</span> n = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两层 lambda 嵌套，看起来挺花里胡哨</span></span><br><span class="line">    <span class="keyword">auto</span> embed_embed_lambda = [](<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; - - &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> [](<span class="keyword">int</span> c) &#123; <span class="keyword">return</span> c / <span class="number">2</span>; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; embed_embed_lambda(<span class="number">2</span>)(<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &gt;: 2 - - 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 function 对象的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> get_function = [](<span class="keyword">int</span> x) -&gt; <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 function 为对象作为其参数的 lambda 表达式</span></span><br><span class="line">    <span class="keyword">auto</span> param_function = [](<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; &amp;f, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> f(n) * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ans = param_function(get_function(<span class="number">2</span>), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT主题配置</title>
    <url>/2020/08/30/Hexo-NexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>首先安装</strong></p>
<p>首先安装好 <code>NexT</code> ，从 <a href="https://github.com/theme-next/hexo-theme-next">这里</a> 下载克隆最新的 <code>NexT</code> ，然后把内容解压到 <code>Hexo</code> 安装目录下的 <code>theses</code> 文件夹中，并且重命名为 <code>next</code>。</p>
<a id="more"></a>

<p><strong>配置文件</strong> </p>
<p>完成上面步骤后，在 <code>Hexo</code> 的安装目录下，有一个文件夹 <code>themes</code> 该文件夹中存放着主题文件，在 <code>themes\next\</code> 文件夹下有配置文件 <code>_config.yml</code> （以后称为 <strong>NexT 配置文件</strong>） ，在该文件中，内容可以说是巨大无比，抽取关键内容，可以对以下内容进行配置。NexT配置<a href="https://theme-next.org/docs/theme-settings/">详细文档</a></p>
<h2 id="1-网站图标"><a href="#1-网站图标" class="headerlink" title="1 网站图标"></a>1 网站图标</h2><p>找到自己中意的图标后，先调整尺寸，一般都是 <code>16 * 16</code> 用作网站小图标，<code>32 * 32</code> 及以上用作站点图标（用户头像类似），然后保存在 <code>&#123;Hexo_home&#125;\source\image\</code> 下。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/icon-16.png</span>            <span class="comment"># 小图标</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/icon-32.png</span>           <span class="comment"># 中等图标</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/icon-32.png</span> <span class="comment"># 适配 Apple 设备</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/icon.svg</span>   <span class="comment"># safari 浏览器的小图标，需要用 svg 格式</span></span><br></pre></td></tr></table></figure>

<h2 id="2-版权声明"><a href="#2-版权声明" class="headerlink" title="2. 版权声明"></a>2. 版权声明</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="3-主题样式以及暗黑模式"><a href="#3-主题样式以及暗黑模式" class="headerlink" title="3. 主题样式以及暗黑模式"></a>3. 主题样式以及暗黑模式</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模式</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暗黑模式</span></span><br><span class="line"><span class="attr">darkmode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="4-菜单栏"><a href="#4-菜单栏" class="headerlink" title="4. 菜单栏"></a>4. 菜单栏</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否打开某一个菜单栏，打开的话只需要将前面的 # 注释去掉</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment"># sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment"># commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否显示图标、是否显示角标</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="5-社交链接"><a href="#5-社交链接" class="headerlink" title="5. 社交链接"></a>5. 社交链接</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据需要进行添加就好了</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/hxz1998</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">huxz1998@163.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br></pre></td></tr></table></figure>

<h2 id="6-阅读更多（Read-More）"><a href="#6-阅读更多（Read-More）" class="headerlink" title="6. 阅读更多（Read More）"></a>6. 阅读更多（Read More）</h2><p>这个功能类似于 <strong>全文展开</strong> ，第一步打开 <strong>阅读全文</strong> 按钮：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">read_more_btn:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>第二步，在某一个文章中，添加 <code>&lt;!-- more --&gt;</code> 标签，该标签前面的内容将会被展示，后面的内容将会被折叠。</p>
<h2 id="7-字数统计，阅读时长-amp-本地查询"><a href="#7-字数统计，阅读时长-amp-本地查询" class="headerlink" title="7. 字数统计，阅读时长 &amp; 本地查询"></a>7. 字数统计，阅读时长 &amp; 本地查询</h2><p>参考 <strong>配置Hexo</strong> 一文。</p>
<h2 id="8-访客统计"><a href="#8-访客统计" class="headerlink" title="8. 访客统计"></a>8. 访客统计</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span>      </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>              <span class="comment"># 首先打开该插件</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>      <span class="comment"># 是否显示访客</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span> <span class="comment"># 该数字前面的图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>         <span class="comment"># 总浏览量</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span>     <span class="comment"># 还是图标~</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>          <span class="comment"># 文章浏览量</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span>      <span class="comment"># 仍旧是图标</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <url>/2020/08/28/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1. 准备环境"></a>1. 准备环境</h1><p>所需软件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.js	-&gt; v12.18.3</span><br><span class="line">npm     -&gt; 6.14.6 </span><br><span class="line">Git     -&gt; 2.16.2.windows1</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 <code>Hexo</code></h1><p>首先在自己的磁盘里创建一个目录，例如 <code>C:\Blog</code>，打开命令行工具，然后输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:                      <span class="comment"># 进入C盘</span></span><br><span class="line"><span class="built_in">cd</span> Blog	                <span class="comment"># 进入 Blog 文件夹</span></span><br><span class="line">npm install -g hexo-cli <span class="comment"># 安装 hexo 这个过程超级漫长，建议去喝一杯咖啡，如果没有修改 npm 的镜像源的话</span></span><br></pre></td></tr></table></figure>
<p>假如上面的过程没有出现什么幺蛾子，没有报错，也没有警告，那么恭喜，现在来到了 <code>hexo</code> 软件。</p>
<h1 id="3-在-Github-创建-Pages"><a href="#3-在-Github-创建-Pages" class="headerlink" title="3. 在 Github 创建 Pages"></a>3. 在 <code>Github</code> 创建 <code>Pages</code></h1><p>这里有两种创建的方法，可以创建<strong>仓库</strong>归属的 <code>Pages</code>，也可以创建<strong>帐户</strong>归属的 <code>Pages</code>，这里创建的是后者（账户归属），不为别的，因为好看。两者的区别主要在：</p>
<ol>
<li>仓库归属的最终访问路径为：<code>https://github.com/&#123;username&#125;/&#123;repo&#125;</code></li>
<li>账户归属的最终访问路径为：<code>https://&#123;username&#125;.github.io/</code></li>
</ol>
<p>在创建过程中，需要把仓库名称设置为自己的账户名称这样才能实现上面的第二种。</p>
<h1 id="4-创建本地博客并本地预览"><a href="#4-创建本地博客并本地预览" class="headerlink" title="4. 创建本地博客并本地预览"></a>4. 创建本地博客并本地预览</h1><p>回到第 2 步的命令行中，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog     <span class="comment"># 初始化博客仓库</span></span><br><span class="line">hexo new HelloHexo <span class="comment"># 创建第一篇文章</span></span><br></pre></td></tr></table></figure>

<p>然后可以到目录 <code>C:\Blog\source\_post</code> 目录下看到 <code>HelloHexo.md</code> 文件，找一个称手的 <code>MarkDown</code> 编辑器，通过修改该文件内容来完成内容编写。</p>
<p>修改完成后，继续回到上面的命令行中，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean    <span class="comment"># （可选）清除缓存，方便后面重新生成 hexo c</span></span><br><span class="line">hexo generate <span class="comment"># 生成相关页面，也可以 hexo g</span></span><br><span class="line">hexo server   <span class="comment"># 启动本地预览，也可以 hexo s</span></span><br></pre></td></tr></table></figure>

<p>然后就可以在 <code>http://localhost:4000/</code> 中看到自己的博客预览了，如果成功看到，那么恭喜，可以再喝一杯咖啡了😝。</p>
<h1 id="5-2020年9月1日更新"><a href="#5-2020年9月1日更新" class="headerlink" title="5.  2020年9月1日更新"></a>5.  2020年9月1日更新</h1><p>当使用 <code>hexo s</code> 来启动本地服务，然后进去网页报类似于 <code>(node:23020) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency</code> 错误时，需要将 <code>node</code> 从 <code>14</code> 版本降为 <code>12</code> 版本。</p>
<p>如果在 <code>git bash</code> 中使用 <code>Ctrl + c</code> 快捷键终止服务未响应的话，需要更新 <code>git</code> 。</p>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World！</title>
    <url>/2020/08/27/hello-world/</url>
    <content><![CDATA[<h2 id="震惊！-○´･д･-ﾉ"><a href="#震惊！-○´･д･-ﾉ" class="headerlink" title="震惊！(○´･д･)ﾉ"></a>震惊！(○´･д･)ﾉ</h2><p>咩哈哈哈哈哈，可可可可算弄好了。<br>明天见~我的宝宝理。</p>
<h2 id="晚安安"><a href="#晚安安" class="headerlink" title="晚安安"></a>晚安安</h2><blockquote>
<p>晚安啦，我亲爱的宝贝~爱你爱你。</p>
</blockquote>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>初出茅庐</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Hexo</title>
    <url>/2020/08/29/%E9%85%8D%E7%BD%AEHexo/</url>
    <content><![CDATA[<p><strong>配置文件 <code>_config.yml</code></strong></p>
<p>在 <code>Hexo</code> 的安装目录下， 有一个文件 <code>_config.yml</code> （以后称为 <strong>Hexo 配置文件</strong> ，在该文件中，可以对以以下内容进行配置。</p>
<a id="more"></a>

<h2 id="1-站点信息"><a href="#1-站点信息" class="headerlink" title="1. 站点信息"></a>1. 站点信息</h2><p>在这个配置中，可以对站点的基本信息进行修改。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">CHerrY</span> <span class="comment"># 站点标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;门前大桥下，C#C++，快来快来数一数，Java煮青蛙~&#x27;</span>  <span class="comment"># 子标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;算法分析，基础架构&#x27;</span> <span class="comment"># 站点描述，用来展示给访客的</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&#x27;算法分析分享，技术博客，LeetCode，个人博客&#x27;</span>  <span class="comment"># 给搜索引擎用的</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">CHerrY</span>  <span class="comment"># 作者信息，博客中的作者默认署名</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment"># 语言信息，Hexo支持多种语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span>    <span class="comment"># 时区配置，默认使用计算机的当地时间</span></span><br></pre></td></tr></table></figure>

<h2 id="2-URL-配置"><a href="#2-URL-配置" class="headerlink" title="2. URL 配置"></a>2. <code>URL</code> 配置</h2><p>该配置将会影响到博客内 <strong>图片</strong> 的访问、外链等信息。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://hxz1998.github.io/</span> <span class="comment"># 站点域名，如果有的话可以设置自己的域名</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span>                         <span class="comment"># 配置根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>  <span class="comment"># URL 组成格式</span></span><br></pre></td></tr></table></figure>

<h2 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3. 扩展"></a>3. 扩展</h2><p>对 <code>Hexo</code> 进行扩展所用到的配置，每一个插件需要去查看插件自己的说明文档。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插件扩展到： https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment"># 主题扩展到： https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span> <span class="comment"># 设置主题为 next</span></span><br></pre></td></tr></table></figure>

<h2 id="4-部署分发"><a href="#4-部署分发" class="headerlink" title="4. 部署分发"></a>4. 部署分发</h2><p>将博客部署到哪里，就配置这里~</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span> <span class="comment"># 部署服务类型，在这里我使用的是 Github 和 Gitee，因此选 git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># 仓库名称“们”，之所以使用“们”，是因为可以同步多个git仓库</span></span><br><span class="line">    <span class="attr">gitee:</span> <span class="string">https://gitee.com/hxz1998/hxz1998.git</span>  </span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://github.com/hxz1998/hxz1998.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<h2 id="5-字数统计，阅读时长（可选）"><a href="#5-字数统计，阅读时长（可选）" class="headerlink" title="5. 字数统计，阅读时长（可选）"></a>5. 字数统计，阅读时长（可选）</h2><p><strong>下面内容在Hexo配置文件中并不存在，别害怕，自己添加就完事儿了。</strong> 这里主要对博客的一些额外的功能进行配置，需要结合 <code>hexo-symbols-count-time</code> 插件进行使用。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>     <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure>

<h3 id="5-1-hexo-symbols-count-time-安装"><a href="#5-1-hexo-symbols-count-time-安装" class="headerlink" title="5.1 hexo-symbols-count-time 安装"></a>5.1 <code>hexo-symbols-count-time</code> 安装</h3><p>打开心心念念的命令行终端，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time	<span class="comment"># 过程很快，没有多大</span></span><br></pre></td></tr></table></figure>

<p>等待安装完成，<strong>重新生成</strong> 、启动 <code>Hexo</code> 即可查看效果。</p>
<h3 id="5-2-配置-NexT-中的内容"><a href="#5-2-配置-NexT-中的内容" class="headerlink" title="5.2 配置 NexT 中的内容"></a>5.2 配置 <code>NexT</code> 中的内容</h3><p>将 <code>symbol_count_time</code> 启用：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>   <span class="comment"># 分隔的元数据</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>   <span class="comment"># 文章字数 </span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span> <span class="comment"># 总字数</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>                 <span class="comment"># 平均字长（字符以字为单位）</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>               <span class="comment"># 每分钟字数</span></span><br></pre></td></tr></table></figure>

<p>上面的数字都可以修改，当然，还可以参考来自 <a href="https://github.com/theme-next/hexo-symbols-count-time">官方</a> 指导：</p>
<blockquote>
<p><strong>注意对于中国用户：</strong>因为在有关中国语文平均字长<code>~1.5</code>，如果你在大多数情况下，写中国的职位（不含混合英文），建议设置<code>awl</code>到<code>2</code>和<code>wpm</code>到<code>300</code>。<br>但是，如果您通常将自己的帖子与英语混在一起，则<code>awl</code>to <code>4</code>和<code>wpm</code>to <code>275</code>会很好。</p>
</blockquote>
<h2 id="6-搜索（可选）"><a href="#6-搜索（可选）" class="headerlink" title="6. 搜索（可选）"></a>6. 搜索（可选）</h2><p>同样的，这是一个在 <strong>Hexo配置文件中并不存在的内容，需要额外添加。</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span> </span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span>  <span class="comment"># 将搜索索引放到哪里</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span>       <span class="comment"># 搜索字段</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span>     <span class="comment"># 是否检索内容</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span>      <span class="comment"># 生成格式</span></span><br></pre></td></tr></table></figure>

<p> 配置完之后，仍然需要额外配置 <code>NexT</code> 主题的配置文件 <code>next\_config.xml</code> 才可以生效。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span>	</span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>	</span><br></pre></td></tr></table></figure>

<h3 id="6-1-hexo-generator-searchdb-安装"><a href="#6-1-hexo-generator-searchdb-安装" class="headerlink" title="6.1 hexo-generator-searchdb 安装"></a>6.1 <code>hexo-generator-searchdb</code> 安装</h3><p>继续使用上面心心念念的终端，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p>等待安装完成，<strong>重新生成</strong> 、再次启动 <code>Hexo</code> 即可查看效果。</p>
<h2 id="7-标签云"><a href="#7-标签云" class="headerlink" title="7. 标签云"></a>7. 标签云</h2><p>首先要建立存放标签的页面，打开喜欢用的命令行终端，并输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure>

<p>然后就可以在 <code>Hexo_home\source\</code> 文件夹下看到有 <code>tags\index.md</code> 文件，对该文件进行修改成如下内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 标签云              # 展示标题</span><br><span class="line">date: 2020-08-27 23:03:38 # 创建时间，一般不需要改</span><br><span class="line">type: &quot;tags&quot;              # <span class="xml"><span class="tag">&lt;<span class="name">---</span> 这个才是添加的重点！</span></span></span><br></pre></td></tr></table></figure>

<p>然后刷新就可以在主页面菜单中看到 <strong>标签</strong> 这一栏了。</p>
<h2 id="8-分类"><a href="#8-分类" class="headerlink" title="8. 分类"></a>8. 分类</h2><p>对于分类页面的建立，和上面 <strong>第七条</strong> 一样。</p>
]]></content>
      <categories>
        <category>捣鼓小玩意儿</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>unordered_map和map的区别</title>
    <url>/2020/09/01/unordered-map%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>哈希表</tag>
        <tag>Map</tag>
      </tags>
  </entry>
</search>
